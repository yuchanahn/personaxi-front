/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const xe="167",uc=0,cc=1,dc=2;const Ps="attached",xa="detached";const pc=303,fc=1e3,mc=1001,gc=1002,yc=1003,xc=1004,_c=1005,Mc=1006,vc=1007,wc=1008;const bc=2300,Sc=2301;const Tc=0,Ac=1,Rc=2,Ec=0,so="",zt="srgb",Hn="srgb-linear",_a="display-p3",ro="display-p3-linear",Ln="linear",Is="srgb",Ls="rec709",Cs="p3";class ki{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const n=this._listeners[t];if(n!==void 0){const r=n.indexOf(e);r!==-1&&n.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const i=this._listeners[t.type];if(i!==void 0){t.target=this;const n=i.slice(0);for(let r=0,o=n.length;r<o;r++)n[r].call(this,t);t.target=null}}}const Y=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Bs=1234567;const ke=Math.PI/180,We=180/Math.PI;function dt(){const s=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Y[s&255]+Y[s>>8&255]+Y[s>>16&255]+Y[s>>24&255]+"-"+Y[t&255]+Y[t>>8&255]+"-"+Y[t>>16&15|64]+Y[t>>24&255]+"-"+Y[e&63|128]+Y[e>>8&255]+"-"+Y[e>>16&255]+Y[e>>24&255]+Y[i&255]+Y[i>>8&255]+Y[i>>16&255]+Y[i>>24&255]).toLowerCase()}function X(s,t,e){return Math.max(t,Math.min(e,s))}function jn(s,t){return(s%t+t)%t}function Ma(s,t,e,i,n){return i+(s-t)*(n-i)/(e-t)}function va(s,t,e){return s!==t?(e-s)/(t-s):0}function De(s,t,e){return(1-e)*s+e*t}function wa(s,t,e,i){return De(s,t,1-Math.exp(-e*i))}function ba(s,t=1){return t-Math.abs(jn(s,t*2)-t)}function Sa(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t),s*s*(3-2*s))}function Ta(s,t,e){return s<=t?0:s>=e?1:(s=(s-t)/(e-t),s*s*s*(s*(s*6-15)+10))}function Aa(s,t){return s+Math.floor(Math.random()*(t-s+1))}function Ra(s,t){return s+Math.random()*(t-s)}function Ea(s){return s*(.5-Math.random())}function Pa(s){s!==void 0&&(Bs=s);let t=Bs+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function Ia(s){return s*ke}function La(s){return s*We}function Ca(s){return(s&s-1)===0&&s!==0}function Ba(s){return Math.pow(2,Math.ceil(Math.log(s)/Math.LN2))}function Fa(s){return Math.pow(2,Math.floor(Math.log(s)/Math.LN2))}function za(s,t,e,i,n){const r=Math.cos,o=Math.sin,l=r(e/2),a=o(e/2),h=r((t+i)/2),u=o((t+i)/2),c=r((t-i)/2),d=o((t-i)/2),p=r((i-t)/2),f=o((i-t)/2);switch(n){case"XYX":s.set(l*u,a*c,a*d,l*h);break;case"YZY":s.set(a*d,l*u,a*c,l*h);break;case"ZXZ":s.set(a*c,a*d,l*u,l*h);break;case"XZX":s.set(l*u,a*f,a*p,l*h);break;case"YXY":s.set(a*p,l*u,a*f,l*h);break;case"ZYZ":s.set(a*f,a*p,l*u,l*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}function ct(s,t){switch(t.constructor){case Float32Array:return s;case Uint32Array:return s/4294967295;case Uint16Array:return s/65535;case Uint8Array:return s/255;case Int32Array:return Math.max(s/2147483647,-1);case Int16Array:return Math.max(s/32767,-1);case Int8Array:return Math.max(s/127,-1);default:throw new Error("Invalid component type.")}}function N(s,t){switch(t.constructor){case Float32Array:return s;case Uint32Array:return Math.round(s*4294967295);case Uint16Array:return Math.round(s*65535);case Uint8Array:return Math.round(s*255);case Int32Array:return Math.round(s*2147483647);case Int16Array:return Math.round(s*32767);case Int8Array:return Math.round(s*127);default:throw new Error("Invalid component type.")}}const W={DEG2RAD:ke,RAD2DEG:We,generateUUID:dt,clamp:X,euclideanModulo:jn,mapLinear:Ma,inverseLerp:va,lerp:De,damp:wa,pingpong:ba,smoothstep:Sa,smootherstep:Ta,randInt:Aa,randFloat:Ra,randFloatSpread:Ea,seededRandom:Pa,degToRad:Ia,radToDeg:La,isPowerOfTwo:Ca,ceilPowerOfTwo:Ba,floorPowerOfTwo:Fa,setQuaternionFromProperEuler:za,normalize:N,denormalize:ct};class F{constructor(t=0,e=0){F.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6],this.y=n[1]*e+n[4]*i+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(X(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),n=Math.sin(e),r=this.x-t.x,o=this.y-t.y;return this.x=r*i-o*n+t.x,this.y=r*n+o*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class U{constructor(t,e,i,n,r,o,l,a,h){U.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,i,n,r,o,l,a,h)}set(t,e,i,n,r,o,l,a,h){const u=this.elements;return u[0]=t,u[1]=n,u[2]=l,u[3]=e,u[4]=r,u[5]=a,u[6]=i,u[7]=o,u[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,r=this.elements,o=i[0],l=i[3],a=i[6],h=i[1],u=i[4],c=i[7],d=i[2],p=i[5],f=i[8],m=n[0],y=n[3],x=n[6],w=n[1],M=n[4],_=n[7],v=n[2],S=n[5],b=n[8];return r[0]=o*m+l*w+a*v,r[3]=o*y+l*M+a*S,r[6]=o*x+l*_+a*b,r[1]=h*m+u*w+c*v,r[4]=h*y+u*M+c*S,r[7]=h*x+u*_+c*b,r[2]=d*m+p*w+f*v,r[5]=d*y+p*M+f*S,r[8]=d*x+p*_+f*b,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],o=t[4],l=t[5],a=t[6],h=t[7],u=t[8];return e*o*u-e*l*h-i*r*u+i*l*a+n*r*h-n*o*a}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],o=t[4],l=t[5],a=t[6],h=t[7],u=t[8],c=u*o-l*h,d=l*a-u*r,p=h*r-o*a,f=e*c+i*d+n*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=c*m,t[1]=(n*h-u*i)*m,t[2]=(l*i-n*o)*m,t[3]=d*m,t[4]=(u*e-n*a)*m,t[5]=(n*r-l*e)*m,t[6]=p*m,t[7]=(i*a-h*e)*m,t[8]=(o*e-i*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,n,r,o,l){const a=Math.cos(r),h=Math.sin(r);return this.set(i*a,i*h,-i*(a*o+h*l)+o+t,-n*h,n*a,-n*(-h*o+a*l)+l+e,0,0,1),this}scale(t,e){return this.premultiply(Zi.makeScale(t,e)),this}rotate(t){return this.premultiply(Zi.makeRotation(-t)),this}translate(t,e){return this.premultiply(Zi.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<9;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const Zi=new U;function Na(s){for(let t=s.length-1;t>=0;--t)if(s[t]>=65535)return!0;return!1}function Cn(s){return document.createElementNS("http://www.w3.org/1999/xhtml",s)}const Fs={};function oo(s){s in Fs||(Fs[s]=!0,console.warn(s))}const zs=new U().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),Ns=new U().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Se={[Hn]:{transfer:Ln,primaries:Ls,luminanceCoefficients:[.2126,.7152,.0722],toReference:s=>s,fromReference:s=>s},[zt]:{transfer:Is,primaries:Ls,luminanceCoefficients:[.2126,.7152,.0722],toReference:s=>s.convertSRGBToLinear(),fromReference:s=>s.convertLinearToSRGB()},[ro]:{transfer:Ln,primaries:Cs,luminanceCoefficients:[.2289,.6917,.0793],toReference:s=>s.applyMatrix3(Ns),fromReference:s=>s.applyMatrix3(zs)},[_a]:{transfer:Is,primaries:Cs,luminanceCoefficients:[.2289,.6917,.0793],toReference:s=>s.convertSRGBToLinear().applyMatrix3(Ns),fromReference:s=>s.applyMatrix3(zs).convertLinearToSRGB()}},Oa=new Set([Hn,ro]),at={enabled:!0,_workingColorSpace:Hn,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(s){if(!Oa.has(s))throw new Error(`Unsupported working color space, "${s}".`);this._workingColorSpace=s},convert:function(s,t,e){if(this.enabled===!1||t===e||!t||!e)return s;const i=Se[t].toReference,n=Se[e].fromReference;return n(i(s))},fromWorkingColorSpace:function(s,t){return this.convert(s,this._workingColorSpace,t)},toWorkingColorSpace:function(s,t){return this.convert(s,t,this._workingColorSpace)},getPrimaries:function(s){return Se[s].primaries},getTransfer:function(s){return s===so?Ln:Se[s].transfer},getLuminanceCoefficients:function(s,t=this._workingColorSpace){return s.fromArray(Se[t].luminanceCoefficients)}};function ye(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function $i(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}let $t;class Va{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{$t===void 0&&($t=Cn("canvas")),$t.width=t.width,$t.height=t.height;const i=$t.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=$t}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Cn("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const n=i.getImageData(0,0,t.width,t.height),r=n.data;for(let o=0;o<r.length;o++)r[o]=ye(r[o]/255)*255;return i.putImageData(n,0,0),e}else if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(ye(e[i]/255)*255):e[i]=ye(e[i]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let Ua=0;class ka{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Ua++}),this.uuid=dt(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},n=this.data;if(n!==null){let r;if(Array.isArray(n)){r=[];for(let o=0,l=n.length;o<l;o++)n[o].isDataTexture?r.push(Ji(n[o].image)):r.push(Ji(n[o]))}else r=Ji(n);i.url=r}return e||(t.images[this.uuid]=i),i}}function Ji(s){return typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&s instanceof ImageBitmap?Va.getDataURL(s):s.data?{data:Array.from(s.data),width:s.width,height:s.height,type:s.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Da=0;class At extends ki{constructor(t=At.DEFAULT_IMAGE,e=At.DEFAULT_MAPPING,i=1001,n=1001,r=1006,o=1008,l=1023,a=1009,h=At.DEFAULT_ANISOTROPY,u=so){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Da++}),this.uuid=dt(),this.name="",this.source=new ka(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=i,this.wrapT=n,this.magFilter=r,this.minFilter=o,this.anisotropy=h,this.format=l,this.internalFormat=null,this.type=a,this.offset=new F(0,0),this.repeat=new F(1,1),this.center=new F(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new U,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==300)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}At.DEFAULT_IMAGE=null;At.DEFAULT_MAPPING=300;At.DEFAULT_ANISOTROPY=1;class rt{constructor(t=0,e=0,i=0,n=1){rt.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,n){return this.x=t,this.y=e,this.z=i,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,r=this.w,o=t.elements;return this.x=o[0]*e+o[4]*i+o[8]*n+o[12]*r,this.y=o[1]*e+o[5]*i+o[9]*n+o[13]*r,this.z=o[2]*e+o[6]*i+o[10]*n+o[14]*r,this.w=o[3]*e+o[7]*i+o[11]*n+o[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,n,r;const a=t.elements,h=a[0],u=a[4],c=a[8],d=a[1],p=a[5],f=a[9],m=a[2],y=a[6],x=a[10];if(Math.abs(u-d)<.01&&Math.abs(c-m)<.01&&Math.abs(f-y)<.01){if(Math.abs(u+d)<.1&&Math.abs(c+m)<.1&&Math.abs(f+y)<.1&&Math.abs(h+p+x-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const M=(h+1)/2,_=(p+1)/2,v=(x+1)/2,S=(u+d)/4,b=(c+m)/4,T=(f+y)/4;return M>_&&M>v?M<.01?(i=0,n=.707106781,r=.707106781):(i=Math.sqrt(M),n=S/i,r=b/i):_>v?_<.01?(i=.707106781,n=0,r=.707106781):(n=Math.sqrt(_),i=S/n,r=T/n):v<.01?(i=.707106781,n=.707106781,r=0):(r=Math.sqrt(v),i=b/r,n=T/r),this.set(i,n,r,e),this}let w=Math.sqrt((y-f)*(y-f)+(c-m)*(c-m)+(d-u)*(d-u));return Math.abs(w)<.001&&(w=1),this.x=(y-f)/w,this.y=(c-m)/w,this.z=(d-u)/w,this.w=Math.acos((h+p+x-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class I{constructor(t=0,e=0,i=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=n}static slerpFlat(t,e,i,n,r,o,l){let a=i[n+0],h=i[n+1],u=i[n+2],c=i[n+3];const d=r[o+0],p=r[o+1],f=r[o+2],m=r[o+3];if(l===0){t[e+0]=a,t[e+1]=h,t[e+2]=u,t[e+3]=c;return}if(l===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(c!==m||a!==d||h!==p||u!==f){let y=1-l;const x=a*d+h*p+u*f+c*m,w=x>=0?1:-1,M=1-x*x;if(M>Number.EPSILON){const v=Math.sqrt(M),S=Math.atan2(v,x*w);y=Math.sin(y*S)/v,l=Math.sin(l*S)/v}const _=l*w;if(a=a*y+d*_,h=h*y+p*_,u=u*y+f*_,c=c*y+m*_,y===1-l){const v=1/Math.sqrt(a*a+h*h+u*u+c*c);a*=v,h*=v,u*=v,c*=v}}t[e]=a,t[e+1]=h,t[e+2]=u,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,n,r,o){const l=i[n],a=i[n+1],h=i[n+2],u=i[n+3],c=r[o],d=r[o+1],p=r[o+2],f=r[o+3];return t[e]=l*f+u*c+a*p-h*d,t[e+1]=a*f+u*d+h*c-l*p,t[e+2]=h*f+u*p+l*d-a*c,t[e+3]=u*f-l*c-a*d-h*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,n){return this._x=t,this._y=e,this._z=i,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,n=t._y,r=t._z,o=t._order,l=Math.cos,a=Math.sin,h=l(i/2),u=l(n/2),c=l(r/2),d=a(i/2),p=a(n/2),f=a(r/2);switch(o){case"XYZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"YXZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"ZXY":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"ZYX":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"YZX":this._x=d*u*c+h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c-d*p*f;break;case"XZY":this._x=d*u*c-h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,n=Math.sin(i);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],n=e[4],r=e[8],o=e[1],l=e[5],a=e[9],h=e[2],u=e[6],c=e[10],d=i+l+c;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-a)*p,this._y=(r-h)*p,this._z=(o-n)*p}else if(i>l&&i>c){const p=2*Math.sqrt(1+i-l-c);this._w=(u-a)/p,this._x=.25*p,this._y=(n+o)/p,this._z=(r+h)/p}else if(l>c){const p=2*Math.sqrt(1+l-i-c);this._w=(r-h)/p,this._x=(n+o)/p,this._y=.25*p,this._z=(a+u)/p}else{const p=2*Math.sqrt(1+c-i-l);this._w=(o-n)/p,this._x=(r+h)/p,this._y=(a+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(X(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const n=Math.min(1,e/i);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,n=t._y,r=t._z,o=t._w,l=e._x,a=e._y,h=e._z,u=e._w;return this._x=i*u+o*l+n*h-r*a,this._y=n*u+o*a+r*l-i*h,this._z=r*u+o*h+i*a-n*l,this._w=o*u-i*l-n*a-r*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,n=this._y,r=this._z,o=this._w;let l=o*t._w+i*t._x+n*t._y+r*t._z;if(l<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,l=-l):this.copy(t),l>=1)return this._w=o,this._x=i,this._y=n,this._z=r,this;const a=1-l*l;if(a<=Number.EPSILON){const p=1-e;return this._w=p*o+e*this._w,this._x=p*i+e*this._x,this._y=p*n+e*this._y,this._z=p*r+e*this._z,this.normalize(),this}const h=Math.sqrt(a),u=Math.atan2(h,l),c=Math.sin((1-e)*u)/h,d=Math.sin(e*u)/h;return this._w=o*c+this._w*d,this._x=i*c+this._x*d,this._y=n*c+this._y*d,this._z=r*c+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),n=Math.sqrt(1-i),r=Math.sqrt(i);return this.set(n*Math.sin(t),n*Math.cos(t),r*Math.sin(e),r*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class g{constructor(t=0,e=0,i=0){g.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Os.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Os.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*n,this.y=r[1]*e+r[4]*i+r[7]*n,this.z=r[2]*e+r[5]*i+r[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,n=this.z,r=t.elements,o=1/(r[3]*e+r[7]*i+r[11]*n+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*n+r[12])*o,this.y=(r[1]*e+r[5]*i+r[9]*n+r[13])*o,this.z=(r[2]*e+r[6]*i+r[10]*n+r[14])*o,this}applyQuaternion(t){const e=this.x,i=this.y,n=this.z,r=t.x,o=t.y,l=t.z,a=t.w,h=2*(o*n-l*i),u=2*(l*e-r*n),c=2*(r*i-o*e);return this.x=e+a*h+o*c-l*u,this.y=i+a*u+l*h-r*c,this.z=n+a*c+r*u-o*h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*n,this.y=r[1]*e+r[5]*i+r[9]*n,this.z=r[2]*e+r[6]*i+r[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,n=t.y,r=t.z,o=e.x,l=e.y,a=e.z;return this.x=n*a-r*l,this.y=r*o-i*a,this.z=i*l-n*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return Qi.copy(this).projectOnVector(t),this.sub(Qi)}reflect(t){return this.sub(Qi.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(X(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,n=this.z-t.z;return e*e+i*i+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const n=Math.sin(e)*t;return this.x=n*Math.sin(i),this.y=Math.cos(e)*t,this.z=n*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Qi=new g,Os=new I;class Ot{constructor(t=new g(1/0,1/0,1/0),e=new g(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(lt.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(lt.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=lt.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0){const r=i.getAttribute("position");if(e===!0&&r!==void 0&&t.isInstancedMesh!==!0)for(let o=0,l=r.count;o<l;o++)t.isMesh===!0?t.getVertexPosition(o,lt):lt.fromBufferAttribute(r,o),lt.applyMatrix4(t.matrixWorld),this.expandByPoint(lt);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Ke.copy(t.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),Ke.copy(i.boundingBox)),Ke.applyMatrix4(t.matrixWorld),this.union(Ke)}const n=t.children;for(let r=0,o=n.length;r<o;r++)this.expandByObject(n[r],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,lt),lt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Te),ti.subVectors(this.max,Te),Jt.subVectors(t.a,Te),Qt.subVectors(t.b,Te),Kt.subVectors(t.c,Te),Et.subVectors(Qt,Jt),Pt.subVectors(Kt,Qt),Dt.subVectors(Jt,Kt);let e=[0,-Et.z,Et.y,0,-Pt.z,Pt.y,0,-Dt.z,Dt.y,Et.z,0,-Et.x,Pt.z,0,-Pt.x,Dt.z,0,-Dt.x,-Et.y,Et.x,0,-Pt.y,Pt.x,0,-Dt.y,Dt.x,0];return!Ki(e,Jt,Qt,Kt,ti)||(e=[1,0,0,0,1,0,0,0,1],!Ki(e,Jt,Qt,Kt,ti))?!1:(ei.crossVectors(Et,Pt),e=[ei.x,ei.y,ei.z],Ki(e,Jt,Qt,Kt,ti))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,lt).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(lt).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Mt[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Mt[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Mt[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Mt[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Mt[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Mt[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Mt[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Mt[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Mt),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const Mt=[new g,new g,new g,new g,new g,new g,new g,new g],lt=new g,Ke=new Ot,Jt=new g,Qt=new g,Kt=new g,Et=new g,Pt=new g,Dt=new g,Te=new g,ti=new g,ei=new g,Wt=new g;function Ki(s,t,e,i,n){for(let r=0,o=s.length-3;r<=o;r+=3){Wt.fromArray(s,r);const l=n.x*Math.abs(Wt.x)+n.y*Math.abs(Wt.y)+n.z*Math.abs(Wt.z),a=t.dot(Wt),h=e.dot(Wt),u=i.dot(Wt);if(Math.max(-Math.max(a,h,u),Math.min(a,h,u))>l)return!1}return!0}const Wa=new Ot,Ae=new g,tn=new g;class Rt{constructor(t=new g,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):Wa.setFromPoints(t).getCenter(i);let n=0;for(let r=0,o=t.length;r<o;r++)n=Math.max(n,i.distanceToSquared(t[r]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Ae.subVectors(t,this.center);const e=Ae.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),n=(i-this.radius)*.5;this.center.addScaledVector(Ae,n/i),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(tn.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Ae.copy(t.center).add(tn)),this.expandByPoint(Ae.copy(t.center).sub(tn))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const vt=new g,en=new g,ii=new g,It=new g,nn=new g,ni=new g,sn=new g;class Di{constructor(t=new g,e=new g(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,vt)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=vt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(vt.copy(this.origin).addScaledVector(this.direction,e),vt.distanceToSquared(t))}distanceSqToSegment(t,e,i,n){en.copy(t).add(e).multiplyScalar(.5),ii.copy(e).sub(t).normalize(),It.copy(this.origin).sub(en);const r=t.distanceTo(e)*.5,o=-this.direction.dot(ii),l=It.dot(this.direction),a=-It.dot(ii),h=It.lengthSq(),u=Math.abs(1-o*o);let c,d,p,f;if(u>0)if(c=o*a-l,d=o*l-a,f=r*u,c>=0)if(d>=-f)if(d<=f){const m=1/u;c*=m,d*=m,p=c*(c+o*d+2*l)+d*(o*c+d+2*a)+h}else d=r,c=Math.max(0,-(o*d+l)),p=-c*c+d*(d+2*a)+h;else d=-r,c=Math.max(0,-(o*d+l)),p=-c*c+d*(d+2*a)+h;else d<=-f?(c=Math.max(0,-(-o*r+l)),d=c>0?-r:Math.min(Math.max(-r,-a),r),p=-c*c+d*(d+2*a)+h):d<=f?(c=0,d=Math.min(Math.max(-r,-a),r),p=d*(d+2*a)+h):(c=Math.max(0,-(o*r+l)),d=c>0?r:Math.min(Math.max(-r,-a),r),p=-c*c+d*(d+2*a)+h);else d=o>0?-r:r,c=Math.max(0,-(o*d+l)),p=-c*c+d*(d+2*a)+h;return i&&i.copy(this.origin).addScaledVector(this.direction,c),n&&n.copy(en).addScaledVector(ii,d),p}intersectSphere(t,e){vt.subVectors(t.center,this.origin);const i=vt.dot(this.direction),n=vt.dot(vt)-i*i,r=t.radius*t.radius;if(n>r)return null;const o=Math.sqrt(r-n),l=i-o,a=i+o;return a<0?null:l<0?this.at(a,e):this.at(l,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,n,r,o,l,a;const h=1/this.direction.x,u=1/this.direction.y,c=1/this.direction.z,d=this.origin;return h>=0?(i=(t.min.x-d.x)*h,n=(t.max.x-d.x)*h):(i=(t.max.x-d.x)*h,n=(t.min.x-d.x)*h),u>=0?(r=(t.min.y-d.y)*u,o=(t.max.y-d.y)*u):(r=(t.max.y-d.y)*u,o=(t.min.y-d.y)*u),i>o||r>n||((r>i||isNaN(i))&&(i=r),(o<n||isNaN(n))&&(n=o),c>=0?(l=(t.min.z-d.z)*c,a=(t.max.z-d.z)*c):(l=(t.max.z-d.z)*c,a=(t.min.z-d.z)*c),i>a||l>n)||((l>i||i!==i)&&(i=l),(a<n||n!==n)&&(n=a),n<0)?null:this.at(i>=0?i:n,e)}intersectsBox(t){return this.intersectBox(t,vt)!==null}intersectTriangle(t,e,i,n,r){nn.subVectors(e,t),ni.subVectors(i,t),sn.crossVectors(nn,ni);let o=this.direction.dot(sn),l;if(o>0){if(n)return null;l=1}else if(o<0)l=-1,o=-o;else return null;It.subVectors(this.origin,t);const a=l*this.direction.dot(ni.crossVectors(It,ni));if(a<0)return null;const h=l*this.direction.dot(nn.cross(It));if(h<0||a+h>o)return null;const u=-l*It.dot(sn);return u<0?null:this.at(u/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class P{constructor(t,e,i,n,r,o,l,a,h,u,c,d,p,f,m,y){P.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,i,n,r,o,l,a,h,u,c,d,p,f,m,y)}set(t,e,i,n,r,o,l,a,h,u,c,d,p,f,m,y){const x=this.elements;return x[0]=t,x[4]=e,x[8]=i,x[12]=n,x[1]=r,x[5]=o,x[9]=l,x[13]=a,x[2]=h,x[6]=u,x[10]=c,x[14]=d,x[3]=p,x[7]=f,x[11]=m,x[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new P().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,n=1/te.setFromMatrixColumn(t,0).length(),r=1/te.setFromMatrixColumn(t,1).length(),o=1/te.setFromMatrixColumn(t,2).length();return e[0]=i[0]*n,e[1]=i[1]*n,e[2]=i[2]*n,e[3]=0,e[4]=i[4]*r,e[5]=i[5]*r,e[6]=i[6]*r,e[7]=0,e[8]=i[8]*o,e[9]=i[9]*o,e[10]=i[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,n=t.y,r=t.z,o=Math.cos(i),l=Math.sin(i),a=Math.cos(n),h=Math.sin(n),u=Math.cos(r),c=Math.sin(r);if(t.order==="XYZ"){const d=o*u,p=o*c,f=l*u,m=l*c;e[0]=a*u,e[4]=-a*c,e[8]=h,e[1]=p+f*h,e[5]=d-m*h,e[9]=-l*a,e[2]=m-d*h,e[6]=f+p*h,e[10]=o*a}else if(t.order==="YXZ"){const d=a*u,p=a*c,f=h*u,m=h*c;e[0]=d+m*l,e[4]=f*l-p,e[8]=o*h,e[1]=o*c,e[5]=o*u,e[9]=-l,e[2]=p*l-f,e[6]=m+d*l,e[10]=o*a}else if(t.order==="ZXY"){const d=a*u,p=a*c,f=h*u,m=h*c;e[0]=d-m*l,e[4]=-o*c,e[8]=f+p*l,e[1]=p+f*l,e[5]=o*u,e[9]=m-d*l,e[2]=-o*h,e[6]=l,e[10]=o*a}else if(t.order==="ZYX"){const d=o*u,p=o*c,f=l*u,m=l*c;e[0]=a*u,e[4]=f*h-p,e[8]=d*h+m,e[1]=a*c,e[5]=m*h+d,e[9]=p*h-f,e[2]=-h,e[6]=l*a,e[10]=o*a}else if(t.order==="YZX"){const d=o*a,p=o*h,f=l*a,m=l*h;e[0]=a*u,e[4]=m-d*c,e[8]=f*c+p,e[1]=c,e[5]=o*u,e[9]=-l*u,e[2]=-h*u,e[6]=p*c+f,e[10]=d-m*c}else if(t.order==="XZY"){const d=o*a,p=o*h,f=l*a,m=l*h;e[0]=a*u,e[4]=-c,e[8]=h*u,e[1]=d*c+m,e[5]=o*u,e[9]=p*c-f,e[2]=f*c-p,e[6]=l*u,e[10]=m*c+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ha,t,ja)}lookAt(t,e,i){const n=this.elements;return et.subVectors(t,e),et.lengthSq()===0&&(et.z=1),et.normalize(),Lt.crossVectors(i,et),Lt.lengthSq()===0&&(Math.abs(i.z)===1?et.x+=1e-4:et.z+=1e-4,et.normalize(),Lt.crossVectors(i,et)),Lt.normalize(),si.crossVectors(et,Lt),n[0]=Lt.x,n[4]=si.x,n[8]=et.x,n[1]=Lt.y,n[5]=si.y,n[9]=et.y,n[2]=Lt.z,n[6]=si.z,n[10]=et.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,n=e.elements,r=this.elements,o=i[0],l=i[4],a=i[8],h=i[12],u=i[1],c=i[5],d=i[9],p=i[13],f=i[2],m=i[6],y=i[10],x=i[14],w=i[3],M=i[7],_=i[11],v=i[15],S=n[0],b=n[4],T=n[8],E=n[12],A=n[1],R=n[5],L=n[9],z=n[13],G=n[2],$=n[6],tt=n[10],J=n[14],ot=n[3],ft=n[7],H=n[11],Ut=n[15];return r[0]=o*S+l*A+a*G+h*ot,r[4]=o*b+l*R+a*$+h*ft,r[8]=o*T+l*L+a*tt+h*H,r[12]=o*E+l*z+a*J+h*Ut,r[1]=u*S+c*A+d*G+p*ot,r[5]=u*b+c*R+d*$+p*ft,r[9]=u*T+c*L+d*tt+p*H,r[13]=u*E+c*z+d*J+p*Ut,r[2]=f*S+m*A+y*G+x*ot,r[6]=f*b+m*R+y*$+x*ft,r[10]=f*T+m*L+y*tt+x*H,r[14]=f*E+m*z+y*J+x*Ut,r[3]=w*S+M*A+_*G+v*ot,r[7]=w*b+M*R+_*$+v*ft,r[11]=w*T+M*L+_*tt+v*H,r[15]=w*E+M*z+_*J+v*Ut,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],n=t[8],r=t[12],o=t[1],l=t[5],a=t[9],h=t[13],u=t[2],c=t[6],d=t[10],p=t[14],f=t[3],m=t[7],y=t[11],x=t[15];return f*(+r*a*c-n*h*c-r*l*d+i*h*d+n*l*p-i*a*p)+m*(+e*a*p-e*h*d+r*o*d-n*o*p+n*h*u-r*a*u)+y*(+e*h*c-e*l*p-r*o*c+i*o*p+r*l*u-i*h*u)+x*(-n*l*u-e*a*c+e*l*d+n*o*c-i*o*d+i*a*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],n=t[2],r=t[3],o=t[4],l=t[5],a=t[6],h=t[7],u=t[8],c=t[9],d=t[10],p=t[11],f=t[12],m=t[13],y=t[14],x=t[15],w=c*y*h-m*d*h+m*a*p-l*y*p-c*a*x+l*d*x,M=f*d*h-u*y*h-f*a*p+o*y*p+u*a*x-o*d*x,_=u*m*h-f*c*h+f*l*p-o*m*p-u*l*x+o*c*x,v=f*c*a-u*m*a-f*l*d+o*m*d+u*l*y-o*c*y,S=e*w+i*M+n*_+r*v;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/S;return t[0]=w*b,t[1]=(m*d*r-c*y*r-m*n*p+i*y*p+c*n*x-i*d*x)*b,t[2]=(l*y*r-m*a*r+m*n*h-i*y*h-l*n*x+i*a*x)*b,t[3]=(c*a*r-l*d*r-c*n*h+i*d*h+l*n*p-i*a*p)*b,t[4]=M*b,t[5]=(u*y*r-f*d*r+f*n*p-e*y*p-u*n*x+e*d*x)*b,t[6]=(f*a*r-o*y*r-f*n*h+e*y*h+o*n*x-e*a*x)*b,t[7]=(o*d*r-u*a*r+u*n*h-e*d*h-o*n*p+e*a*p)*b,t[8]=_*b,t[9]=(f*c*r-u*m*r-f*i*p+e*m*p+u*i*x-e*c*x)*b,t[10]=(o*m*r-f*l*r+f*i*h-e*m*h-o*i*x+e*l*x)*b,t[11]=(u*l*r-o*c*r-u*i*h+e*c*h+o*i*p-e*l*p)*b,t[12]=v*b,t[13]=(u*m*n-f*c*n+f*i*d-e*m*d-u*i*y+e*c*y)*b,t[14]=(f*l*n-o*m*n-f*i*a+e*m*a+o*i*y-e*l*y)*b,t[15]=(o*c*n-u*l*n+u*i*a-e*c*a-o*i*d+e*l*d)*b,this}scale(t){const e=this.elements,i=t.x,n=t.y,r=t.z;return e[0]*=i,e[4]*=n,e[8]*=r,e[1]*=i,e[5]*=n,e[9]*=r,e[2]*=i,e[6]*=n,e[10]*=r,e[3]*=i,e[7]*=n,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,n))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),n=Math.sin(e),r=1-i,o=t.x,l=t.y,a=t.z,h=r*o,u=r*l;return this.set(h*o+i,h*l-n*a,h*a+n*l,0,h*l+n*a,u*l+i,u*a-n*o,0,h*a-n*l,u*a+n*o,r*a*a+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,n,r,o){return this.set(1,i,r,0,t,1,o,0,e,n,1,0,0,0,0,1),this}compose(t,e,i){const n=this.elements,r=e._x,o=e._y,l=e._z,a=e._w,h=r+r,u=o+o,c=l+l,d=r*h,p=r*u,f=r*c,m=o*u,y=o*c,x=l*c,w=a*h,M=a*u,_=a*c,v=i.x,S=i.y,b=i.z;return n[0]=(1-(m+x))*v,n[1]=(p+_)*v,n[2]=(f-M)*v,n[3]=0,n[4]=(p-_)*S,n[5]=(1-(d+x))*S,n[6]=(y+w)*S,n[7]=0,n[8]=(f+M)*b,n[9]=(y-w)*b,n[10]=(1-(d+m))*b,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,i){const n=this.elements;let r=te.set(n[0],n[1],n[2]).length();const o=te.set(n[4],n[5],n[6]).length(),l=te.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),t.x=n[12],t.y=n[13],t.z=n[14],ht.copy(this);const h=1/r,u=1/o,c=1/l;return ht.elements[0]*=h,ht.elements[1]*=h,ht.elements[2]*=h,ht.elements[4]*=u,ht.elements[5]*=u,ht.elements[6]*=u,ht.elements[8]*=c,ht.elements[9]*=c,ht.elements[10]*=c,e.setFromRotationMatrix(ht),i.x=r,i.y=o,i.z=l,this}makePerspective(t,e,i,n,r,o,l=2e3){const a=this.elements,h=2*r/(e-t),u=2*r/(i-n),c=(e+t)/(e-t),d=(i+n)/(i-n);let p,f;if(l===2e3)p=-(o+r)/(o-r),f=-2*o*r/(o-r);else if(l===2001)p=-o/(o-r),f=-o*r/(o-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+l);return a[0]=h,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=u,a[9]=d,a[13]=0,a[2]=0,a[6]=0,a[10]=p,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,i,n,r,o,l=2e3){const a=this.elements,h=1/(e-t),u=1/(i-n),c=1/(o-r),d=(e+t)*h,p=(i+n)*u;let f,m;if(l===2e3)f=(o+r)*c,m=-2*c;else if(l===2001)f=r*c,m=-1*c;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+l);return a[0]=2*h,a[4]=0,a[8]=0,a[12]=-d,a[1]=0,a[5]=2*u,a[9]=0,a[13]=-p,a[2]=0,a[6]=0,a[10]=m,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let n=0;n<16;n++)if(e[n]!==i[n])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const te=new g,ht=new P,Ha=new g(0,0,0),ja=new g(1,1,1),Lt=new g,si=new g,et=new g,Vs=new P,Us=new I;class pt{constructor(t=0,e=0,i=0,n=pt.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,n=this._order){return this._x=t,this._y=e,this._z=i,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const n=t.elements,r=n[0],o=n[4],l=n[8],a=n[1],h=n[5],u=n[9],c=n[2],d=n[6],p=n[10];switch(e){case"XYZ":this._y=Math.asin(X(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,h),this._z=0);break;case"YXZ":this._x=Math.asin(-X(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(a,h)):(this._y=Math.atan2(-c,r),this._z=0);break;case"ZXY":this._x=Math.asin(X(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-c,p),this._z=Math.atan2(-o,h)):(this._y=0,this._z=Math.atan2(a,r));break;case"ZYX":this._y=Math.asin(-X(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(a,r)):(this._x=0,this._z=Math.atan2(-o,h));break;case"YZX":this._z=Math.asin(X(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-c,r)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-X(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,h),this._y=Math.atan2(l,r)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return Vs.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Vs,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Us.setFromEuler(this),this.setFromQuaternion(Us,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}pt.DEFAULT_ORDER="XYZ";class qa{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let Xa=0;const ks=new g,ee=new I,wt=new P,ri=new g,Re=new g,Ga=new g,Ya=new I,Ds=new g(1,0,0),Ws=new g(0,1,0),Hs=new g(0,0,1),js={type:"added"},Za={type:"removed"},ie={type:"childadded",child:null},rn={type:"childremoved",child:null};class D extends ki{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Xa++}),this.uuid=dt(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=D.DEFAULT_UP.clone();const t=new g,e=new pt,i=new I,n=new g(1,1,1);function r(){i.setFromEuler(e,!1)}function o(){e.setFromQuaternion(i,void 0,!1)}e._onChange(r),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new P},normalMatrix:{value:new U}}),this.matrix=new P,this.matrixWorld=new P,this.matrixAutoUpdate=D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new qa,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ee.setFromAxisAngle(t,e),this.quaternion.multiply(ee),this}rotateOnWorldAxis(t,e){return ee.setFromAxisAngle(t,e),this.quaternion.premultiply(ee),this}rotateX(t){return this.rotateOnAxis(Ds,t)}rotateY(t){return this.rotateOnAxis(Ws,t)}rotateZ(t){return this.rotateOnAxis(Hs,t)}translateOnAxis(t,e){return ks.copy(t).applyQuaternion(this.quaternion),this.position.add(ks.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Ds,t)}translateY(t){return this.translateOnAxis(Ws,t)}translateZ(t){return this.translateOnAxis(Hs,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(wt.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?ri.copy(t):ri.set(t,e,i);const n=this.parent;this.updateWorldMatrix(!0,!1),Re.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?wt.lookAt(Re,ri,this.up):wt.lookAt(ri,Re,this.up),this.quaternion.setFromRotationMatrix(wt),n&&(wt.extractRotation(n.matrixWorld),ee.setFromRotationMatrix(wt),this.quaternion.premultiply(ee.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(js),ie.child=t,this.dispatchEvent(ie),ie.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Za),rn.child=t,this.dispatchEvent(rn),rn.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),wt.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),wt.multiply(t.parent.matrixWorld)),t.applyMatrix4(wt),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(js),ie.child=t,this.dispatchEvent(ie),ie.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,n=this.children.length;i<n;i++){const o=this.children[i].getObjectByProperty(t,e);if(o!==void 0)return o}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const n=this.children;for(let r=0,o=n.length;r<o;r++)n[r].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Re,t,Ga),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Re,Ya,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,n=e.length;i<n;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const n=this.children;for(let r=0,o=n.length;r<o;r++)n[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map(l=>({boxInitialized:l.boxInitialized,boxMin:l.box.min.toArray(),boxMax:l.box.max.toArray(),sphereInitialized:l.sphereInitialized,sphereRadius:l.sphere.radius,sphereCenter:l.sphere.center.toArray()})),n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(n.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),this.boundingBox!==null&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()}));function r(l,a){return l[a.uuid]===void 0&&(l[a.uuid]=a.toJSON(t)),a.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(t.geometries,this.geometry);const l=this.geometry.parameters;if(l!==void 0&&l.shapes!==void 0){const a=l.shapes;if(Array.isArray(a))for(let h=0,u=a.length;h<u;h++){const c=a[h];r(t.shapes,c)}else r(t.shapes,a)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const l=[];for(let a=0,h=this.material.length;a<h;a++)l.push(r(t.materials,this.material[a]));n.material=l}else n.material=r(t.materials,this.material);if(this.children.length>0){n.children=[];for(let l=0;l<this.children.length;l++)n.children.push(this.children[l].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let l=0;l<this.animations.length;l++){const a=this.animations[l];n.animations.push(r(t.animations,a))}}if(e){const l=o(t.geometries),a=o(t.materials),h=o(t.textures),u=o(t.images),c=o(t.shapes),d=o(t.skeletons),p=o(t.animations),f=o(t.nodes);l.length>0&&(i.geometries=l),a.length>0&&(i.materials=a),h.length>0&&(i.textures=h),u.length>0&&(i.images=u),c.length>0&&(i.shapes=c),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),f.length>0&&(i.nodes=f)}return i.object=n,i;function o(l){const a=[];for(const h in l){const u=l[h];delete u.metadata,a.push(u)}return a}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const n=t.children[i];this.add(n.clone())}return this}}D.DEFAULT_UP=new g(0,1,0);D.DEFAULT_MATRIX_AUTO_UPDATE=!0;D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ut=new g,bt=new g,on=new g,St=new g,ne=new g,se=new g,qs=new g,an=new g,ln=new g,hn=new g;class xt{constructor(t=new g,e=new g,i=new g){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,n){n.subVectors(i,e),ut.subVectors(t,e),n.cross(ut);const r=n.lengthSq();return r>0?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}static getBarycoord(t,e,i,n,r){ut.subVectors(n,e),bt.subVectors(i,e),on.subVectors(t,e);const o=ut.dot(ut),l=ut.dot(bt),a=ut.dot(on),h=bt.dot(bt),u=bt.dot(on),c=o*h-l*l;if(c===0)return r.set(0,0,0),null;const d=1/c,p=(h*a-l*u)*d,f=(o*u-l*a)*d;return r.set(1-p-f,f,p)}static containsPoint(t,e,i,n){return this.getBarycoord(t,e,i,n,St)===null?!1:St.x>=0&&St.y>=0&&St.x+St.y<=1}static getInterpolation(t,e,i,n,r,o,l,a){return this.getBarycoord(t,e,i,n,St)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(r,St.x),a.addScaledVector(o,St.y),a.addScaledVector(l,St.z),a)}static isFrontFacing(t,e,i,n){return ut.subVectors(i,e),bt.subVectors(t,e),ut.cross(bt).dot(n)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,n){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,i,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ut.subVectors(this.c,this.b),bt.subVectors(this.a,this.b),ut.cross(bt).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return xt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return xt.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,i,n,r){return xt.getInterpolation(t,this.a,this.b,this.c,e,i,n,r)}containsPoint(t){return xt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return xt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,n=this.b,r=this.c;let o,l;ne.subVectors(n,i),se.subVectors(r,i),an.subVectors(t,i);const a=ne.dot(an),h=se.dot(an);if(a<=0&&h<=0)return e.copy(i);ln.subVectors(t,n);const u=ne.dot(ln),c=se.dot(ln);if(u>=0&&c<=u)return e.copy(n);const d=a*c-u*h;if(d<=0&&a>=0&&u<=0)return o=a/(a-u),e.copy(i).addScaledVector(ne,o);hn.subVectors(t,r);const p=ne.dot(hn),f=se.dot(hn);if(f>=0&&p<=f)return e.copy(r);const m=p*h-a*f;if(m<=0&&h>=0&&f<=0)return l=h/(h-f),e.copy(i).addScaledVector(se,l);const y=u*f-p*c;if(y<=0&&c-u>=0&&p-f>=0)return qs.subVectors(r,n),l=(c-u)/(c-u+(p-f)),e.copy(n).addScaledVector(qs,l);const x=1/(y+m+d);return o=m*x,l=d*x,e.copy(i).addScaledVector(ne,o).addScaledVector(se,l)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const ao={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ct={h:0,s:0,l:0},oi={h:0,s:0,l:0};function un(s,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?s+(t-s)*6*e:e<1/2?t:e<2/3?s+(t-s)*6*(2/3-e):s}class B{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(e===void 0&&i===void 0){const n=t;n&&n.isColor?this.copy(n):typeof n=="number"?this.setHex(n):typeof n=="string"&&this.setStyle(n)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=zt){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,at.toWorkingColorSpace(this,e),this}setRGB(t,e,i,n=at.workingColorSpace){return this.r=t,this.g=e,this.b=i,at.toWorkingColorSpace(this,n),this}setHSL(t,e,i,n=at.workingColorSpace){if(t=jn(t,1),e=X(e,0,1),i=X(i,0,1),e===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+e):i+e-i*e,o=2*i-r;this.r=un(o,r,t+1/3),this.g=un(o,r,t),this.b=un(o,r,t-1/3)}return at.toWorkingColorSpace(this,n),this}setStyle(t,e=zt){function i(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const o=n[1],l=n[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return i(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return i(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return i(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=n[1],o=r.length;if(o===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,e);if(o===6)return this.setHex(parseInt(r,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=zt){const i=ao[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=ye(t.r),this.g=ye(t.g),this.b=ye(t.b),this}copyLinearToSRGB(t){return this.r=$i(t.r),this.g=$i(t.g),this.b=$i(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=zt){return at.fromWorkingColorSpace(Z.copy(this),t),Math.round(X(Z.r*255,0,255))*65536+Math.round(X(Z.g*255,0,255))*256+Math.round(X(Z.b*255,0,255))}getHexString(t=zt){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=at.workingColorSpace){at.fromWorkingColorSpace(Z.copy(this),e);const i=Z.r,n=Z.g,r=Z.b,o=Math.max(i,n,r),l=Math.min(i,n,r);let a,h;const u=(l+o)/2;if(l===o)a=0,h=0;else{const c=o-l;switch(h=u<=.5?c/(o+l):c/(2-o-l),o){case i:a=(n-r)/c+(n<r?6:0);break;case n:a=(r-i)/c+2;break;case r:a=(i-n)/c+4;break}a/=6}return t.h=a,t.s=h,t.l=u,t}getRGB(t,e=at.workingColorSpace){return at.fromWorkingColorSpace(Z.copy(this),e),t.r=Z.r,t.g=Z.g,t.b=Z.b,t}getStyle(t=zt){at.fromWorkingColorSpace(Z.copy(this),t);const e=Z.r,i=Z.g,n=Z.b;return t!==zt?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(i*255)},${Math.round(n*255)})`}offsetHSL(t,e,i){return this.getHSL(Ct),this.setHSL(Ct.h+t,Ct.s+e,Ct.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Ct),t.getHSL(oi);const i=De(Ct.h,oi.h,e),n=De(Ct.s,oi.s,e),r=De(Ct.l,oi.l,e);return this.setHSL(i,n,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,n=this.b,r=t.elements;return this.r=r[0]*e+r[3]*i+r[6]*n,this.g=r[1]*e+r[4]*i+r[7]*n,this.b=r[2]*e+r[5]*i+r[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Z=new B;B.NAMES=ao;let $a=0;class Vt extends ki{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:$a++}),this.uuid=dt(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new B(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const n=this[e];if(n===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}n&&n.isColor?n.set(i):n&&n.isVector3&&i&&i.isVector3?n.copy(i):this[e]=i}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(i.blending=this.blending),this.side!==0&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==204&&(i.blendSrc=this.blendSrc),this.blendDst!==205&&(i.blendDst=this.blendDst),this.blendEquation!==100&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==3&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==519&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==7680&&(i.stencilFail=this.stencilFail),this.stencilZFail!==7680&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==7680&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function n(r){const o=[];for(const l in r){const a=r[l];delete a.metadata,o.push(a)}return o}if(e){const r=n(t.textures),o=n(t.images);r.length>0&&(i.textures=r),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const n=e.length;i=new Array(n);for(let r=0;r!==n;++r)i[r]=e[r].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}onBeforeRender(){console.warn("Material: onBeforeRender() has been removed.")}}class Bn extends Vt{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new B(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pt,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const j=new g,ai=new F;class V{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i,this.usage=35044,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return oo("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[t+n]=e.array[i+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)ai.fromBufferAttribute(this,e),ai.applyMatrix3(t),this.setXY(e,ai.x,ai.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)j.fromBufferAttribute(this,e),j.applyMatrix3(t),this.setXYZ(e,j.x,j.y,j.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)j.fromBufferAttribute(this,e),j.applyMatrix4(t),this.setXYZ(e,j.x,j.y,j.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)j.fromBufferAttribute(this,e),j.applyNormalMatrix(t),this.setXYZ(e,j.x,j.y,j.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)j.fromBufferAttribute(this,e),j.transformDirection(t),this.setXYZ(e,j.x,j.y,j.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=ct(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=N(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=ct(e,this.array)),e}setX(t,e){return this.normalized&&(e=N(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=ct(e,this.array)),e}setY(t,e){return this.normalized&&(e=N(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=ct(e,this.array)),e}setZ(t,e){return this.normalized&&(e=N(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=ct(e,this.array)),e}setW(t,e){return this.normalized&&(e=N(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=N(e,this.array),i=N(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,n){return t*=this.itemSize,this.normalized&&(e=N(e,this.array),i=N(i,this.array),n=N(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this}setXYZW(t,e,i,n,r){return t*=this.itemSize,this.normalized&&(e=N(e,this.array),i=N(i,this.array),n=N(n,this.array),r=N(r,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=n,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==35044&&(t.usage=this.usage),t}}class Ja extends V{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class Qa extends V{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class He extends V{constructor(t,e,i){super(new Float32Array(t),e,i)}}let Ka=0;const nt=new P,cn=new D,re=new g,it=new Ot,Ee=new Ot,q=new g;class K extends ki{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Ka++}),this.uuid=dt(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Na(t)?Qa:Ja)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new U().getNormalMatrix(t);i.applyNormalMatrix(r),i.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(t),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return nt.makeRotationFromQuaternion(t),this.applyMatrix4(nt),this}rotateX(t){return nt.makeRotationX(t),this.applyMatrix4(nt),this}rotateY(t){return nt.makeRotationY(t),this.applyMatrix4(nt),this}rotateZ(t){return nt.makeRotationZ(t),this.applyMatrix4(nt),this}translate(t,e,i){return nt.makeTranslation(t,e,i),this.applyMatrix4(nt),this}scale(t,e,i){return nt.makeScale(t,e,i),this.applyMatrix4(nt),this}lookAt(t){return cn.lookAt(t),cn.updateMatrix(),this.applyMatrix4(cn.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(re).negate(),this.translate(re.x,re.y,re.z),this}setFromPoints(t){const e=[];for(let i=0,n=t.length;i<n;i++){const r=t[i];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new He(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ot);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new g(-1/0,-1/0,-1/0),new g(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,n=e.length;i<n;i++){const r=e[i];it.setFromBufferAttribute(r),this.morphTargetsRelative?(q.addVectors(this.boundingBox.min,it.min),this.boundingBox.expandByPoint(q),q.addVectors(this.boundingBox.max,it.max),this.boundingBox.expandByPoint(q)):(this.boundingBox.expandByPoint(it.min),this.boundingBox.expandByPoint(it.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Rt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new g,1/0);return}if(t){const i=this.boundingSphere.center;if(it.setFromBufferAttribute(t),e)for(let r=0,o=e.length;r<o;r++){const l=e[r];Ee.setFromBufferAttribute(l),this.morphTargetsRelative?(q.addVectors(it.min,Ee.min),it.expandByPoint(q),q.addVectors(it.max,Ee.max),it.expandByPoint(q)):(it.expandByPoint(Ee.min),it.expandByPoint(Ee.max))}it.getCenter(i);let n=0;for(let r=0,o=t.count;r<o;r++)q.fromBufferAttribute(t,r),n=Math.max(n,i.distanceToSquared(q));if(e)for(let r=0,o=e.length;r<o;r++){const l=e[r],a=this.morphTargetsRelative;for(let h=0,u=l.count;h<u;h++)q.fromBufferAttribute(l,h),a&&(re.fromBufferAttribute(t,h),q.add(re)),n=Math.max(n,i.distanceToSquared(q))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.position,n=e.normal,r=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new V(new Float32Array(4*i.count),4));const o=this.getAttribute("tangent"),l=[],a=[];for(let T=0;T<i.count;T++)l[T]=new g,a[T]=new g;const h=new g,u=new g,c=new g,d=new F,p=new F,f=new F,m=new g,y=new g;function x(T,E,A){h.fromBufferAttribute(i,T),u.fromBufferAttribute(i,E),c.fromBufferAttribute(i,A),d.fromBufferAttribute(r,T),p.fromBufferAttribute(r,E),f.fromBufferAttribute(r,A),u.sub(h),c.sub(h),p.sub(d),f.sub(d);const R=1/(p.x*f.y-f.x*p.y);isFinite(R)&&(m.copy(u).multiplyScalar(f.y).addScaledVector(c,-p.y).multiplyScalar(R),y.copy(c).multiplyScalar(p.x).addScaledVector(u,-f.x).multiplyScalar(R),l[T].add(m),l[E].add(m),l[A].add(m),a[T].add(y),a[E].add(y),a[A].add(y))}let w=this.groups;w.length===0&&(w=[{start:0,count:t.count}]);for(let T=0,E=w.length;T<E;++T){const A=w[T],R=A.start,L=A.count;for(let z=R,G=R+L;z<G;z+=3)x(t.getX(z+0),t.getX(z+1),t.getX(z+2))}const M=new g,_=new g,v=new g,S=new g;function b(T){v.fromBufferAttribute(n,T),S.copy(v);const E=l[T];M.copy(E),M.sub(v.multiplyScalar(v.dot(E))).normalize(),_.crossVectors(S,E);const R=_.dot(a[T])<0?-1:1;o.setXYZW(T,M.x,M.y,M.z,R)}for(let T=0,E=w.length;T<E;++T){const A=w[T],R=A.start,L=A.count;for(let z=R,G=R+L;z<G;z+=3)b(t.getX(z+0)),b(t.getX(z+1)),b(t.getX(z+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new V(new Float32Array(e.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const n=new g,r=new g,o=new g,l=new g,a=new g,h=new g,u=new g,c=new g;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),y=t.getX(d+2);n.fromBufferAttribute(e,f),r.fromBufferAttribute(e,m),o.fromBufferAttribute(e,y),u.subVectors(o,r),c.subVectors(n,r),u.cross(c),l.fromBufferAttribute(i,f),a.fromBufferAttribute(i,m),h.fromBufferAttribute(i,y),l.add(u),a.add(u),h.add(u),i.setXYZ(f,l.x,l.y,l.z),i.setXYZ(m,a.x,a.y,a.z),i.setXYZ(y,h.x,h.y,h.z)}else for(let d=0,p=e.count;d<p;d+=3)n.fromBufferAttribute(e,d+0),r.fromBufferAttribute(e,d+1),o.fromBufferAttribute(e,d+2),u.subVectors(o,r),c.subVectors(n,r),u.cross(c),i.setXYZ(d+0,u.x,u.y,u.z),i.setXYZ(d+1,u.x,u.y,u.z),i.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)q.fromBufferAttribute(t,e),q.normalize(),t.setXYZ(e,q.x,q.y,q.z)}toNonIndexed(){function t(l,a){const h=l.array,u=l.itemSize,c=l.normalized,d=new h.constructor(a.length*u);let p=0,f=0;for(let m=0,y=a.length;m<y;m++){l.isInterleavedBufferAttribute?p=a[m]*l.data.stride+l.offset:p=a[m]*u;for(let x=0;x<u;x++)d[f++]=h[p++]}return new V(d,u,c)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new K,i=this.index.array,n=this.attributes;for(const l in n){const a=n[l],h=t(a,i);e.setAttribute(l,h)}const r=this.morphAttributes;for(const l in r){const a=[],h=r[l];for(let u=0,c=h.length;u<c;u++){const d=h[u],p=t(d,i);a.push(p)}e.morphAttributes[l]=a}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let l=0,a=o.length;l<a;l++){const h=o[l];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const h in a)a[h]!==void 0&&(t[h]=a[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const a in i){const h=i[a];t.data.attributes[a]=h.toJSON(t.data)}const n={};let r=!1;for(const a in this.morphAttributes){const h=this.morphAttributes[a],u=[];for(let c=0,d=h.length;c<d;c++){const p=h[c];u.push(p.toJSON(t.data))}u.length>0&&(n[a]=u,r=!0)}r&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const l=this.boundingSphere;return l!==null&&(t.data.boundingSphere={center:l.center.toArray(),radius:l.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const n=t.attributes;for(const h in n){const u=n[h];this.setAttribute(h,u.clone(e))}const r=t.morphAttributes;for(const h in r){const u=[],c=r[h];for(let d=0,p=c.length;d<p;d++)u.push(c[d].clone(e));this.morphAttributes[h]=u}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let h=0,u=o.length;h<u;h++){const c=o[h];this.addGroup(c.start,c.count,c.materialIndex)}const l=t.boundingBox;l!==null&&(this.boundingBox=l.clone());const a=t.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Xs=new P,Ht=new Di,li=new Rt,Gs=new g,oe=new g,ae=new g,le=new g,dn=new g,hi=new g,ui=new F,ci=new F,di=new F,Ys=new g,Zs=new g,$s=new g,pi=new g,fi=new g;class je extends D{constructor(t=new K,e=new Bn){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const n=e[i[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=n.length;r<o;r++){const l=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}getVertexPosition(t,e){const i=this.geometry,n=i.attributes.position,r=i.morphAttributes.position,o=i.morphTargetsRelative;e.fromBufferAttribute(n,t);const l=this.morphTargetInfluences;if(r&&l){hi.set(0,0,0);for(let a=0,h=r.length;a<h;a++){const u=l[a],c=r[a];u!==0&&(dn.fromBufferAttribute(c,t),o?hi.addScaledVector(dn,u):hi.addScaledVector(dn.sub(e),u))}e.add(hi)}return e}raycast(t,e){const i=this.geometry,n=this.material,r=this.matrixWorld;n!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),li.copy(i.boundingSphere),li.applyMatrix4(r),Ht.copy(t.ray).recast(t.near),!(li.containsPoint(Ht.origin)===!1&&(Ht.intersectSphere(li,Gs)===null||Ht.origin.distanceToSquared(Gs)>(t.far-t.near)**2))&&(Xs.copy(r).invert(),Ht.copy(t.ray).applyMatrix4(Xs),!(i.boundingBox!==null&&Ht.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(t,e,Ht)))}_computeIntersections(t,e,i){let n;const r=this.geometry,o=this.material,l=r.index,a=r.attributes.position,h=r.attributes.uv,u=r.attributes.uv1,c=r.attributes.normal,d=r.groups,p=r.drawRange;if(l!==null)if(Array.isArray(o))for(let f=0,m=d.length;f<m;f++){const y=d[f],x=o[y.materialIndex],w=Math.max(y.start,p.start),M=Math.min(l.count,Math.min(y.start+y.count,p.start+p.count));for(let _=w,v=M;_<v;_+=3){const S=l.getX(_),b=l.getX(_+1),T=l.getX(_+2);n=mi(this,x,t,i,h,u,c,S,b,T),n&&(n.faceIndex=Math.floor(_/3),n.face.materialIndex=y.materialIndex,e.push(n))}}else{const f=Math.max(0,p.start),m=Math.min(l.count,p.start+p.count);for(let y=f,x=m;y<x;y+=3){const w=l.getX(y),M=l.getX(y+1),_=l.getX(y+2);n=mi(this,o,t,i,h,u,c,w,M,_),n&&(n.faceIndex=Math.floor(y/3),e.push(n))}}else if(a!==void 0)if(Array.isArray(o))for(let f=0,m=d.length;f<m;f++){const y=d[f],x=o[y.materialIndex],w=Math.max(y.start,p.start),M=Math.min(a.count,Math.min(y.start+y.count,p.start+p.count));for(let _=w,v=M;_<v;_+=3){const S=_,b=_+1,T=_+2;n=mi(this,x,t,i,h,u,c,S,b,T),n&&(n.faceIndex=Math.floor(_/3),n.face.materialIndex=y.materialIndex,e.push(n))}}else{const f=Math.max(0,p.start),m=Math.min(a.count,p.start+p.count);for(let y=f,x=m;y<x;y+=3){const w=y,M=y+1,_=y+2;n=mi(this,o,t,i,h,u,c,w,M,_),n&&(n.faceIndex=Math.floor(y/3),e.push(n))}}}}function tl(s,t,e,i,n,r,o,l){let a;if(t.side===1?a=i.intersectTriangle(o,r,n,!0,l):a=i.intersectTriangle(n,r,o,t.side===0,l),a===null)return null;fi.copy(l),fi.applyMatrix4(s.matrixWorld);const h=e.ray.origin.distanceTo(fi);return h<e.near||h>e.far?null:{distance:h,point:fi.clone(),object:s}}function mi(s,t,e,i,n,r,o,l,a,h){s.getVertexPosition(l,oe),s.getVertexPosition(a,ae),s.getVertexPosition(h,le);const u=tl(s,t,e,i,oe,ae,le,pi);if(u){n&&(ui.fromBufferAttribute(n,l),ci.fromBufferAttribute(n,a),di.fromBufferAttribute(n,h),u.uv=xt.getInterpolation(pi,oe,ae,le,ui,ci,di,new F)),r&&(ui.fromBufferAttribute(r,l),ci.fromBufferAttribute(r,a),di.fromBufferAttribute(r,h),u.uv1=xt.getInterpolation(pi,oe,ae,le,ui,ci,di,new F)),o&&(Ys.fromBufferAttribute(o,l),Zs.fromBufferAttribute(o,a),$s.fromBufferAttribute(o,h),u.normal=xt.getInterpolation(pi,oe,ae,le,Ys,Zs,$s,new g),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const c={a:l,b:a,c:h,normal:new g,materialIndex:0};xt.getNormal(oe,ae,le,c.normal),u.face=c}return u}function qn(s){const t={};for(const e in s){t[e]={};for(const i in s[e]){const n=s[e][i];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?n.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][i]=null):t[e][i]=n.clone():Array.isArray(n)?t[e][i]=n.slice():t[e][i]=n}}return t}function el(s){const t={};for(let e=0;e<s.length;e++){const i=qn(s[e]);for(const n in i)t[n]=i[n]}return t}function il(s){const t=[];for(let e=0;e<s.length;e++)t.push(s[e].clone());return t}const nl={clone:qn,merge:el};var sl=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,rl=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ol extends Vt{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=sl,this.fragmentShader=rl,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=qn(t.uniforms),this.uniformsGroups=il(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const o=this.uniforms[n].value;o&&o.isTexture?e.uniforms[n]={type:"t",value:o.toJSON(t).uuid}:o&&o.isColor?e.uniforms[n]={type:"c",value:o.getHex()}:o&&o.isVector2?e.uniforms[n]={type:"v2",value:o.toArray()}:o&&o.isVector3?e.uniforms[n]={type:"v3",value:o.toArray()}:o&&o.isVector4?e.uniforms[n]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?e.uniforms[n]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?e.uniforms[n]={type:"m4",value:o.toArray()}:e.uniforms[n]={value:o}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const n in this.extensions)this.extensions[n]===!0&&(i[n]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class lo extends D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new P,this.projectionMatrix=new P,this.projectionMatrixInverse=new P,this.coordinateSystem=2e3}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Bt=new g,Js=new F,Qs=new F;class ho extends lo{constructor(t=50,e=1,i=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=We*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(ke*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return We*2*Math.atan(Math.tan(ke*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){Bt.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Bt.x,Bt.y).multiplyScalar(-t/Bt.z),Bt.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(Bt.x,Bt.y).multiplyScalar(-t/Bt.z)}getViewSize(t,e){return this.getViewBounds(t,Js,Qs),e.subVectors(Qs,Js)}setViewOffset(t,e,i,n,r,o){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(ke*.5*this.fov)/this.zoom,i=2*e,n=this.aspect*i,r=-.5*n;const o=this.view;if(this.view!==null&&this.view.enabled){const a=o.fullWidth,h=o.fullHeight;r+=o.offsetX*n/a,e-=o.offsetY*i/h,n*=o.width/a,i*=o.height/h}const l=this.filmOffset;l!==0&&(r+=t*l/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+n,e,e-i,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const pn=new g,al=new g,ll=new U;class he{constructor(t=new g(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,n){return this.normal.set(t,e,i),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const n=pn.subVectors(i,e).cross(al.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(pn),n=this.normal.dot(i);if(n===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/n;return r<0||r>1?null:e.copy(t.start).addScaledVector(i,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||ll.getNormalMatrix(t),n=this.coplanarPoint(pn).applyMatrix4(t),r=this.normal.applyMatrix3(i).normalize();return this.constant=-n.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const jt=new Rt,gi=new g;class hl{constructor(t=new he,e=new he,i=new he,n=new he,r=new he,o=new he){this.planes=[t,e,i,n,r,o]}set(t,e,i,n,r,o){const l=this.planes;return l[0].copy(t),l[1].copy(e),l[2].copy(i),l[3].copy(n),l[4].copy(r),l[5].copy(o),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=2e3){const i=this.planes,n=t.elements,r=n[0],o=n[1],l=n[2],a=n[3],h=n[4],u=n[5],c=n[6],d=n[7],p=n[8],f=n[9],m=n[10],y=n[11],x=n[12],w=n[13],M=n[14],_=n[15];if(i[0].setComponents(a-r,d-h,y-p,_-x).normalize(),i[1].setComponents(a+r,d+h,y+p,_+x).normalize(),i[2].setComponents(a+o,d+u,y+f,_+w).normalize(),i[3].setComponents(a-o,d-u,y-f,_-w).normalize(),i[4].setComponents(a-l,d-c,y-m,_-M).normalize(),e===2e3)i[5].setComponents(a+l,d+c,y+m,_+M).normalize();else if(e===2001)i[5].setComponents(l,c,m,M).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),jt.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),jt.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(jt)}intersectsSprite(t){return jt.center.set(0,0,0),jt.radius=.7071067811865476,jt.applyMatrix4(t.matrixWorld),this.intersectsSphere(jt)}intersectsSphere(t){const e=this.planes,i=t.center,n=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(i)<n)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const n=e[i];if(gi.x=n.normal.x>0?t.max.x:t.min.x,gi.y=n.normal.y>0?t.max.y:t.min.y,gi.z=n.normal.z>0?t.max.z:t.min.z,n.distanceToPoint(gi)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}const Pe={common:{diffuse:{value:new B(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new U},alphaMap:{value:null},alphaMapTransform:{value:new U},alphaTest:{value:0}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new U},normalScale:{value:new F(1,1)}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new U}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new B(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}}};class ul extends lo{constructor(t=-1,e=1,i=1,n=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=n,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,n,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=n,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let r=i-t,o=i+t,l=n+e,a=n-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=h*this.view.offsetX,o=r+h*this.view.width,l-=u*this.view.offsetY,a=l-u*this.view.height}this.projectionMatrix.makeOrthographic(r,o,l,a,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class _e extends D{constructor(){super(),this.isGroup=!0,this.type="Group"}}class Pc{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=35044,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=dt()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return oo("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let n=0,r=this.stride;n<r;n++)this.array[t+n]=e.array[i+n];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=dt()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=dt()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Q=new g;class uo{constructor(t,e,i,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)Q.fromBufferAttribute(this,e),Q.applyMatrix4(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Q.fromBufferAttribute(this,e),Q.applyNormalMatrix(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Q.fromBufferAttribute(this,e),Q.transformDirection(t),this.setXYZ(e,Q.x,Q.y,Q.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=ct(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=N(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=N(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=N(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=N(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=N(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=ct(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=ct(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=ct(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=ct(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=N(e,this.array),i=N(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=N(e,this.array),i=N(i,this.array),n=N(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this}setXYZW(t,e,i,n,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=N(e,this.array),i=N(i,this.array),n=N(n,this.array),r=N(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=n,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const n=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[n+r])}return new V(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new uo(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const n=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[n+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const Ks=new g,tr=new rt,er=new rt,cl=new g,ir=new P,yi=new g,fn=new Rt,nr=new P,mn=new Di;class dl extends je{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=Ps,this.bindMatrix=new P,this.bindMatrixInverse=new P,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;this.boundingBox===null&&(this.boundingBox=new Ot),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,yi),this.boundingBox.expandByPoint(yi)}computeBoundingSphere(){const t=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Rt),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,yi),this.boundingSphere.expandByPoint(yi)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const i=this.material,n=this.matrixWorld;i!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),fn.copy(this.boundingSphere),fn.applyMatrix4(n),t.ray.intersectsSphere(fn)!==!1&&(nr.copy(n).invert(),mn.copy(t.ray).applyMatrix4(nr),!(this.boundingBox!==null&&mn.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(t,e,mn)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new rt,e=this.geometry.attributes.skinWeight;for(let i=0,n=e.count;i<n;i++){t.fromBufferAttribute(e,i);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===Ps?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===xa?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const i=this.skeleton,n=this.geometry;tr.fromBufferAttribute(n.attributes.skinIndex,t),er.fromBufferAttribute(n.attributes.skinWeight,t),Ks.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const o=er.getComponent(r);if(o!==0){const l=tr.getComponent(r);ir.multiplyMatrices(i.bones[l].matrixWorld,i.boneInverses[l]),e.addScaledVector(cl.copy(Ks).applyMatrix4(ir),o)}}return e.applyMatrix4(this.bindMatrixInverse)}}class pl extends D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class co extends At{constructor(t=null,e=1,i=1,n,r,o,l,a,h=1003,u=1003,c,d){super(null,o,l,a,h,u,n,r,c,d),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const sr=new P,fl=new P;class Ye{constructor(t=[],e=[]){this.uuid=dt(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,n=this.bones.length;i<n;i++)this.boneInverses.push(new P)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const i=new P;this.bones[t]&&i.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&i.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,n=this.boneTexture;for(let r=0,o=t.length;r<o;r++){const l=t[r]?t[r].matrixWorld:fl;sr.multiplyMatrices(l,e[r]),sr.toArray(i,r*16)}n!==null&&(n.needsUpdate=!0)}clone(){return new Ye(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new co(e,t,t,1023,1015);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const n=this.bones[e];if(n.name===t)return n}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,n=t.bones.length;i<n;i++){const r=t.bones[i];let o=e[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new pl),this.bones.push(o),this.boneInverses.push(new P().fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let n=0,r=e.length;n<r;n++){const o=e[n];t.bones.push(o.uuid);const l=i[n];t.boneInverses.push(l.toArray())}return t}}class rr extends V{constructor(t,e,i,n=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const ue=new P,or=new P,xi=[],ar=new Ot,ml=new P,Ie=new je,Le=new Rt;class Ic extends je{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new rr(new Float32Array(i*16),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let n=0;n<i;n++)this.setMatrixAt(n,ml)}computeBoundingBox(){const t=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new Ot),t.boundingBox===null&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,ue),ar.copy(t.boundingBox).applyMatrix4(ue),this.boundingBox.union(ar)}computeBoundingSphere(){const t=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new Rt),t.boundingSphere===null&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,ue),Le.copy(t.boundingSphere).applyMatrix4(ue),this.boundingSphere.union(Le)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.morphTexture!==null&&(this.morphTexture=t.morphTexture.clone()),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}getMorphAt(t,e){const i=e.morphTargetInfluences,n=this.morphTexture.source.data.data,r=i.length+1,o=t*r+1;for(let l=0;l<i.length;l++)i[l]=n[o+l]}raycast(t,e){const i=this.matrixWorld,n=this.count;if(Ie.geometry=this.geometry,Ie.material=this.material,Ie.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Le.copy(this.boundingSphere),Le.applyMatrix4(i),t.ray.intersectsSphere(Le)!==!1))for(let r=0;r<n;r++){this.getMatrixAt(r,ue),or.multiplyMatrices(i,ue),Ie.matrixWorld=or,Ie.raycast(t,xi);for(let o=0,l=xi.length;o<l;o++){const a=xi[o];a.instanceId=r,a.object=this,e.push(a)}xi.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new rr(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}setMorphAt(t,e){const i=e.morphTargetInfluences,n=i.length+1;this.morphTexture===null&&(this.morphTexture=new co(new Float32Array(n*this.count),n,this.count,1028,1015));const r=this.morphTexture.source.data.data;let o=0;for(let h=0;h<i.length;h++)o+=i[h];const l=this.geometry.morphTargetsRelative?1:1-o,a=n*t;r[a]=l,r.set(i,a+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}class Me extends Vt{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new B(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}const Bi=new g,Fi=new g,lr=new P,Ce=new Di,_i=new Rt,gn=new g,hr=new g;class Xn extends D{constructor(t=new K,e=new Me){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[0];for(let n=1,r=e.count;n<r;n++)Bi.fromBufferAttribute(e,n-1),Fi.fromBufferAttribute(e,n),i[n]=i[n-1],i[n]+=Bi.distanceTo(Fi);t.setAttribute("lineDistance",new He(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,r=t.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),_i.copy(i.boundingSphere),_i.applyMatrix4(n),_i.radius+=r,t.ray.intersectsSphere(_i)===!1)return;lr.copy(n).invert(),Ce.copy(t.ray).applyMatrix4(lr);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=l*l,h=this.isLineSegments?2:1,u=i.index,d=i.attributes.position;if(u!==null){const p=Math.max(0,o.start),f=Math.min(u.count,o.start+o.count);for(let m=p,y=f-1;m<y;m+=h){const x=u.getX(m),w=u.getX(m+1),M=Mi(this,t,Ce,a,x,w);M&&e.push(M)}if(this.isLineLoop){const m=u.getX(f-1),y=u.getX(p),x=Mi(this,t,Ce,a,m,y);x&&e.push(x)}}else{const p=Math.max(0,o.start),f=Math.min(d.count,o.start+o.count);for(let m=p,y=f-1;m<y;m+=h){const x=Mi(this,t,Ce,a,m,m+1);x&&e.push(x)}if(this.isLineLoop){const m=Mi(this,t,Ce,a,f-1,p);m&&e.push(m)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const n=e[i[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=n.length;r<o;r++){const l=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}}function Mi(s,t,e,i,n,r){const o=s.geometry.attributes.position;if(Bi.fromBufferAttribute(o,n),Fi.fromBufferAttribute(o,r),e.distanceSqToSegment(Bi,Fi,gn,hr)>i)return;gn.applyMatrix4(s.matrixWorld);const a=t.ray.origin.distanceTo(gn);if(!(a<t.near||a>t.far))return{distance:a,point:hr.clone().applyMatrix4(s.matrixWorld),index:n,face:null,faceIndex:null,object:s}}const ur=new g,cr=new g;class Wi extends Xn{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[];for(let n=0,r=e.count;n<r;n+=2)ur.fromBufferAttribute(e,n),cr.fromBufferAttribute(e,n+1),i[n]=n===0?0:i[n-1],i[n+1]=i[n]+ur.distanceTo(cr);t.setAttribute("lineDistance",new He(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Lc extends Xn{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}class gl extends Vt{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new B(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}const dr=new P,Fn=new Di,vi=new Rt,wi=new g;class Cc extends D{constructor(t=new K,e=new gl){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,n=this.matrixWorld,r=t.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),vi.copy(i.boundingSphere),vi.applyMatrix4(n),vi.radius+=r,t.ray.intersectsSphere(vi)===!1)return;dr.copy(n).invert(),Fn.copy(t.ray).applyMatrix4(dr);const l=r/((this.scale.x+this.scale.y+this.scale.z)/3),a=l*l,h=i.index,c=i.attributes.position;if(h!==null){const d=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let f=d,m=p;f<m;f++){const y=h.getX(f);wi.fromBufferAttribute(c,y),pr(wi,y,a,n,t,e,this)}}else{const d=Math.max(0,o.start),p=Math.min(c.count,o.start+o.count);for(let f=d,m=p;f<m;f++)wi.fromBufferAttribute(c,f),pr(wi,f,a,n,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const n=e[i[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=n.length;r<o;r++){const l=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[l]=r}}}}}function pr(s,t,e,i,n,r,o){const l=Fn.distanceSqToPoint(s);if(l<e){const a=new g;Fn.closestPointToPoint(s,a),a.applyMatrix4(i);const h=n.ray.origin.distanceTo(a);if(h<n.near||h>n.far)return;r.push({distance:h,distanceToRay:Math.sqrt(l),point:a,index:t,face:null,object:o})}}class Bc{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,n=this.getPoint(0),r=0;e.push(0);for(let o=1;o<=t;o++)i=this.getPoint(o/t),r+=i.distanceTo(n),e.push(r),n=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let n=0;const r=i.length;let o;e?o=e:o=t*i[r-1];let l=0,a=r-1,h;for(;l<=a;)if(n=Math.floor(l+(a-l)/2),h=i[n]-o,h<0)l=n+1;else if(h>0)a=n-1;else{a=n;break}if(n=a,i[n]===o)return n/(r-1);const u=i[n],d=i[n+1]-u,p=(o-u)/d;return(n+p)/(r-1)}getTangent(t,e){let n=t-1e-4,r=t+1e-4;n<0&&(n=0),r>1&&(r=1);const o=this.getPoint(n),l=this.getPoint(r),a=e||(o.isVector2?new F:new g);return a.copy(l).sub(o).normalize(),a}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new g,n=[],r=[],o=[],l=new g,a=new P;for(let p=0;p<=t;p++){const f=p/t;n[p]=this.getTangentAt(f,new g)}r[0]=new g,o[0]=new g;let h=Number.MAX_VALUE;const u=Math.abs(n[0].x),c=Math.abs(n[0].y),d=Math.abs(n[0].z);u<=h&&(h=u,i.set(1,0,0)),c<=h&&(h=c,i.set(0,1,0)),d<=h&&i.set(0,0,1),l.crossVectors(n[0],i).normalize(),r[0].crossVectors(n[0],l),o[0].crossVectors(n[0],r[0]);for(let p=1;p<=t;p++){if(r[p]=r[p-1].clone(),o[p]=o[p-1].clone(),l.crossVectors(n[p-1],n[p]),l.length()>Number.EPSILON){l.normalize();const f=Math.acos(X(n[p-1].dot(n[p]),-1,1));r[p].applyMatrix4(a.makeRotationAxis(l,f))}o[p].crossVectors(n[p],r[p])}if(e===!0){let p=Math.acos(X(r[0].dot(r[t]),-1,1));p/=t,n[0].dot(l.crossVectors(r[0],r[t]))>0&&(p=-p);for(let f=1;f<=t;f++)r[f].applyMatrix4(a.makeRotationAxis(n[f],p*f)),o[f].crossVectors(n[f],r[f])}return{tangents:n,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}const yl={triangulate:function(s,t,e=2){const i=t&&t.length,n=i?t[0]*e:s.length;let r=po(s,0,n,e,!0);const o=[];if(!r||r.next===r.prev)return o;let l,a,h,u,c,d,p;if(i&&(r=wl(s,t,r,e)),s.length>80*e){l=h=s[0],a=u=s[1];for(let f=e;f<n;f+=e)c=s[f],d=s[f+1],c<l&&(l=c),d<a&&(a=d),c>h&&(h=c),d>u&&(u=d);p=Math.max(h-l,u-a),p=p!==0?32767/p:0}return qe(r,o,e,l,a,p,0),o}};function po(s,t,e,i,n){let r,o;if(n===Bl(s,t,e,i)>0)for(r=t;r<e;r+=i)o=fr(r,s[r],s[r+1],o);else for(r=e-i;r>=t;r-=i)o=fr(r,s[r],s[r+1],o);return o&&Hi(o,o.next)&&(Ge(o),o=o.next),o}function Zt(s,t){if(!s)return s;t||(t=s);let e=s,i;do if(i=!1,!e.steiner&&(Hi(e,e.next)||k(e.prev,e,e.next)===0)){if(Ge(e),e=t=e.prev,e===e.next)break;i=!0}else e=e.next;while(i||e!==t);return t}function qe(s,t,e,i,n,r,o){if(!s)return;!o&&r&&Rl(s,i,n,r);let l=s,a,h;for(;s.prev!==s.next;){if(a=s.prev,h=s.next,r?_l(s,i,n,r):xl(s)){t.push(a.i/e|0),t.push(s.i/e|0),t.push(h.i/e|0),Ge(s),s=h.next,l=h.next;continue}if(s=h,s===l){o?o===1?(s=Ml(Zt(s),t,e),qe(s,t,e,i,n,r,2)):o===2&&vl(s,t,e,i,n,r):qe(Zt(s),t,e,i,n,r,1);break}}}function xl(s){const t=s.prev,e=s,i=s.next;if(k(t,e,i)>=0)return!1;const n=t.x,r=e.x,o=i.x,l=t.y,a=e.y,h=i.y,u=n<r?n<o?n:o:r<o?r:o,c=l<a?l<h?l:h:a<h?a:h,d=n>r?n>o?n:o:r>o?r:o,p=l>a?l>h?l:h:a>h?a:h;let f=i.next;for(;f!==t;){if(f.x>=u&&f.x<=d&&f.y>=c&&f.y<=p&&ge(n,l,r,a,o,h,f.x,f.y)&&k(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function _l(s,t,e,i){const n=s.prev,r=s,o=s.next;if(k(n,r,o)>=0)return!1;const l=n.x,a=r.x,h=o.x,u=n.y,c=r.y,d=o.y,p=l<a?l<h?l:h:a<h?a:h,f=u<c?u<d?u:d:c<d?c:d,m=l>a?l>h?l:h:a>h?a:h,y=u>c?u>d?u:d:c>d?c:d,x=zn(p,f,t,e,i),w=zn(m,y,t,e,i);let M=s.prevZ,_=s.nextZ;for(;M&&M.z>=x&&_&&_.z<=w;){if(M.x>=p&&M.x<=m&&M.y>=f&&M.y<=y&&M!==n&&M!==o&&ge(l,u,a,c,h,d,M.x,M.y)&&k(M.prev,M,M.next)>=0||(M=M.prevZ,_.x>=p&&_.x<=m&&_.y>=f&&_.y<=y&&_!==n&&_!==o&&ge(l,u,a,c,h,d,_.x,_.y)&&k(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;M&&M.z>=x;){if(M.x>=p&&M.x<=m&&M.y>=f&&M.y<=y&&M!==n&&M!==o&&ge(l,u,a,c,h,d,M.x,M.y)&&k(M.prev,M,M.next)>=0)return!1;M=M.prevZ}for(;_&&_.z<=w;){if(_.x>=p&&_.x<=m&&_.y>=f&&_.y<=y&&_!==n&&_!==o&&ge(l,u,a,c,h,d,_.x,_.y)&&k(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function Ml(s,t,e){let i=s;do{const n=i.prev,r=i.next.next;!Hi(n,r)&&fo(n,i,i.next,r)&&Xe(n,r)&&Xe(r,n)&&(t.push(n.i/e|0),t.push(i.i/e|0),t.push(r.i/e|0),Ge(i),Ge(i.next),i=s=r),i=i.next}while(i!==s);return Zt(i)}function vl(s,t,e,i,n,r){let o=s;do{let l=o.next.next;for(;l!==o.prev;){if(o.i!==l.i&&Il(o,l)){let a=mo(o,l);o=Zt(o,o.next),a=Zt(a,a.next),qe(o,t,e,i,n,r,0),qe(a,t,e,i,n,r,0);return}l=l.next}o=o.next}while(o!==s)}function wl(s,t,e,i){const n=[];let r,o,l,a,h;for(r=0,o=t.length;r<o;r++)l=t[r]*i,a=r<o-1?t[r+1]*i:s.length,h=po(s,l,a,i,!1),h===h.next&&(h.steiner=!0),n.push(Pl(h));for(n.sort(bl),r=0;r<n.length;r++)e=Sl(n[r],e);return e}function bl(s,t){return s.x-t.x}function Sl(s,t){const e=Tl(s,t);if(!e)return t;const i=mo(e,s);return Zt(i,i.next),Zt(e,e.next)}function Tl(s,t){let e=t,i=-1/0,n;const r=s.x,o=s.y;do{if(o<=e.y&&o>=e.next.y&&e.next.y!==e.y){const d=e.x+(o-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=r&&d>i&&(i=d,n=e.x<e.next.x?e:e.next,d===r))return n}e=e.next}while(e!==t);if(!n)return null;const l=n,a=n.x,h=n.y;let u=1/0,c;e=n;do r>=e.x&&e.x>=a&&r!==e.x&&ge(o<h?r:i,o,a,h,o<h?i:r,o,e.x,e.y)&&(c=Math.abs(o-e.y)/(r-e.x),Xe(e,s)&&(c<u||c===u&&(e.x>n.x||e.x===n.x&&Al(n,e)))&&(n=e,u=c)),e=e.next;while(e!==l);return n}function Al(s,t){return k(s.prev,s,t.prev)<0&&k(t.next,s,s.next)<0}function Rl(s,t,e,i){let n=s;do n.z===0&&(n.z=zn(n.x,n.y,t,e,i)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next;while(n!==s);n.prevZ.nextZ=null,n.prevZ=null,El(n)}function El(s){let t,e,i,n,r,o,l,a,h=1;do{for(e=s,s=null,r=null,o=0;e;){for(o++,i=e,l=0,t=0;t<h&&(l++,i=i.nextZ,!!i);t++);for(a=h;l>0||a>0&&i;)l!==0&&(a===0||!i||e.z<=i.z)?(n=e,e=e.nextZ,l--):(n=i,i=i.nextZ,a--),r?r.nextZ=n:s=n,n.prevZ=r,r=n;e=i}r.nextZ=null,h*=2}while(o>1);return s}function zn(s,t,e,i,n){return s=(s-e)*n|0,t=(t-i)*n|0,s=(s|s<<8)&16711935,s=(s|s<<4)&252645135,s=(s|s<<2)&858993459,s=(s|s<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,s|t<<1}function Pl(s){let t=s,e=s;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==s);return e}function ge(s,t,e,i,n,r,o,l){return(n-o)*(t-l)>=(s-o)*(r-l)&&(s-o)*(i-l)>=(e-o)*(t-l)&&(e-o)*(r-l)>=(n-o)*(i-l)}function Il(s,t){return s.next.i!==t.i&&s.prev.i!==t.i&&!Ll(s,t)&&(Xe(s,t)&&Xe(t,s)&&Cl(s,t)&&(k(s.prev,s,t.prev)||k(s,t.prev,t))||Hi(s,t)&&k(s.prev,s,s.next)>0&&k(t.prev,t,t.next)>0)}function k(s,t,e){return(t.y-s.y)*(e.x-t.x)-(t.x-s.x)*(e.y-t.y)}function Hi(s,t){return s.x===t.x&&s.y===t.y}function fo(s,t,e,i){const n=Si(k(s,t,e)),r=Si(k(s,t,i)),o=Si(k(e,i,s)),l=Si(k(e,i,t));return!!(n!==r&&o!==l||n===0&&bi(s,e,t)||r===0&&bi(s,i,t)||o===0&&bi(e,s,i)||l===0&&bi(e,t,i))}function bi(s,t,e){return t.x<=Math.max(s.x,e.x)&&t.x>=Math.min(s.x,e.x)&&t.y<=Math.max(s.y,e.y)&&t.y>=Math.min(s.y,e.y)}function Si(s){return s>0?1:s<0?-1:0}function Ll(s,t){let e=s;do{if(e.i!==s.i&&e.next.i!==s.i&&e.i!==t.i&&e.next.i!==t.i&&fo(e,e.next,s,t))return!0;e=e.next}while(e!==s);return!1}function Xe(s,t){return k(s.prev,s,s.next)<0?k(s,t,s.next)>=0&&k(s,s.prev,t)>=0:k(s,t,s.prev)<0||k(s,s.next,t)<0}function Cl(s,t){let e=s,i=!1;const n=(s.x+t.x)/2,r=(s.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&n<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==s);return i}function mo(s,t){const e=new Nn(s.i,s.x,s.y),i=new Nn(t.i,t.x,t.y),n=s.next,r=t.prev;return s.next=t,t.prev=s,e.next=n,n.prev=e,i.next=e,e.prev=i,r.next=i,i.prev=r,i}function fr(s,t,e,i){const n=new Nn(s,t,e);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function Ge(s){s.next.prev=s.prev,s.prev.next=s.next,s.prevZ&&(s.prevZ.nextZ=s.nextZ),s.nextZ&&(s.nextZ.prevZ=s.prevZ)}function Nn(s,t,e){this.i=s,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Bl(s,t,e,i){let n=0;for(let r=t,o=e-i;r<e;r+=i)n+=(s[o]-s[r])*(s[r+1]+s[o+1]),o=r;return n}class go{static area(t){const e=t.length;let i=0;for(let n=e-1,r=0;r<e;n=r++)i+=t[n].x*t[r].y-t[r].x*t[n].y;return i*.5}static isClockWise(t){return go.area(t)<0}static triangulateShape(t,e){const i=[],n=[],r=[];mr(t),gr(i,t);let o=t.length;e.forEach(mr);for(let a=0;a<e.length;a++)n.push(o),o+=e[a].length,gr(i,e[a]);const l=yl.triangulate(i,n);for(let a=0;a<l.length;a+=3)r.push(l.slice(a,a+3));return r}}function mr(s){const t=s.length;t>2&&s[t-1].equals(s[0])&&s.pop()}function gr(s,t){for(let e=0;e<t.length;e++)s.push(t[e].x),s.push(t[e].y)}class Fl extends Vt{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new B(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new B(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new F(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pt,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Fc extends Fl{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new F(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return X(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new B(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new B(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new B(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class zc extends Vt{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new B(16777215),this.specular=new B(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new B(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new F(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pt,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Nc extends Vt{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new B(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new B(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new F(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pt,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}function Ti(s,t,e){return!s||!e&&s.constructor===t?s:typeof t.BYTES_PER_ELEMENT=="number"?new t(s):Array.prototype.slice.call(s)}function zl(s){return ArrayBuffer.isView(s)&&!(s instanceof DataView)}function Nl(s){function t(n,r){return s[n]-s[r]}const e=s.length,i=new Array(e);for(let n=0;n!==e;++n)i[n]=n;return i.sort(t),i}function yr(s,t,e){const i=s.length,n=new s.constructor(i);for(let r=0,o=0;o!==i;++r){const l=e[r]*t;for(let a=0;a!==t;++a)n[o++]=s[l+a]}return n}function yo(s,t,e,i){let n=1,r=s[0];for(;r!==void 0&&r[i]===void 0;)r=s[n++];if(r===void 0)return;let o=r[i];if(o!==void 0)if(Array.isArray(o))do o=r[i],o!==void 0&&(t.push(r.time),e.push.apply(e,o)),r=s[n++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[i],o!==void 0&&(t.push(r.time),o.toArray(e,e.length)),r=s[n++];while(r!==void 0);else do o=r[i],o!==void 0&&(t.push(r.time),e.push(o)),r=s[n++];while(r!==void 0)}class ji{constructor(t,e,i,n){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=n!==void 0?n:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,n=e[i],r=e[i-1];i:{t:{let o;e:{n:if(!(t<n)){for(let l=i+2;;){if(n===void 0){if(t<r)break n;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===l)break;if(r=n,n=e[++i],t<n)break t}o=e.length;break e}if(!(t>=r)){const l=e[1];t<l&&(i=2,r=l);for(let a=i-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===a)break;if(n=r,r=e[--i-1],t>=r)break t}o=i,i=0;break e}break i}for(;i<o;){const l=i+o>>>1;t<e[l]?o=l:i=l+1}if(n=e[i],r=e[i-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,r,n)}return this.interpolate_(i,r,t,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,n=this.valueSize,r=t*n;for(let o=0;o!==n;++o)e[o]=i[r+o];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Ol extends ji{constructor(t,e,i,n){super(t,e,i,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(t,e,i){const n=this.parameterPositions;let r=t-2,o=t+1,l=n[r],a=n[o];if(l===void 0)switch(this.getSettings_().endingStart){case 2401:r=t,l=2*e-i;break;case 2402:r=n.length-2,l=e+n[r]-n[r+1];break;default:r=t,l=i}if(a===void 0)switch(this.getSettings_().endingEnd){case 2401:o=t,a=2*i-e;break;case 2402:o=1,a=i+n[1]-n[0];break;default:o=t-1,a=e}const h=(i-e)*.5,u=this.valueSize;this._weightPrev=h/(e-l),this._weightNext=h/(a-i),this._offsetPrev=r*u,this._offsetNext=o*u}interpolate_(t,e,i,n){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,a=t*l,h=a-l,u=this._offsetPrev,c=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(i-e)/(n-e),m=f*f,y=m*f,x=-d*y+2*d*m-d*f,w=(1+d)*y+(-1.5-2*d)*m+(-.5+d)*f+1,M=(-1-p)*y+(1.5+p)*m+.5*f,_=p*y-p*m;for(let v=0;v!==l;++v)r[v]=x*o[u+v]+w*o[h+v]+M*o[a+v]+_*o[c+v];return r}}class Vl extends ji{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,a=t*l,h=a-l,u=(i-e)/(n-e),c=1-u;for(let d=0;d!==l;++d)r[d]=o[h+d]*c+o[a+d]*u;return r}}class Ul extends ji{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t){return this.copySampleValue_(t-1)}}class _t{constructor(t,e,i,n){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=Ti(e,this.TimeBufferType),this.values=Ti(i,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:Ti(t.times,Array),values:Ti(t.values,Array)};const n=t.getInterpolation();n!==t.DefaultInterpolation&&(i.interpolation=n)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new Ul(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Vl(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Ol(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case 2300:e=this.InterpolantFactoryMethodDiscrete;break;case 2301:e=this.InterpolantFactoryMethodLinear;break;case 2302:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,n=e.length;i!==n;++i)e[i]*=t}return this}trim(t,e){const i=this.times,n=i.length;let r=0,o=n-1;for(;r!==n&&i[r]<t;)++r;for(;o!==-1&&i[o]>e;)--o;if(++o,r!==0||o!==n){r>=o&&(o=Math.max(o,1),r=o-1);const l=this.getValueSize();this.times=i.slice(r,o),this.values=this.values.slice(r*l,o*l)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,n=this.values,r=i.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let o=null;for(let l=0;l!==r;l++){const a=i[l];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,l,a),t=!1;break}if(o!==null&&o>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,l,a,o),t=!1;break}o=a}if(n!==void 0&&zl(n))for(let l=0,a=n.length;l!==a;++l){const h=n[l];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,l,h),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),i=this.getValueSize(),n=this.getInterpolation()===2302,r=t.length-1;let o=1;for(let l=1;l<r;++l){let a=!1;const h=t[l],u=t[l+1];if(h!==u&&(l!==1||h!==t[0]))if(n)a=!0;else{const c=l*i,d=c-i,p=c+i;for(let f=0;f!==i;++f){const m=e[c+f];if(m!==e[d+f]||m!==e[p+f]){a=!0;break}}}if(a){if(l!==o){t[o]=t[l];const c=l*i,d=o*i;for(let p=0;p!==i;++p)e[d+p]=e[c+p]}++o}}if(r>0){t[o]=t[r];for(let l=r*i,a=o*i,h=0;h!==i;++h)e[a+h]=e[l+h];++o}return o!==t.length?(this.times=t.slice(0,o),this.values=e.slice(0,o*i)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),i=this.constructor,n=new i(this.name,t,e);return n.createInterpolant=this.createInterpolant,n}}_t.prototype.TimeBufferType=Float32Array;_t.prototype.ValueBufferType=Float32Array;_t.prototype.DefaultInterpolation=2301;class ve extends _t{constructor(t,e,i){super(t,e,i)}}ve.prototype.ValueTypeName="bool";ve.prototype.ValueBufferType=Array;ve.prototype.DefaultInterpolation=2300;ve.prototype.InterpolantFactoryMethodLinear=void 0;ve.prototype.InterpolantFactoryMethodSmooth=void 0;class xo extends _t{}xo.prototype.ValueTypeName="color";class zi extends _t{}zi.prototype.ValueTypeName="number";class kl extends ji{constructor(t,e,i,n){super(t,e,i,n)}interpolate_(t,e,i,n){const r=this.resultBuffer,o=this.sampleValues,l=this.valueSize,a=(i-e)/(n-e);let h=t*l;for(let u=h+l;h!==u;h+=4)I.slerpFlat(r,0,o,h-l,o,h,a);return r}}class qi extends _t{InterpolantFactoryMethodLinear(t){return new kl(this.times,this.values,this.getValueSize(),t)}}qi.prototype.ValueTypeName="quaternion";qi.prototype.InterpolantFactoryMethodSmooth=void 0;class we extends _t{constructor(t,e,i){super(t,e,i)}}we.prototype.ValueTypeName="string";we.prototype.ValueBufferType=Array;we.prototype.DefaultInterpolation=2300;we.prototype.InterpolantFactoryMethodLinear=void 0;we.prototype.InterpolantFactoryMethodSmooth=void 0;class Ni extends _t{}Ni.prototype.ValueTypeName="vector";class Oc{constructor(t="",e=-1,i=[],n=2500){this.name=t,this.tracks=i,this.duration=e,this.blendMode=n,this.uuid=dt(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,n=1/(t.fps||1);for(let o=0,l=i.length;o!==l;++o)e.push(Wl(i[o]).scale(n));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],i=t.tracks,n={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,o=i.length;r!==o;++r)e.push(_t.toJSON(i[r]));return n}static CreateFromMorphTargetSequence(t,e,i,n){const r=e.length,o=[];for(let l=0;l<r;l++){let a=[],h=[];a.push((l+r-1)%r,l,(l+1)%r),h.push(0,1,0);const u=Nl(a);a=yr(a,1,u),h=yr(h,1,u),!n&&a[0]===0&&(a.push(r),h.push(h[0])),o.push(new zi(".morphTargetInfluences["+e[l].name+"]",a,h).scale(1/i))}return new this(t,-1,o)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const n=t;i=n.geometry&&n.geometry.animations||n.animations}for(let n=0;n<i.length;n++)if(i[n].name===e)return i[n];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const n={},r=/^([\w-]*?)([\d]+)$/;for(let l=0,a=t.length;l<a;l++){const h=t[l],u=h.name.match(r);if(u&&u.length>1){const c=u[1];let d=n[c];d||(n[c]=d=[]),d.push(h)}}const o=[];for(const l in n)o.push(this.CreateFromMorphTargetSequence(l,n[l],e,i));return o}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(c,d,p,f,m){if(p.length!==0){const y=[],x=[];yo(p,y,x,f),y.length!==0&&m.push(new c(d,y,x))}},n=[],r=t.name||"default",o=t.fps||30,l=t.blendMode;let a=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const d=h[c].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let m=0;m<d[f].morphTargets.length;m++)p[d[f].morphTargets[m]]=-1;for(const m in p){const y=[],x=[];for(let w=0;w!==d[f].morphTargets.length;++w){const M=d[f];y.push(M.time),x.push(M.morphTarget===m?1:0)}n.push(new zi(".morphTargetInfluence["+m+"]",y,x))}a=p.length*o}else{const p=".bones["+e[c].name+"]";i(Ni,p+".position",d,"pos",n),i(qi,p+".quaternion",d,"rot",n),i(Ni,p+".scale",d,"scl",n)}}return n.length===0?null:new this(r,a,n,l)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,n=t.length;i!==n;++i){const r=this.tracks[i];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Dl(s){switch(s.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return zi;case"vector":case"vector2":case"vector3":case"vector4":return Ni;case"color":return xo;case"quaternion":return qi;case"bool":case"boolean":return ve;case"string":return we}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+s)}function Wl(s){if(s.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=Dl(s.type);if(s.times===void 0){const e=[],i=[];yo(s.keys,e,i,"value"),s.times=e,s.values=i}return t.parse!==void 0?t.parse(s):new t(s.name,s.times,s.values,s.interpolation)}const Nt={enabled:!1,files:{},add:function(s,t){this.enabled!==!1&&(this.files[s]=t)},get:function(s){if(this.enabled!==!1)return this.files[s]},remove:function(s){delete this.files[s]},clear:function(){this.files={}}};class Hl{constructor(t,e,i){const n=this;let r=!1,o=0,l=0,a;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(u){l++,r===!1&&n.onStart!==void 0&&n.onStart(u,o,l),r=!0},this.itemEnd=function(u){o++,n.onProgress!==void 0&&n.onProgress(u,o,l),o===l&&(r=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(u){n.onError!==void 0&&n.onError(u)},this.resolveURL=function(u){return a?a(u):u},this.setURLModifier=function(u){return a=u,this},this.addHandler=function(u,c){return h.push(u,c),this},this.removeHandler=function(u){const c=h.indexOf(u);return c!==-1&&h.splice(c,2),this},this.getHandler=function(u){for(let c=0,d=h.length;c<d;c+=2){const p=h[c],f=h[c+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const jl=new Hl;class Ze{constructor(t){this.manager=t!==void 0?t:jl,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(n,r){i.load(t,n,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}Ze.DEFAULT_MATERIAL_NAME="__DEFAULT";const Tt={};class ql extends Error{constructor(t,e){super(t),this.response=e}}class Vc extends Ze{constructor(t){super(t)}load(t,e,i,n){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=Nt.get(t);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(Tt[t]!==void 0){Tt[t].push({onLoad:e,onProgress:i,onError:n});return}Tt[t]=[],Tt[t].push({onLoad:e,onProgress:i,onError:n});const o=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),l=this.mimeType,a=this.responseType;fetch(o).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||h.body===void 0||h.body.getReader===void 0)return h;const u=Tt[t],c=h.body.getReader(),d=h.headers.get("X-File-Size")||h.headers.get("Content-Length"),p=d?parseInt(d):0,f=p!==0;let m=0;const y=new ReadableStream({start(x){w();function w(){c.read().then(({done:M,value:_})=>{if(M)x.close();else{m+=_.byteLength;const v=new ProgressEvent("progress",{lengthComputable:f,loaded:m,total:p});for(let S=0,b=u.length;S<b;S++){const T=u[S];T.onProgress&&T.onProgress(v)}x.enqueue(_),w()}},M=>{x.error(M)})}}});return new Response(y)}else throw new ql(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,h)}).then(h=>{switch(a){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(u=>new DOMParser().parseFromString(u,l));case"json":return h.json();default:if(l===void 0)return h.text();{const c=/charset="?([^;"\s]*)"?/i.exec(l),d=c&&c[1]?c[1].toLowerCase():void 0,p=new TextDecoder(d);return h.arrayBuffer().then(f=>p.decode(f))}}}).then(h=>{Nt.add(t,h);const u=Tt[t];delete Tt[t];for(let c=0,d=u.length;c<d;c++){const p=u[c];p.onLoad&&p.onLoad(h)}}).catch(h=>{const u=Tt[t];if(u===void 0)throw this.manager.itemError(t),h;delete Tt[t];for(let c=0,d=u.length;c<d;c++){const p=u[c];p.onError&&p.onError(h)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class _o extends Ze{constructor(t){super(t)}load(t,e,i,n){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=Nt.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;const l=Cn("img");function a(){u(),Nt.add(t,this),e&&e(this),r.manager.itemEnd(t)}function h(c){u(),n&&n(c),r.manager.itemError(t),r.manager.itemEnd(t)}function u(){l.removeEventListener("load",a,!1),l.removeEventListener("error",h,!1)}return l.addEventListener("load",a,!1),l.addEventListener("error",h,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(l.crossOrigin=this.crossOrigin),r.manager.itemStart(t),l.src=t,l}}class Uc extends Ze{constructor(t){super(t)}load(t,e,i,n){const r=new At,o=new _o(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(t,function(l){r.image=l,r.needsUpdate=!0,e!==void 0&&e(r)},i,n),r}}class Xi extends D{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new B(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(e.object.target=this.target.uuid),e}}const yn=new P,xr=new g,_r=new g;class Gn{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new F(512,512),this.map=null,this.mapPass=null,this.matrix=new P,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new hl,this._frameExtents=new F(1,1),this._viewportCount=1,this._viewports=[new rt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;xr.setFromMatrixPosition(t.matrixWorld),e.position.copy(xr),_r.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(_r),e.updateMatrixWorld(),yn.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(yn),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(yn)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Xl extends Gn{constructor(){super(new ho(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=We*2*t.angle*this.focus,n=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;(i!==e.fov||n!==e.aspect||r!==e.far)&&(e.fov=i,e.aspect=n,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class kc extends Xi{constructor(t,e,i=0,n=Math.PI/3,r=0,o=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(D.DEFAULT_UP),this.updateMatrix(),this.target=new D,this.distance=i,this.angle=n,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new Xl}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Mr=new P,Be=new g,xn=new g;class Gl extends Gn{constructor(){super(new ho(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new F(4,2),this._viewportCount=6,this._viewports=[new rt(2,1,1,1),new rt(0,1,1,1),new rt(3,1,1,1),new rt(1,1,1,1),new rt(3,0,1,1),new rt(1,0,1,1)],this._cubeDirections=[new g(1,0,0),new g(-1,0,0),new g(0,0,1),new g(0,0,-1),new g(0,1,0),new g(0,-1,0)],this._cubeUps=[new g(0,1,0),new g(0,1,0),new g(0,1,0),new g(0,1,0),new g(0,0,1),new g(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,n=this.matrix,r=t.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),Be.setFromMatrixPosition(t.matrixWorld),i.position.copy(Be),xn.copy(i.position),xn.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(xn),i.updateMatrixWorld(),n.makeTranslation(-Be.x,-Be.y,-Be.z),Mr.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Mr)}}class Dc extends Xi{constructor(t,e,i=0,n=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=n,this.shadow=new Gl}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Yl extends Gn{constructor(){super(new ul(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class Wc extends Xi{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(D.DEFAULT_UP),this.updateMatrix(),this.target=new D,this.shadow=new Yl}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class Hc extends Xi{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class jc{static decodeText(t){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,n=t.length;i<n;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class qc extends Ze{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,n){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=Nt.get(t);if(o!==void 0){if(r.manager.itemStart(t),o.then){o.then(h=>{e&&e(h),r.manager.itemEnd(t)}).catch(h=>{n&&n(h)});return}return setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o}const l={};l.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",l.headers=this.requestHeader;const a=fetch(t,l).then(function(h){return h.blob()}).then(function(h){return createImageBitmap(h,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(h){return Nt.add(t,h),e&&e(h),r.manager.itemEnd(t),h}).catch(function(h){n&&n(h),Nt.remove(t),r.manager.itemError(t),r.manager.itemEnd(t)});Nt.add(t,a),r.manager.itemStart(t)}}const Yn="\\[\\]\\.:\\/",Zl=new RegExp("["+Yn+"]","g"),Zn="[^"+Yn+"]",$l="[^"+Yn.replace("\\.","")+"]",Jl=/((?:WC+[\/:])*)/.source.replace("WC",Zn),Ql=/(WCOD+)?/.source.replace("WCOD",$l),Kl=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Zn),th=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Zn),eh=new RegExp("^"+Jl+Ql+Kl+th+"$"),ih=["material","materials","bones","map"];class nh{constructor(t,e,i){const n=i||O.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,n)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,n=this._bindings[i];n!==void 0&&n.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=i.length;n!==r;++n)i[n].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}}class O{constructor(t,e,i){this.path=e,this.parsedPath=i||O.parseTrackName(e),this.node=O.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new O.Composite(t,e,i):new O(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(Zl,"")}static parseTrackName(t){const e=eh.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=i.nodeName&&i.nodeName.lastIndexOf(".");if(n!==void 0&&n!==-1){const r=i.nodeName.substring(n+1);ih.indexOf(r)!==-1&&(i.nodeName=i.nodeName.substring(0,n),i.objectName=r)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(r){for(let o=0;o<r.length;o++){const l=r[o];if(l.name===e||l.uuid===e)return l;const a=i(l.children);if(a)return a}return null},n=i(t.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)t[e++]=i[n]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let n=0,r=i.length;n!==r;++n)i[n]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,n=e.propertyName;let r=e.propertyIndex;if(t||(t=O.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let h=e.objectIndex;switch(i){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let u=0;u<t.length;u++)if(t[u].name===h){h=u;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[i]}if(h!==void 0){if(t[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[h]}}const o=t[n];if(o===void 0){const h=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+n+" but it wasn't found.",t);return}let l=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?l=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(l=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(r!==void 0){if(n==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}a=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(a=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=n;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][l]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}O.Composite=nh;O.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};O.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};O.prototype.GetterByBindingType=[O.prototype._getValue_direct,O.prototype._getValue_array,O.prototype._getValue_arrayElement,O.prototype._getValue_toArray];O.prototype.SetterByBindingTypeAndVersioning=[[O.prototype._setValue_direct,O.prototype._setValue_direct_setNeedsUpdate,O.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[O.prototype._setValue_array,O.prototype._setValue_array_setNeedsUpdate,O.prototype._setValue_array_setMatrixWorldNeedsUpdate],[O.prototype._setValue_arrayElement,O.prototype._setValue_arrayElement_setNeedsUpdate,O.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[O.prototype._setValue_fromArray,O.prototype._setValue_fromArray_setNeedsUpdate,O.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class vr{constructor(t,e,i,n,r){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=i,this.elementSize=n,this.count=r,this.version=0}set needsUpdate(t){t===!0&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}class sh extends Wi{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],n=new K;n.setAttribute("position",new He(e,3)),n.setAttribute("color",new He(i,3));const r=new Me({vertexColors:!0,toneMapped:!1});super(n,r),this.type="AxesHelper"}setColors(t,e,i){const n=new B,r=this.geometry.attributes.color.array;return n.set(t),n.toArray(r,0),n.toArray(r,3),n.set(e),n.toArray(r,6),n.toArray(r,9),n.set(i),n.toArray(r,12),n.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:xe}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=xe);/*!
 * @pixiv/three-vrm v3.4.1
 * VRM file loader for three.js.
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */var Ai=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())}),C=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())}),wr=class extends D{constructor(s){super(),this.weight=0,this.isBinary=!1,this.overrideBlink="none",this.overrideLookAt="none",this.overrideMouth="none",this._binds=[],this.name=`VRMExpression_${s}`,this.expressionName=s,this.type="VRMExpression",this.visible=!1}get binds(){return this._binds}get overrideBlinkAmount(){return this.overrideBlink==="block"?0<this.outputWeight?1:0:this.overrideBlink==="blend"?this.outputWeight:0}get overrideLookAtAmount(){return this.overrideLookAt==="block"?0<this.outputWeight?1:0:this.overrideLookAt==="blend"?this.outputWeight:0}get overrideMouthAmount(){return this.overrideMouth==="block"?0<this.outputWeight?1:0:this.overrideMouth==="blend"?this.outputWeight:0}get outputWeight(){return this.isBinary?this.weight>.5?1:0:this.weight}addBind(s){this._binds.push(s)}deleteBind(s){const t=this._binds.indexOf(s);t>=0&&this._binds.splice(t,1)}applyWeight(s){var t;let e=this.outputWeight;e*=(t=s?.multiplier)!=null?t:1,this.isBinary&&e<1&&(e=0),this._binds.forEach(i=>i.applyWeight(e))}clearAppliedWeight(){this._binds.forEach(s=>s.clearAppliedWeight())}};function Mo(s,t,e){var i,n;const r=s.parser.json,o=(i=r.nodes)==null?void 0:i[t];if(o==null)return console.warn(`extractPrimitivesInternal: Attempt to use nodes[${t}] of glTF but the node doesn't exist`),null;const l=o.mesh;if(l==null)return null;const a=(n=r.meshes)==null?void 0:n[l];if(a==null)return console.warn(`extractPrimitivesInternal: Attempt to use meshes[${l}] of glTF but the mesh doesn't exist`),null;const h=a.primitives.length,u=[];return e.traverse(c=>{u.length<h&&c.isMesh&&u.push(c)}),u}function br(s,t){return C(this,null,function*(){const e=yield s.parser.getDependency("node",t);return Mo(s,t,e)})}function Sr(s){return C(this,null,function*(){const t=yield s.parser.getDependencies("node"),e=new Map;return t.forEach((i,n)=>{const r=Mo(s,n,i);r!=null&&e.set(n,r)}),e})}var On={Aa:"aa",Ih:"ih",Ou:"ou",Ee:"ee",Oh:"oh",Blink:"blink",Happy:"happy",Angry:"angry",Sad:"sad",Relaxed:"relaxed",LookUp:"lookUp",Surprised:"surprised",LookDown:"lookDown",LookLeft:"lookLeft",LookRight:"lookRight",BlinkLeft:"blinkLeft",BlinkRight:"blinkRight",Neutral:"neutral"};function vo(s){return Math.max(Math.min(s,1),0)}var Tr=class wo{constructor(){this.blinkExpressionNames=["blink","blinkLeft","blinkRight"],this.lookAtExpressionNames=["lookLeft","lookRight","lookUp","lookDown"],this.mouthExpressionNames=["aa","ee","ih","oh","ou"],this._expressions=[],this._expressionMap={}}get expressions(){return this._expressions.concat()}get expressionMap(){return Object.assign({},this._expressionMap)}get presetExpressionMap(){const t={},e=new Set(Object.values(On));return Object.entries(this._expressionMap).forEach(([i,n])=>{e.has(i)&&(t[i]=n)}),t}get customExpressionMap(){const t={},e=new Set(Object.values(On));return Object.entries(this._expressionMap).forEach(([i,n])=>{e.has(i)||(t[i]=n)}),t}copy(t){return this._expressions.concat().forEach(i=>{this.unregisterExpression(i)}),t._expressions.forEach(i=>{this.registerExpression(i)}),this.blinkExpressionNames=t.blinkExpressionNames.concat(),this.lookAtExpressionNames=t.lookAtExpressionNames.concat(),this.mouthExpressionNames=t.mouthExpressionNames.concat(),this}clone(){return new wo().copy(this)}getExpression(t){var e;return(e=this._expressionMap[t])!=null?e:null}registerExpression(t){this._expressions.push(t),this._expressionMap[t.expressionName]=t}unregisterExpression(t){const e=this._expressions.indexOf(t);e===-1&&console.warn("VRMExpressionManager: The specified expressions is not registered"),this._expressions.splice(e,1),delete this._expressionMap[t.expressionName]}getValue(t){var e;const i=this.getExpression(t);return(e=i?.weight)!=null?e:null}setValue(t,e){const i=this.getExpression(t);i&&(i.weight=vo(e))}resetValues(){this._expressions.forEach(t=>{t.weight=0})}getExpressionTrackName(t){const e=this.getExpression(t);return e?`${e.name}.weight`:null}update(){const t=this._calculateWeightMultipliers();this._expressions.forEach(e=>{e.clearAppliedWeight()}),this._expressions.forEach(e=>{let i=1;const n=e.expressionName;this.blinkExpressionNames.indexOf(n)!==-1&&(i*=t.blink),this.lookAtExpressionNames.indexOf(n)!==-1&&(i*=t.lookAt),this.mouthExpressionNames.indexOf(n)!==-1&&(i*=t.mouth),e.applyWeight({multiplier:i})})}_calculateWeightMultipliers(){let t=1,e=1,i=1;return this._expressions.forEach(n=>{t-=n.overrideBlinkAmount,e-=n.overrideLookAtAmount,i-=n.overrideMouthAmount}),t=Math.max(0,t),e=Math.max(0,e),i=Math.max(0,i),{blink:t,lookAt:e,mouth:i}}},Fe={Color:"color",EmissionColor:"emissionColor",ShadeColor:"shadeColor",RimColor:"rimColor",OutlineColor:"outlineColor"},rh={_Color:Fe.Color,_EmissionColor:Fe.EmissionColor,_ShadeColor:Fe.ShadeColor,_RimColor:Fe.RimColor,_OutlineColor:Fe.OutlineColor},oh=new B,bo=class So{constructor({material:t,type:e,targetValue:i,targetAlpha:n}){this.material=t,this.type=e,this.targetValue=i,this.targetAlpha=n??1;const r=this._initColorBindState(),o=this._initAlphaBindState();this._state={color:r,alpha:o}}applyWeight(t){const{color:e,alpha:i}=this._state;if(e!=null){const{propertyName:n,deltaValue:r}=e,o=this.material[n];o?.add(oh.copy(r).multiplyScalar(t))}if(i!=null){const{propertyName:n,deltaValue:r}=i;this.material[n]!=null&&(this.material[n]+=r*t)}}clearAppliedWeight(){const{color:t,alpha:e}=this._state;if(t!=null){const{propertyName:i,initialValue:n}=t,r=this.material[i];r?.copy(n)}if(e!=null){const{propertyName:i,initialValue:n}=e;this.material[i]!=null&&(this.material[i]=n)}}_initColorBindState(){var t,e,i;const{material:n,type:r,targetValue:o}=this,l=this._getPropertyNameMap(),a=(e=(t=l?.[r])==null?void 0:t[0])!=null?e:null;if(a==null)return console.warn(`Tried to add a material color bind to the material ${(i=n.name)!=null?i:"(no name)"}, the type ${r} but the material or the type is not supported.`),null;const u=n[a].clone(),c=new B(o.r-u.r,o.g-u.g,o.b-u.b);return{propertyName:a,initialValue:u,deltaValue:c}}_initAlphaBindState(){var t,e,i;const{material:n,type:r,targetAlpha:o}=this,l=this._getPropertyNameMap(),a=(e=(t=l?.[r])==null?void 0:t[1])!=null?e:null;if(a==null&&o!==1)return console.warn(`Tried to add a material alpha bind to the material ${(i=n.name)!=null?i:"(no name)"}, the type ${r} but the material or the type does not support alpha.`),null;if(a==null)return null;const h=n[a],u=o-h;return{propertyName:a,initialValue:h,deltaValue:u}}_getPropertyNameMap(){var t,e;return(e=(t=Object.entries(So._propertyNameMapMap).find(([i])=>this.material[i]===!0))==null?void 0:t[1])!=null?e:null}};bo._propertyNameMapMap={isMeshStandardMaterial:{color:["color","opacity"],emissionColor:["emissive",null]},isMeshBasicMaterial:{color:["color","opacity"]},isMToonMaterial:{color:["color","opacity"],emissionColor:["emissive",null],outlineColor:["outlineColorFactor",null],matcapColor:["matcapFactor",null],rimColor:["parametricRimColorFactor",null],shadeColor:["shadeColorFactor",null]}};var Ar=bo,Oi=class{constructor({primitives:s,index:t,weight:e}){this.primitives=s,this.index=t,this.weight=e}applyWeight(s){this.primitives.forEach(t=>{var e;((e=t.morphTargetInfluences)==null?void 0:e[this.index])!=null&&(t.morphTargetInfluences[this.index]+=this.weight*s)})}clearAppliedWeight(){this.primitives.forEach(s=>{var t;((t=s.morphTargetInfluences)==null?void 0:t[this.index])!=null&&(s.morphTargetInfluences[this.index]=0)})}},Rr=new F,To=class Ao{constructor({material:t,scale:e,offset:i}){var n,r;this.material=t,this.scale=e,this.offset=i;const o=(n=Object.entries(Ao._propertyNamesMap).find(([l])=>t[l]===!0))==null?void 0:n[1];o==null?(console.warn(`Tried to add a texture transform bind to the material ${(r=t.name)!=null?r:"(no name)"} but the material is not supported.`),this._properties=[]):(this._properties=[],o.forEach(l=>{var a;const h=(a=t[l])==null?void 0:a.clone();if(!h)return null;t[l]=h;const u=h.offset.clone(),c=h.repeat.clone(),d=i.clone().sub(u),p=e.clone().sub(c);this._properties.push({name:l,initialOffset:u,deltaOffset:d,initialScale:c,deltaScale:p})}))}applyWeight(t){this._properties.forEach(e=>{const i=this.material[e.name];i!==void 0&&(i.offset.add(Rr.copy(e.deltaOffset).multiplyScalar(t)),i.repeat.add(Rr.copy(e.deltaScale).multiplyScalar(t)))})}clearAppliedWeight(){this._properties.forEach(t=>{const e=this.material[t.name];e!==void 0&&(e.offset.copy(t.initialOffset),e.repeat.copy(t.initialScale))})}};To._propertyNamesMap={isMeshStandardMaterial:["map","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap"],isMeshBasicMaterial:["map","specularMap","alphaMap"],isMToonMaterial:["map","normalMap","emissiveMap","shadeMultiplyTexture","rimMultiplyTexture","outlineWidthMultiplyTexture","uvAnimationMaskTexture"]};var Er=To,ah=new Set(["1.0","1.0-beta"]),Ro=class Eo{get name(){return"VRMExpressionLoaderPlugin"}constructor(t){this.parser=t}afterRoot(t){return C(this,null,function*(){t.userData.vrmExpressionManager=yield this._import(t)})}_import(t){return C(this,null,function*(){const e=yield this._v1Import(t);if(e)return e;const i=yield this._v0Import(t);return i||null})}_v1Import(t){return C(this,null,function*(){var e,i;const n=this.parser.json;if(!(((e=n.extensionsUsed)==null?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;const o=(i=n.extensions)==null?void 0:i.VRMC_vrm;if(!o)return null;const l=o.specVersion;if(!ah.has(l))return console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${l}"`),null;const a=o.expressions;if(!a)return null;const h=new Set(Object.values(On)),u=new Map;a.preset!=null&&Object.entries(a.preset).forEach(([d,p])=>{if(p!=null){if(!h.has(d)){console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${d}" detected. Ignoring the expression`);return}u.set(d,p)}}),a.custom!=null&&Object.entries(a.custom).forEach(([d,p])=>{if(h.has(d)){console.warn(`VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${d}". Ignoring the expression`);return}u.set(d,p)});const c=new Tr;return yield Promise.all(Array.from(u.entries()).map(d=>C(this,[d],function*([p,f]){var m,y,x,w,M,_,v;const S=new wr(p);if(t.scene.add(S),S.isBinary=(m=f.isBinary)!=null?m:!1,S.overrideBlink=(y=f.overrideBlink)!=null?y:"none",S.overrideLookAt=(x=f.overrideLookAt)!=null?x:"none",S.overrideMouth=(w=f.overrideMouth)!=null?w:"none",(M=f.morphTargetBinds)==null||M.forEach(b=>C(this,null,function*(){var T;if(b.node===void 0||b.index===void 0)return;const E=yield br(t,b.node),A=b.index;if(!E.every(R=>Array.isArray(R.morphTargetInfluences)&&A<R.morphTargetInfluences.length)){console.warn(`VRMExpressionLoaderPlugin: ${f.name} attempts to index morph #${A} but not found.`);return}S.addBind(new Oi({primitives:E,index:A,weight:(T=b.weight)!=null?T:1}))})),f.materialColorBinds||f.textureTransformBinds){const b=[];t.scene.traverse(T=>{const E=T.material;E&&(Array.isArray(E)?b.push(...E):b.push(E))}),(_=f.materialColorBinds)==null||_.forEach(T=>C(this,null,function*(){b.filter(A=>{var R;const L=(R=this.parser.associations.get(A))==null?void 0:R.materials;return T.material===L}).forEach(A=>{S.addBind(new Ar({material:A,type:T.type,targetValue:new B().fromArray(T.targetValue),targetAlpha:T.targetValue[3]}))})})),(v=f.textureTransformBinds)==null||v.forEach(T=>C(this,null,function*(){b.filter(A=>{var R;const L=(R=this.parser.associations.get(A))==null?void 0:R.materials;return T.material===L}).forEach(A=>{var R,L;S.addBind(new Er({material:A,offset:new F().fromArray((R=T.offset)!=null?R:[0,0]),scale:new F().fromArray((L=T.scale)!=null?L:[1,1])}))})}))}c.registerExpression(S)}))),c})}_v0Import(t){return C(this,null,function*(){var e;const i=this.parser.json,n=(e=i.extensions)==null?void 0:e.VRM;if(!n)return null;const r=n.blendShapeMaster;if(!r)return null;const o=new Tr,l=r.blendShapeGroups;if(!l)return o;const a=new Set;return yield Promise.all(l.map(h=>C(this,null,function*(){var u;const c=h.presetName,d=c!=null&&Eo.v0v1PresetNameMap[c]||null,p=d??h.name;if(p==null){console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");return}if(a.has(p)){console.warn(`VRMExpressionLoaderPlugin: An expression preset ${c} has duplicated entries. Ignoring the expression`);return}a.add(p);const f=new wr(p);t.scene.add(f),f.isBinary=(u=h.isBinary)!=null?u:!1,h.binds&&h.binds.forEach(y=>C(this,null,function*(){var x;if(y.mesh===void 0||y.index===void 0)return;const w=[];(x=i.nodes)==null||x.forEach((_,v)=>{_.mesh===y.mesh&&w.push(v)});const M=y.index;yield Promise.all(w.map(_=>C(this,null,function*(){var v;const S=yield br(t,_);if(!S.every(b=>Array.isArray(b.morphTargetInfluences)&&M<b.morphTargetInfluences.length)){console.warn(`VRMExpressionLoaderPlugin: ${h.name} attempts to index ${M}th morph but not found.`);return}f.addBind(new Oi({primitives:S,index:M,weight:.01*((v=y.weight)!=null?v:100)}))})))}));const m=h.materialValues;m&&m.length!==0&&m.forEach(y=>{if(y.materialName===void 0||y.propertyName===void 0||y.targetValue===void 0)return;const x=[];t.scene.traverse(M=>{if(M.material){const _=M.material;Array.isArray(_)?x.push(..._.filter(v=>(v.name===y.materialName||v.name===y.materialName+" (Outline)")&&x.indexOf(v)===-1)):_.name===y.materialName&&x.indexOf(_)===-1&&x.push(_)}});const w=y.propertyName;x.forEach(M=>{if(w==="_MainTex_ST"){const v=new F(y.targetValue[0],y.targetValue[1]),S=new F(y.targetValue[2],y.targetValue[3]);S.y=1-S.y-v.y,f.addBind(new Er({material:M,scale:v,offset:S}));return}const _=rh[w];if(_){f.addBind(new Ar({material:M,type:_,targetValue:new B().fromArray(y.targetValue),targetAlpha:y.targetValue[3]}));return}console.warn(w+" is not supported")})}),o.registerExpression(f)}))),o})}};Ro.v0v1PresetNameMap={a:"aa",e:"ee",i:"ih",o:"oh",u:"ou",blink:"blink",joy:"happy",angry:"angry",sorrow:"sad",fun:"relaxed",lookup:"lookUp",lookdown:"lookDown",lookleft:"lookLeft",lookright:"lookRight",blink_l:"blinkLeft",blink_r:"blinkRight",neutral:"neutral"};var lh=Ro,$n=class fe{constructor(t,e){this._firstPersonOnlyLayer=fe.DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=fe.DEFAULT_THIRDPERSON_ONLY_LAYER,this._initializedLayers=!1,this.humanoid=t,this.meshAnnotations=e}copy(t){if(this.humanoid!==t.humanoid)throw new Error("VRMFirstPerson: humanoid must be same in order to copy");return this.meshAnnotations=t.meshAnnotations.map(e=>({meshes:e.meshes.concat(),type:e.type})),this}clone(){return new fe(this.humanoid,this.meshAnnotations).copy(this)}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}setup({firstPersonOnlyLayer:t=fe.DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:e=fe.DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initializedLayers||(this._firstPersonOnlyLayer=t,this._thirdPersonOnlyLayer=e,this.meshAnnotations.forEach(i=>{i.meshes.forEach(n=>{i.type==="firstPersonOnly"?(n.layers.set(this._firstPersonOnlyLayer),n.traverse(r=>r.layers.set(this._firstPersonOnlyLayer))):i.type==="thirdPersonOnly"?(n.layers.set(this._thirdPersonOnlyLayer),n.traverse(r=>r.layers.set(this._thirdPersonOnlyLayer))):i.type==="auto"&&this._createHeadlessModel(n)})}),this._initializedLayers=!0)}_excludeTriangles(t,e,i,n){let r=0;if(e!=null&&e.length>0)for(let o=0;o<t.length;o+=3){const l=t[o],a=t[o+1],h=t[o+2],u=e[l],c=i[l];if(u[0]>0&&n.includes(c[0])||u[1]>0&&n.includes(c[1])||u[2]>0&&n.includes(c[2])||u[3]>0&&n.includes(c[3]))continue;const d=e[a],p=i[a];if(d[0]>0&&n.includes(p[0])||d[1]>0&&n.includes(p[1])||d[2]>0&&n.includes(p[2])||d[3]>0&&n.includes(p[3]))continue;const f=e[h],m=i[h];f[0]>0&&n.includes(m[0])||f[1]>0&&n.includes(m[1])||f[2]>0&&n.includes(m[2])||f[3]>0&&n.includes(m[3])||(t[r++]=l,t[r++]=a,t[r++]=h)}return r}_createErasedMesh(t,e){const i=new dl(t.geometry.clone(),t.material);i.name=`${t.name}(erase)`,i.frustumCulled=t.frustumCulled,i.layers.set(this._firstPersonOnlyLayer);const n=i.geometry,r=n.getAttribute("skinIndex"),o=r instanceof vr?[]:r.array,l=[];for(let m=0;m<o.length;m+=4)l.push([o[m],o[m+1],o[m+2],o[m+3]]);const a=n.getAttribute("skinWeight"),h=a instanceof vr?[]:a.array,u=[];for(let m=0;m<h.length;m+=4)u.push([h[m],h[m+1],h[m+2],h[m+3]]);const c=n.getIndex();if(!c)throw new Error("The geometry doesn't have an index buffer");const d=Array.from(c.array),p=this._excludeTriangles(d,u,l,e),f=[];for(let m=0;m<p;m++)f[m]=d[m];return n.setIndex(f),t.onBeforeRender&&(i.onBeforeRender=t.onBeforeRender),i.bind(new Ye(t.skeleton.bones,t.skeleton.boneInverses),new P),i}_createHeadlessModelForSkinnedMesh(t,e){const i=[];if(e.skeleton.bones.forEach((r,o)=>{this._isEraseTarget(r)&&i.push(o)}),!i.length){e.layers.enable(this._thirdPersonOnlyLayer),e.layers.enable(this._firstPersonOnlyLayer);return}e.layers.set(this._thirdPersonOnlyLayer);const n=this._createErasedMesh(e,i);t.add(n)}_createHeadlessModel(t){if(t.type==="Group")if(t.layers.set(this._thirdPersonOnlyLayer),this._isEraseTarget(t))t.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer));else{const e=new _e;e.name=`_headless_${t.name}`,e.layers.set(this._firstPersonOnlyLayer),t.parent.add(e),t.children.filter(i=>i.type==="SkinnedMesh").forEach(i=>{const n=i;this._createHeadlessModelForSkinnedMesh(e,n)})}else if(t.type==="SkinnedMesh"){const e=t;this._createHeadlessModelForSkinnedMesh(t.parent,e)}else this._isEraseTarget(t)&&(t.layers.set(this._thirdPersonOnlyLayer),t.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer)))}_isEraseTarget(t){return t===this.humanoid.getRawBoneNode("head")?!0:t.parent?this._isEraseTarget(t.parent):!1}};$n.DEFAULT_FIRSTPERSON_ONLY_LAYER=9;$n.DEFAULT_THIRDPERSON_ONLY_LAYER=10;var Pr=$n,hh=new Set(["1.0","1.0-beta"]),uh=class{get name(){return"VRMFirstPersonLoaderPlugin"}constructor(s){this.parser=s}afterRoot(s){return C(this,null,function*(){const t=s.userData.vrmHumanoid;if(t!==null){if(t===void 0)throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");s.userData.vrmFirstPerson=yield this._import(s,t)}})}_import(s,t){return C(this,null,function*(){if(t==null)return null;const e=yield this._v1Import(s,t);if(e)return e;const i=yield this._v0Import(s,t);return i||null})}_v1Import(s,t){return C(this,null,function*(){var e,i;const n=this.parser.json;if(!(((e=n.extensionsUsed)==null?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;const o=(i=n.extensions)==null?void 0:i.VRMC_vrm;if(!o)return null;const l=o.specVersion;if(!hh.has(l))return console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${l}"`),null;const a=o.firstPerson,h=[],u=yield Sr(s);return Array.from(u.entries()).forEach(([c,d])=>{var p,f;const m=(p=a?.meshAnnotations)==null?void 0:p.find(y=>y.node===c);h.push({meshes:d,type:(f=m?.type)!=null?f:"auto"})}),new Pr(t,h)})}_v0Import(s,t){return C(this,null,function*(){var e;const i=this.parser.json,n=(e=i.extensions)==null?void 0:e.VRM;if(!n)return null;const r=n.firstPerson;if(!r)return null;const o=[],l=yield Sr(s);return Array.from(l.entries()).forEach(([a,h])=>{const u=i.nodes[a],c=r.meshAnnotations?r.meshAnnotations.find(d=>d.mesh===u.mesh):void 0;o.push({meshes:h,type:this._convertV0FlagToV1Type(c?.firstPersonFlag)})}),new Pr(t,o)})}_convertV0FlagToV1Type(s){return s==="FirstPersonOnly"?"firstPersonOnly":s==="ThirdPersonOnly"?"thirdPersonOnly":s==="Both"?"both":"auto"}},Ir=new g,Lr=new g,ch=new I,Cr=class extends _e{constructor(s){super(),this.vrmHumanoid=s,this._boneAxesMap=new Map,Object.values(s.humanBones).forEach(t=>{const e=new sh(1);e.matrixAutoUpdate=!1,e.material.depthTest=!1,e.material.depthWrite=!1,this.add(e),this._boneAxesMap.set(t,e)})}dispose(){Array.from(this._boneAxesMap.values()).forEach(s=>{s.geometry.dispose(),s.material.dispose()})}updateMatrixWorld(s){Array.from(this._boneAxesMap.entries()).forEach(([t,e])=>{t.node.updateWorldMatrix(!0,!1),t.node.matrixWorld.decompose(Ir,ch,Lr);const i=Ir.set(.1,.1,.1).divide(Lr);e.matrix.copy(t.node.matrixWorld).scale(i)}),super.updateMatrixWorld(s)}},_n=["hips","spine","chest","upperChest","neck","head","leftEye","rightEye","jaw","leftUpperLeg","leftLowerLeg","leftFoot","leftToes","rightUpperLeg","rightLowerLeg","rightFoot","rightToes","leftShoulder","leftUpperArm","leftLowerArm","leftHand","rightShoulder","rightUpperArm","rightLowerArm","rightHand","leftThumbMetacarpal","leftThumbProximal","leftThumbDistal","leftIndexProximal","leftIndexIntermediate","leftIndexDistal","leftMiddleProximal","leftMiddleIntermediate","leftMiddleDistal","leftRingProximal","leftRingIntermediate","leftRingDistal","leftLittleProximal","leftLittleIntermediate","leftLittleDistal","rightThumbMetacarpal","rightThumbProximal","rightThumbDistal","rightIndexProximal","rightIndexIntermediate","rightIndexDistal","rightMiddleProximal","rightMiddleIntermediate","rightMiddleDistal","rightRingProximal","rightRingIntermediate","rightRingDistal","rightLittleProximal","rightLittleIntermediate","rightLittleDistal"],dh={hips:null,spine:"hips",chest:"spine",upperChest:"chest",neck:"upperChest",head:"neck",leftEye:"head",rightEye:"head",jaw:"head",leftUpperLeg:"hips",leftLowerLeg:"leftUpperLeg",leftFoot:"leftLowerLeg",leftToes:"leftFoot",rightUpperLeg:"hips",rightLowerLeg:"rightUpperLeg",rightFoot:"rightLowerLeg",rightToes:"rightFoot",leftShoulder:"upperChest",leftUpperArm:"leftShoulder",leftLowerArm:"leftUpperArm",leftHand:"leftLowerArm",rightShoulder:"upperChest",rightUpperArm:"rightShoulder",rightLowerArm:"rightUpperArm",rightHand:"rightLowerArm",leftThumbMetacarpal:"leftHand",leftThumbProximal:"leftThumbMetacarpal",leftThumbDistal:"leftThumbProximal",leftIndexProximal:"leftHand",leftIndexIntermediate:"leftIndexProximal",leftIndexDistal:"leftIndexIntermediate",leftMiddleProximal:"leftHand",leftMiddleIntermediate:"leftMiddleProximal",leftMiddleDistal:"leftMiddleIntermediate",leftRingProximal:"leftHand",leftRingIntermediate:"leftRingProximal",leftRingDistal:"leftRingIntermediate",leftLittleProximal:"leftHand",leftLittleIntermediate:"leftLittleProximal",leftLittleDistal:"leftLittleIntermediate",rightThumbMetacarpal:"rightHand",rightThumbProximal:"rightThumbMetacarpal",rightThumbDistal:"rightThumbProximal",rightIndexProximal:"rightHand",rightIndexIntermediate:"rightIndexProximal",rightIndexDistal:"rightIndexIntermediate",rightMiddleProximal:"rightHand",rightMiddleIntermediate:"rightMiddleProximal",rightMiddleDistal:"rightMiddleIntermediate",rightRingProximal:"rightHand",rightRingIntermediate:"rightRingProximal",rightRingDistal:"rightRingIntermediate",rightLittleProximal:"rightHand",rightLittleIntermediate:"rightLittleProximal",rightLittleDistal:"rightLittleIntermediate"};function Po(s){return s.invert?s.invert():s.inverse(),s}var qt=new g,Xt=new I,Vn=class{constructor(s){this.humanBones=s,this.restPose=this.getAbsolutePose()}getAbsolutePose(){const s={};return Object.keys(this.humanBones).forEach(t=>{const e=t,i=this.getBoneNode(e);i&&(qt.copy(i.position),Xt.copy(i.quaternion),s[e]={position:qt.toArray(),rotation:Xt.toArray()})}),s}getPose(){const s={};return Object.keys(this.humanBones).forEach(t=>{const e=t,i=this.getBoneNode(e);if(!i)return;qt.set(0,0,0),Xt.identity();const n=this.restPose[e];n?.position&&qt.fromArray(n.position).negate(),n?.rotation&&Po(Xt.fromArray(n.rotation)),qt.add(i.position),Xt.premultiply(i.quaternion),s[e]={position:qt.toArray(),rotation:Xt.toArray()}}),s}setPose(s){Object.entries(s).forEach(([t,e])=>{const i=t,n=this.getBoneNode(i);if(!n)return;const r=this.restPose[i];r&&(e?.position&&(n.position.fromArray(e.position),r.position&&n.position.add(qt.fromArray(r.position))),e?.rotation&&(n.quaternion.fromArray(e.rotation),r.rotation&&n.quaternion.multiply(Xt.fromArray(r.rotation))))})}resetPose(){Object.entries(this.restPose).forEach(([s,t])=>{const e=this.getBoneNode(s);e&&(t?.position&&e.position.fromArray(t.position),t?.rotation&&e.quaternion.fromArray(t.rotation))})}getBone(s){var t;return(t=this.humanBones[s])!=null?t:void 0}getBoneNode(s){var t,e;return(e=(t=this.humanBones[s])==null?void 0:t.node)!=null?e:null}},Mn=new g,ph=new I,fh=new g,Br=class Io extends Vn{static _setupTransforms(t){const e=new D;e.name="VRMHumanoidRig";const i={},n={},r={};_n.forEach(l=>{var a;const h=t.getBoneNode(l);if(h){const u=new g,c=new I;h.updateWorldMatrix(!0,!1),h.matrixWorld.decompose(u,c,Mn),i[l]=u,n[l]=h.quaternion.clone();const d=new I;(a=h.parent)==null||a.matrixWorld.decompose(Mn,d,Mn),r[l]=d}});const o={};return _n.forEach(l=>{var a;const h=t.getBoneNode(l);if(h){const u=i[l];let c=l,d;for(;d==null&&(c=dh[c],c!=null);)d=i[c];const p=new D;p.name="Normalized_"+h.name,(c?(a=o[c])==null?void 0:a.node:e).add(p),p.position.copy(u),d&&p.position.sub(d),o[l]={node:p}}}),{rigBones:o,root:e,parentWorldRotations:r,boneRotations:n}}constructor(t){const{rigBones:e,root:i,parentWorldRotations:n,boneRotations:r}=Io._setupTransforms(t);super(e),this.original=t,this.root=i,this._parentWorldRotations=n,this._boneRotations=r}update(){_n.forEach(t=>{const e=this.original.getBoneNode(t);if(e!=null){const i=this.getBoneNode(t),n=this._parentWorldRotations[t],r=ph.copy(n).invert(),o=this._boneRotations[t];if(e.quaternion.copy(i.quaternion).multiply(n).premultiply(r).multiply(o),t==="hips"){const l=i.getWorldPosition(fh);e.parent.updateWorldMatrix(!0,!1);const a=e.parent.matrixWorld,h=l.applyMatrix4(a.invert());e.position.copy(h)}}})}},Fr=class Lo{get restPose(){return console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead."),this.rawRestPose}get rawRestPose(){return this._rawHumanBones.restPose}get normalizedRestPose(){return this._normalizedHumanBones.restPose}get humanBones(){return this._rawHumanBones.humanBones}get rawHumanBones(){return this._rawHumanBones.humanBones}get normalizedHumanBones(){return this._normalizedHumanBones.humanBones}get normalizedHumanBonesRoot(){return this._normalizedHumanBones.root}constructor(t,e){var i;this.autoUpdateHumanBones=(i=e?.autoUpdateHumanBones)!=null?i:!0,this._rawHumanBones=new Vn(t),this._normalizedHumanBones=new Br(this._rawHumanBones)}copy(t){return this.autoUpdateHumanBones=t.autoUpdateHumanBones,this._rawHumanBones=new Vn(t.humanBones),this._normalizedHumanBones=new Br(this._rawHumanBones),this}clone(){return new Lo(this.humanBones,{autoUpdateHumanBones:this.autoUpdateHumanBones}).copy(this)}getAbsolutePose(){return console.warn("VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."),this.getRawAbsolutePose()}getRawAbsolutePose(){return this._rawHumanBones.getAbsolutePose()}getNormalizedAbsolutePose(){return this._normalizedHumanBones.getAbsolutePose()}getPose(){return console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead."),this.getRawPose()}getRawPose(){return this._rawHumanBones.getPose()}getNormalizedPose(){return this._normalizedHumanBones.getPose()}setPose(t){return console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead."),this.setRawPose(t)}setRawPose(t){return this._rawHumanBones.setPose(t)}setNormalizedPose(t){return this._normalizedHumanBones.setPose(t)}resetPose(){return console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead."),this.resetRawPose()}resetRawPose(){return this._rawHumanBones.resetPose()}resetNormalizedPose(){return this._normalizedHumanBones.resetPose()}getBone(t){return console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead."),this.getRawBone(t)}getRawBone(t){return this._rawHumanBones.getBone(t)}getNormalizedBone(t){return this._normalizedHumanBones.getBone(t)}getBoneNode(t){return console.warn("VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."),this.getRawBoneNode(t)}getRawBoneNode(t){return this._rawHumanBones.getBoneNode(t)}getNormalizedBoneNode(t){return this._normalizedHumanBones.getBoneNode(t)}update(){this.autoUpdateHumanBones&&this._normalizedHumanBones.update()}},mh={Hips:"hips",Spine:"spine",Head:"head",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand"},gh=new Set(["1.0","1.0-beta"]),zr={leftThumbProximal:"leftThumbMetacarpal",leftThumbIntermediate:"leftThumbProximal",rightThumbProximal:"rightThumbMetacarpal",rightThumbIntermediate:"rightThumbProximal"},yh=class{get name(){return"VRMHumanoidLoaderPlugin"}constructor(s,t){this.parser=s,this.helperRoot=t?.helperRoot,this.autoUpdateHumanBones=t?.autoUpdateHumanBones}afterRoot(s){return C(this,null,function*(){s.userData.vrmHumanoid=yield this._import(s)})}_import(s){return C(this,null,function*(){const t=yield this._v1Import(s);if(t)return t;const e=yield this._v0Import(s);return e||null})}_v1Import(s){return C(this,null,function*(){var t,e;const i=this.parser.json;if(!(((t=i.extensionsUsed)==null?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;const r=(e=i.extensions)==null?void 0:e.VRMC_vrm;if(!r)return null;const o=r.specVersion;if(!gh.has(o))return console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${o}"`),null;const l=r.humanoid;if(!l)return null;const a=l.humanBones.leftThumbIntermediate!=null||l.humanBones.rightThumbIntermediate!=null,h={};l.humanBones!=null&&(yield Promise.all(Object.entries(l.humanBones).map(c=>C(this,[c],function*([d,p]){let f=d;const m=p.node;if(a){const x=zr[f];x!=null&&(f=x)}const y=yield this.parser.getDependency("node",m);if(y==null){console.warn(`A glTF node bound to the humanoid bone ${f} (index = ${m}) does not exist`);return}h[f]={node:y}}))));const u=new Fr(this._ensureRequiredBonesExist(h),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(s.scene.add(u.normalizedHumanBonesRoot),this.helperRoot){const c=new Cr(u);this.helperRoot.add(c),c.renderOrder=this.helperRoot.renderOrder}return u})}_v0Import(s){return C(this,null,function*(){var t;const i=(t=this.parser.json.extensions)==null?void 0:t.VRM;if(!i)return null;const n=i.humanoid;if(!n)return null;const r={};n.humanBones!=null&&(yield Promise.all(n.humanBones.map(l=>C(this,null,function*(){const a=l.bone,h=l.node;if(a==null||h==null)return;const u=yield this.parser.getDependency("node",h);if(u==null){console.warn(`A glTF node bound to the humanoid bone ${a} (index = ${h}) does not exist`);return}const c=zr[a],d=c??a;if(r[d]!=null){console.warn(`Multiple bone entries for ${d} detected (index = ${h}), ignoring duplicated entries.`);return}r[d]={node:u}}))));const o=new Fr(this._ensureRequiredBonesExist(r),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(s.scene.add(o.normalizedHumanBonesRoot),this.helperRoot){const l=new Cr(o);this.helperRoot.add(l),l.renderOrder=this.helperRoot.renderOrder}return o})}_ensureRequiredBonesExist(s){const t=Object.values(mh).filter(e=>s[e]==null);if(t.length>0)throw new Error(`VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${t.join(", ")}`);return s}},Nr=class extends K{constructor(){super(),this._currentTheta=0,this._currentRadius=0,this.theta=0,this.radius=0,this._currentTheta=0,this._currentRadius=0,this._attrPos=new V(new Float32Array(65*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new V(new Uint16Array(3*63),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let s=!1;this._currentTheta!==this.theta&&(this._currentTheta=this.theta,s=!0),this._currentRadius!==this.radius&&(this._currentRadius=this.radius,s=!0),s&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,0,0,0);for(let s=0;s<64;s++){const t=s/63*this._currentTheta;this._attrPos.setXYZ(s+1,this._currentRadius*Math.sin(t),0,this._currentRadius*Math.cos(t))}this._attrPos.needsUpdate=!0}_buildIndex(){for(let s=0;s<63;s++)this._attrIndex.setXYZ(s*3,0,s+1,s+2);this._attrIndex.needsUpdate=!0}},xh=class extends K{constructor(){super(),this.radius=0,this._currentRadius=0,this.tail=new g,this._currentTail=new g,this._attrPos=new V(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new V(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let s=!1;this._currentRadius!==this.radius&&(this._currentRadius=this.radius,s=!0),this._currentTail.equals(this.tail)||(this._currentTail.copy(this.tail),s=!0),s&&this._buildPosition()}_buildPosition(){for(let s=0;s<32;s++){const t=s/16*Math.PI;this._attrPos.setXYZ(s,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+s,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+s,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let s=0;s<32;s++){const t=(s+1)%32;this._attrIndex.setXY(s*2,s,t),this._attrIndex.setXY(64+s*2,32+s,32+t),this._attrIndex.setXY(128+s*2,64+s,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}},Ri=new I,Or=new I,ze=new g,Vr=new g,Ur=Math.sqrt(2)/2,_h=new I(0,0,-Ur,Ur),Mh=new g(0,1,0),vh=class extends _e{constructor(s){super(),this.matrixAutoUpdate=!1,this.vrmLookAt=s;{const t=new Nr;t.radius=.5;const e=new Bn({color:65280,transparent:!0,opacity:.5,side:2,depthTest:!1,depthWrite:!1});this._meshPitch=new je(t,e),this.add(this._meshPitch)}{const t=new Nr;t.radius=.5;const e=new Bn({color:16711680,transparent:!0,opacity:.5,side:2,depthTest:!1,depthWrite:!1});this._meshYaw=new je(t,e),this.add(this._meshYaw)}{const t=new xh;t.radius=.1;const e=new Me({color:16777215,depthTest:!1,depthWrite:!1});this._lineTarget=new Wi(t,e),this._lineTarget.frustumCulled=!1,this.add(this._lineTarget)}}dispose(){this._meshYaw.geometry.dispose(),this._meshYaw.material.dispose(),this._meshPitch.geometry.dispose(),this._meshPitch.material.dispose(),this._lineTarget.geometry.dispose(),this._lineTarget.material.dispose()}updateMatrixWorld(s){const t=W.DEG2RAD*this.vrmLookAt.yaw;this._meshYaw.geometry.theta=t,this._meshYaw.geometry.update();const e=W.DEG2RAD*this.vrmLookAt.pitch;this._meshPitch.geometry.theta=e,this._meshPitch.geometry.update(),this.vrmLookAt.getLookAtWorldPosition(ze),this.vrmLookAt.getLookAtWorldQuaternion(Ri),Ri.multiply(this.vrmLookAt.getFaceFrontQuaternion(Or)),this._meshYaw.position.copy(ze),this._meshYaw.quaternion.copy(Ri),this._meshPitch.position.copy(ze),this._meshPitch.quaternion.copy(Ri),this._meshPitch.quaternion.multiply(Or.setFromAxisAngle(Mh,t)),this._meshPitch.quaternion.multiply(_h);const{target:i,autoUpdate:n}=this.vrmLookAt;i!=null&&n&&(i.getWorldPosition(Vr).sub(ze),this._lineTarget.geometry.tail.copy(Vr),this._lineTarget.geometry.update(),this._lineTarget.position.copy(ze)),super.updateMatrixWorld(s)}},wh=new g,bh=new g;function Un(s,t){return s.matrixWorld.decompose(wh,t,bh),t}function Ii(s){return[Math.atan2(-s.z,s.x),Math.atan2(s.y,Math.sqrt(s.x*s.x+s.z*s.z))]}function kr(s){const t=Math.round(s/2/Math.PI);return s-2*Math.PI*t}var Dr=new g(0,0,1),Sh=new g,Th=new g,Ah=new g,Rh=new I,vn=new I,Wr=new I,Eh=new I,wn=new pt,Co=class Bo{constructor(t,e){this.offsetFromHeadBone=new g,this.autoUpdate=!0,this.faceFront=new g(0,0,1),this.humanoid=t,this.applier=e,this._yaw=0,this._pitch=0,this._needsUpdate=!0,this._restHeadWorldQuaternion=this.getLookAtWorldQuaternion(new I)}get yaw(){return this._yaw}set yaw(t){this._yaw=t,this._needsUpdate=!0}get pitch(){return this._pitch}set pitch(t){this._pitch=t,this._needsUpdate=!0}get euler(){return console.warn("VRMLookAt: euler is deprecated. use getEuler() instead."),this.getEuler(new pt)}getEuler(t){return t.set(W.DEG2RAD*this._pitch,W.DEG2RAD*this._yaw,0,"YXZ")}copy(t){if(this.humanoid!==t.humanoid)throw new Error("VRMLookAt: humanoid must be same in order to copy");return this.offsetFromHeadBone.copy(t.offsetFromHeadBone),this.applier=t.applier,this.autoUpdate=t.autoUpdate,this.target=t.target,this.faceFront.copy(t.faceFront),this}clone(){return new Bo(this.humanoid,this.applier).copy(this)}reset(){this._yaw=0,this._pitch=0,this._needsUpdate=!0}getLookAtWorldPosition(t){const e=this.humanoid.getRawBoneNode("head");return t.copy(this.offsetFromHeadBone).applyMatrix4(e.matrixWorld)}getLookAtWorldQuaternion(t){const e=this.humanoid.getRawBoneNode("head");return Un(e,t)}getFaceFrontQuaternion(t){if(this.faceFront.distanceToSquared(Dr)<.01)return t.copy(this._restHeadWorldQuaternion).invert();const[e,i]=Ii(this.faceFront);return wn.set(0,.5*Math.PI+e,i,"YZX"),t.setFromEuler(wn).premultiply(Eh.copy(this._restHeadWorldQuaternion).invert())}getLookAtWorldDirection(t){return this.getLookAtWorldQuaternion(vn),this.getFaceFrontQuaternion(Wr),t.copy(Dr).applyQuaternion(vn).applyQuaternion(Wr).applyEuler(this.getEuler(wn))}lookAt(t){const e=Rh.copy(this._restHeadWorldQuaternion).multiply(Po(this.getLookAtWorldQuaternion(vn))),i=this.getLookAtWorldPosition(Th),n=Ah.copy(t).sub(i).applyQuaternion(e).normalize(),[r,o]=Ii(this.faceFront),[l,a]=Ii(n),h=kr(l-r),u=kr(o-a);this._yaw=W.RAD2DEG*h,this._pitch=W.RAD2DEG*u,this._needsUpdate=!0}update(t){this.target!=null&&this.autoUpdate&&this.lookAt(this.target.getWorldPosition(Sh)),this._needsUpdate&&(this._needsUpdate=!1,this.applier.applyYawPitch(this._yaw,this._pitch))}};Co.EULER_ORDER="YXZ";var Ph=Co,Ih=new g(0,0,1),mt=new I,ce=new I,st=new pt(0,0,0,"YXZ"),Li=class{constructor(s,t,e,i,n){this.humanoid=s,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=e,this.rangeMapVerticalDown=i,this.rangeMapVerticalUp=n,this.faceFront=new g(0,0,1),this._restQuatLeftEye=new I,this._restQuatRightEye=new I,this._restLeftEyeParentWorldQuat=new I,this._restRightEyeParentWorldQuat=new I;const r=this.humanoid.getRawBoneNode("leftEye"),o=this.humanoid.getRawBoneNode("rightEye");r&&(this._restQuatLeftEye.copy(r.quaternion),Un(r.parent,this._restLeftEyeParentWorldQuat)),o&&(this._restQuatRightEye.copy(o.quaternion),Un(o.parent,this._restRightEyeParentWorldQuat))}applyYawPitch(s,t){const e=this.humanoid.getRawBoneNode("leftEye"),i=this.humanoid.getRawBoneNode("rightEye"),n=this.humanoid.getNormalizedBoneNode("leftEye"),r=this.humanoid.getNormalizedBoneNode("rightEye");e&&(t<0?st.x=-W.DEG2RAD*this.rangeMapVerticalDown.map(-t):st.x=W.DEG2RAD*this.rangeMapVerticalUp.map(t),s<0?st.y=-W.DEG2RAD*this.rangeMapHorizontalInner.map(-s):st.y=W.DEG2RAD*this.rangeMapHorizontalOuter.map(s),mt.setFromEuler(st),this._getWorldFaceFrontQuat(ce),n.quaternion.copy(ce).multiply(mt).multiply(ce.invert()),mt.copy(this._restLeftEyeParentWorldQuat),e.quaternion.copy(n.quaternion).multiply(mt).premultiply(mt.invert()).multiply(this._restQuatLeftEye)),i&&(t<0?st.x=-W.DEG2RAD*this.rangeMapVerticalDown.map(-t):st.x=W.DEG2RAD*this.rangeMapVerticalUp.map(t),s<0?st.y=-W.DEG2RAD*this.rangeMapHorizontalOuter.map(-s):st.y=W.DEG2RAD*this.rangeMapHorizontalInner.map(s),mt.setFromEuler(st),this._getWorldFaceFrontQuat(ce),r.quaternion.copy(ce).multiply(mt).multiply(ce.invert()),mt.copy(this._restRightEyeParentWorldQuat),i.quaternion.copy(r.quaternion).multiply(mt).premultiply(mt.invert()).multiply(this._restQuatRightEye))}lookAt(s){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const t=W.RAD2DEG*s.y,e=W.RAD2DEG*s.x;this.applyYawPitch(t,e)}_getWorldFaceFrontQuat(s){if(this.faceFront.distanceToSquared(Ih)<.01)return s.identity();const[t,e]=Ii(this.faceFront);return st.set(0,.5*Math.PI+t,e,"YZX"),s.setFromEuler(st)}};Li.type="bone";var kn=class{constructor(s,t,e,i,n){this.expressions=s,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=e,this.rangeMapVerticalDown=i,this.rangeMapVerticalUp=n}applyYawPitch(s,t){t<0?(this.expressions.setValue("lookDown",0),this.expressions.setValue("lookUp",this.rangeMapVerticalUp.map(-t))):(this.expressions.setValue("lookUp",0),this.expressions.setValue("lookDown",this.rangeMapVerticalDown.map(t))),s<0?(this.expressions.setValue("lookLeft",0),this.expressions.setValue("lookRight",this.rangeMapHorizontalOuter.map(-s))):(this.expressions.setValue("lookRight",0),this.expressions.setValue("lookLeft",this.rangeMapHorizontalOuter.map(s)))}lookAt(s){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const t=W.RAD2DEG*s.y,e=W.RAD2DEG*s.x;this.applyYawPitch(t,e)}};kn.type="expression";var Hr=class{constructor(s,t){this.inputMaxValue=s,this.outputScale=t}map(s){return this.outputScale*vo(s/this.inputMaxValue)}},Lh=new Set(["1.0","1.0-beta"]),Ei=.01,Ch=class{get name(){return"VRMLookAtLoaderPlugin"}constructor(s,t){this.parser=s,this.helperRoot=t?.helperRoot}afterRoot(s){return C(this,null,function*(){const t=s.userData.vrmHumanoid;if(t===null)return;if(t===void 0)throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");const e=s.userData.vrmExpressionManager;if(e!==null){if(e===void 0)throw new Error("VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");s.userData.vrmLookAt=yield this._import(s,t,e)}})}_import(s,t,e){return C(this,null,function*(){if(t==null||e==null)return null;const i=yield this._v1Import(s,t,e);if(i)return i;const n=yield this._v0Import(s,t,e);return n||null})}_v1Import(s,t,e){return C(this,null,function*(){var i,n,r;const o=this.parser.json;if(!(((i=o.extensionsUsed)==null?void 0:i.indexOf("VRMC_vrm"))!==-1))return null;const a=(n=o.extensions)==null?void 0:n.VRMC_vrm;if(!a)return null;const h=a.specVersion;if(!Lh.has(h))return console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${h}"`),null;const u=a.lookAt;if(!u)return null;const c=u.type==="expression"?1:10,d=this._v1ImportRangeMap(u.rangeMapHorizontalInner,c),p=this._v1ImportRangeMap(u.rangeMapHorizontalOuter,c),f=this._v1ImportRangeMap(u.rangeMapVerticalDown,c),m=this._v1ImportRangeMap(u.rangeMapVerticalUp,c);let y;u.type==="expression"?y=new kn(e,d,p,f,m):y=new Li(t,d,p,f,m);const x=this._importLookAt(t,y);return x.offsetFromHeadBone.fromArray((r=u.offsetFromHeadBone)!=null?r:[0,.06,0]),x})}_v1ImportRangeMap(s,t){var e,i;let n=(e=s?.inputMaxValue)!=null?e:90;const r=(i=s?.outputScale)!=null?i:t;return n<Ei&&(console.warn("VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"),n=Ei),new Hr(n,r)}_v0Import(s,t,e){return C(this,null,function*(){var i,n,r,o;const a=(i=this.parser.json.extensions)==null?void 0:i.VRM;if(!a)return null;const h=a.firstPerson;if(!h)return null;const u=h.lookAtTypeName==="BlendShape"?1:10,c=this._v0ImportDegreeMap(h.lookAtHorizontalInner,u),d=this._v0ImportDegreeMap(h.lookAtHorizontalOuter,u),p=this._v0ImportDegreeMap(h.lookAtVerticalDown,u),f=this._v0ImportDegreeMap(h.lookAtVerticalUp,u);let m;h.lookAtTypeName==="BlendShape"?m=new kn(e,c,d,p,f):m=new Li(t,c,d,p,f);const y=this._importLookAt(t,m);return h.firstPersonBoneOffset?y.offsetFromHeadBone.set((n=h.firstPersonBoneOffset.x)!=null?n:0,(r=h.firstPersonBoneOffset.y)!=null?r:.06,-((o=h.firstPersonBoneOffset.z)!=null?o:0)):y.offsetFromHeadBone.set(0,.06,0),y.faceFront.set(0,0,-1),m instanceof Li&&m.faceFront.set(0,0,-1),y})}_v0ImportDegreeMap(s,t){var e,i;const n=s?.curve;JSON.stringify(n)!=="[0,0,0,1,1,1,1,0]"&&console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");let r=(e=s?.xRange)!=null?e:90;const o=(i=s?.yRange)!=null?i:t;return r<Ei&&(console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!"),r=Ei),new Hr(r,o)}_importLookAt(s,t){const e=new Ph(s,t);if(this.helperRoot){const i=new vh(e);this.helperRoot.add(i),i.renderOrder=this.helperRoot.renderOrder}return e}};function Bh(s,t){return typeof s!="string"||s===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(s)&&(t=t.replace(/(^https?:\/\/[^/]+).*/i,"$1")),/^(https?:)?\/\//i.test(s)||/^data:.*,.*$/i.test(s)||/^blob:.*$/i.test(s)?s:t+s)}var Fh=new Set(["1.0","1.0-beta"]),zh=class{get name(){return"VRMMetaLoaderPlugin"}constructor(s,t){var e,i,n;this.parser=s,this.needThumbnailImage=(e=t?.needThumbnailImage)!=null?e:!1,this.acceptLicenseUrls=(i=t?.acceptLicenseUrls)!=null?i:["https://vrm.dev/licenses/1.0/"],this.acceptV0Meta=(n=t?.acceptV0Meta)!=null?n:!0}afterRoot(s){return C(this,null,function*(){s.userData.vrmMeta=yield this._import(s)})}_import(s){return C(this,null,function*(){const t=yield this._v1Import(s);if(t!=null)return t;const e=yield this._v0Import(s);return e??null})}_v1Import(s){return C(this,null,function*(){var t,e,i;const n=this.parser.json;if(!(((t=n.extensionsUsed)==null?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;const o=(e=n.extensions)==null?void 0:e.VRMC_vrm;if(o==null)return null;const l=o.specVersion;if(!Fh.has(l))return console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${l}"`),null;const a=o.meta;if(!a)return null;const h=a.licenseUrl;if(!new Set(this.acceptLicenseUrls).has(h))throw new Error(`VRMMetaLoaderPlugin: The license url "${h}" is not accepted`);let c;return this.needThumbnailImage&&a.thumbnailImage!=null&&(c=(i=yield this._extractGLTFImage(a.thumbnailImage))!=null?i:void 0),{metaVersion:"1",name:a.name,version:a.version,authors:a.authors,copyrightInformation:a.copyrightInformation,contactInformation:a.contactInformation,references:a.references,thirdPartyLicenses:a.thirdPartyLicenses,thumbnailImage:c,licenseUrl:a.licenseUrl,avatarPermission:a.avatarPermission,allowExcessivelyViolentUsage:a.allowExcessivelyViolentUsage,allowExcessivelySexualUsage:a.allowExcessivelySexualUsage,commercialUsage:a.commercialUsage,allowPoliticalOrReligiousUsage:a.allowPoliticalOrReligiousUsage,allowAntisocialOrHateUsage:a.allowAntisocialOrHateUsage,creditNotation:a.creditNotation,allowRedistribution:a.allowRedistribution,modification:a.modification,otherLicenseUrl:a.otherLicenseUrl}})}_v0Import(s){return C(this,null,function*(){var t;const i=(t=this.parser.json.extensions)==null?void 0:t.VRM;if(!i)return null;const n=i.meta;if(!n)return null;if(!this.acceptV0Meta)throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");let r;return this.needThumbnailImage&&n.texture!=null&&n.texture!==-1&&(r=yield this.parser.getDependency("texture",n.texture)),{metaVersion:"0",allowedUserName:n.allowedUserName,author:n.author,commercialUssageName:n.commercialUssageName,contactInformation:n.contactInformation,licenseName:n.licenseName,otherLicenseUrl:n.otherLicenseUrl,otherPermissionUrl:n.otherPermissionUrl,reference:n.reference,sexualUssageName:n.sexualUssageName,texture:r??void 0,title:n.title,version:n.version,violentUssageName:n.violentUssageName}})}_extractGLTFImage(s){return C(this,null,function*(){var t;const i=(t=this.parser.json.images)==null?void 0:t[s];if(i==null)return console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${s}] of glTF as a thumbnail but the image doesn't exist`),null;let n=i.uri;if(i.bufferView!=null){const o=yield this.parser.getDependency("bufferView",i.bufferView),l=new Blob([o],{type:i.mimeType});n=URL.createObjectURL(l)}return n==null?(console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${s}] of glTF as a thumbnail but the image couldn't load properly`),null):yield new _o().loadAsync(Bh(n,this.parser.options.path)).catch(o=>(console.error(o),console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image"),null))})}},Nh=class{constructor(s){this.scene=s.scene,this.meta=s.meta,this.humanoid=s.humanoid,this.expressionManager=s.expressionManager,this.firstPerson=s.firstPerson,this.lookAt=s.lookAt}update(s){this.humanoid.update(),this.lookAt&&this.lookAt.update(s),this.expressionManager&&this.expressionManager.update()}},Oh=class extends Nh{constructor(s){super(s),this.materials=s.materials,this.springBoneManager=s.springBoneManager,this.nodeConstraintManager=s.nodeConstraintManager}update(s){super.update(s),this.nodeConstraintManager&&this.nodeConstraintManager.update(),this.springBoneManager&&this.springBoneManager.update(s),this.materials&&this.materials.forEach(t=>{t.update&&t.update(s)})}},Vh=Object.defineProperty,jr=Object.getOwnPropertySymbols,Uh=Object.prototype.hasOwnProperty,kh=Object.prototype.propertyIsEnumerable,qr=(s,t,e)=>t in s?Vh(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,Xr=(s,t)=>{for(var e in t||(t={}))Uh.call(t,e)&&qr(s,e,t[e]);if(jr)for(var e of jr(t))kh.call(t,e)&&qr(s,e,t[e]);return s},Yt=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())}),Dh={"":3e3,srgb:3001};function Wh(s,t){parseInt(xe,10)>=152?s.colorSpace=t:s.encoding=Dh[t]}var Hh=class{get pending(){return Promise.all(this._pendings)}constructor(s,t){this._parser=s,this._materialParams=t,this._pendings=[]}assignPrimitive(s,t){t!=null&&(this._materialParams[s]=t)}assignColor(s,t,e){t!=null&&(this._materialParams[s]=new B().fromArray(t),e&&this._materialParams[s].convertSRGBToLinear())}assignTexture(s,t,e){return Yt(this,null,function*(){const i=Yt(this,null,function*(){t!=null&&(yield this._parser.assignTexture(this._materialParams,s,t),e&&Wh(this._materialParams[s],"srgb"))});return this._pendings.push(i),i})}assignTextureByIndex(s,t,e){return Yt(this,null,function*(){return this.assignTexture(s,t!=null?{index:t}:void 0,e)})}},jh=`// #define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif

#include <common>

// #include <uv_pars_vertex>
#ifdef MTOON_USE_UV
  varying vec2 vUv;

  // COMPAT: pre-r151 uses a common uvTransform
  #if THREE_VRM_THREE_REVISION < 151
    uniform mat3 uvTransform;
  #endif
#endif

// #include <uv2_pars_vertex>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
    uniform mat3 uv2Transform;
  #endif
#endif

// #include <displacementmap_pars_vertex>
// #include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
  uniform sampler2D outlineWidthMultiplyTexture;
  uniform mat3 outlineWidthMultiplyTextureUvTransform;
#endif

uniform float outlineWidthFactor;

void main() {

  // #include <uv_vertex>
  #ifdef MTOON_USE_UV
    // COMPAT: pre-r151 uses a common uvTransform
    #if THREE_VRM_THREE_REVISION >= 151
      vUv = uv;
    #else
      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    #endif
  #endif

  // #include <uv2_vertex>
  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap
  #if THREE_VRM_THREE_REVISION < 151
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
    #endif
  #endif

  #include <color_vertex>

  #include <beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>

  // we need this to compute the outline properly
  objectNormal = normalize( objectNormal );

  #include <defaultnormal_vertex>

  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
    vNormal = normalize( transformedNormal );
  #endif

  #include <begin_vertex>

  #include <morphtarget_vertex>
  #include <skinning_vertex>
  // #include <displacementmap_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>

  vViewPosition = - mvPosition.xyz;

  #ifdef OUTLINE
    float worldNormalLength = length( transformedNormal );
    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;

    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;
      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;
      outlineOffset *= outlineTex;
    #endif

    #ifdef OUTLINE_WIDTH_SCREEN
      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );

    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic
  #endif

  #include <worldpos_vertex>
  // #include <envmap_vertex>
  #include <shadowmap_vertex>
  #include <fog_vertex>

}`,qh=`// #define PHONG

uniform vec3 litFactor;

uniform float opacity;

uniform vec3 shadeColorFactor;
#ifdef USE_SHADEMULTIPLYTEXTURE
  uniform sampler2D shadeMultiplyTexture;
  uniform mat3 shadeMultiplyTextureUvTransform;
#endif

uniform float shadingShiftFactor;
uniform float shadingToonyFactor;

#ifdef USE_SHADINGSHIFTTEXTURE
  uniform sampler2D shadingShiftTexture;
  uniform mat3 shadingShiftTextureUvTransform;
  uniform float shadingShiftTextureScale;
#endif

uniform float giEqualizationFactor;

uniform vec3 parametricRimColorFactor;
#ifdef USE_RIMMULTIPLYTEXTURE
  uniform sampler2D rimMultiplyTexture;
  uniform mat3 rimMultiplyTextureUvTransform;
#endif
uniform float rimLightingMixFactor;
uniform float parametricRimFresnelPowerFactor;
uniform float parametricRimLiftFactor;

#ifdef USE_MATCAPTEXTURE
  uniform vec3 matcapFactor;
  uniform sampler2D matcapTexture;
  uniform mat3 matcapTextureUvTransform;
#endif

uniform vec3 emissive;
uniform float emissiveIntensity;

uniform vec3 outlineColorFactor;
uniform float outlineLightingMixFactor;

#ifdef USE_UVANIMATIONMASKTEXTURE
  uniform sampler2D uvAnimationMaskTexture;
  uniform mat3 uvAnimationMaskTextureUvTransform;
#endif

uniform float uvAnimationScrollXOffset;
uniform float uvAnimationScrollYOffset;
uniform float uvAnimationRotationPhase;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>

// #include <uv_pars_fragment>
#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
  varying vec2 vUv;
#endif

// #include <uv2_pars_fragment>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
  #endif
#endif

#include <map_pars_fragment>

#ifdef USE_MAP
  uniform mat3 mapUvTransform;
#endif

// #include <alphamap_pars_fragment>

#include <alphatest_pars_fragment>

#include <aomap_pars_fragment>
// #include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>

#ifdef USE_EMISSIVEMAP
  uniform mat3 emissiveMapUvTransform;
#endif

// #include <envmap_common_pars_fragment>
// #include <envmap_pars_fragment>
// #include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>

// #include <bsdfs>
// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>
#if THREE_VRM_THREE_REVISION < 151
  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
    return RECIPROCAL_PI * diffuseColor;
  }
#endif

#include <lights_pars_begin>

#include <normal_pars_fragment>

// #include <lights_phong_pars_fragment>
varying vec3 vViewPosition;

struct MToonMaterial {
  vec3 diffuseColor;
  vec3 shadeColor;
  float shadingShift;
};

float linearstep( float a, float b, float t ) {
  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );
}

/**
 * Convert NdotL into toon shading factor using shadingShift and shadingToony
 */
float getShading(
  const in float dotNL,
  const in float shadow,
  const in float shadingShift
) {
  float shading = dotNL;
  shading = shading + shadingShift;
  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );
  shading *= shadow;
  return shading;
}

/**
 * Mix diffuseColor and shadeColor using shading factor and light color
 */
vec3 getDiffuse(
  const in MToonMaterial material,
  const in float shading,
  in vec3 lightColor
) {
  #ifdef DEBUG_LITSHADERATE
    return vec3( BRDF_Lambert( shading * lightColor ) );
  #endif

  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );

  // The "comment out if you want to PBR absolutely" line
  #ifdef V0_COMPAT_SHADE
    col = min( col, material.diffuseColor );
  #endif

  return col;
}

// COMPAT: pre-r156 uses a struct GeometricContext
#if THREE_VRM_THREE_REVISION >= 157
  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#else
  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#endif

#define RE_Direct RE_Direct_MToon
#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon
#define Material_LightProbeLOD( material ) (0)

#include <shadowmap_pars_fragment>
// #include <bumpmap_pars_fragment>

// #include <normalmap_pars_fragment>
#ifdef USE_NORMALMAP

  uniform sampler2D normalMap;
  uniform mat3 normalMapUvTransform;
  uniform vec2 normalScale;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

  uniform mat3 normalMatrix;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )

  // Per-Pixel Tangent Space Normal Mapping
  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

  // three-vrm specific change: it requires \`uv\` as an input in order to support uv scrolls

  // Temporary compat against shader change @ Three.js r126, r151
  #if THREE_VRM_THREE_REVISION >= 151

    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

      vec3 q0 = dFdx( eye_pos.xyz );
      vec3 q1 = dFdy( eye_pos.xyz );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = surf_norm;

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

      return mat3( T * scale, B * scale, N );

    }

  #else

    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = normalize( surf_norm );

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0
      // TODO: Is this still required? Or shall I make a PR about it?
      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {
        return surf_norm;
      }

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

    }

  #endif

#endif

// #include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// == post correction ==========================================================
void postCorrection() {
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
  #include <dithering_fragment>
}

// == main procedure ===========================================================
void main() {
  #include <clipping_planes_fragment>

  vec2 uv = vec2(0.5, 0.5);

  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
    uv = vUv;

    float uvAnimMask = 1.0;
    #ifdef USE_UVANIMATIONMASKTEXTURE
      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;
      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;
    #endif

    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );
    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );
    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;
    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;
  #endif

  #ifdef DEBUG_UV
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
      gl_FragColor = vec4( uv, 0.0, 1.0 );
    #endif
    return;
  #endif

  vec4 diffuseColor = vec4( litFactor, opacity );
  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;

  #include <logdepthbuf_fragment>

  // #include <map_fragment>
  #ifdef USE_MAP
    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;
    vec4 sampledDiffuseColor = texture2D( map, mapUv );
    #ifdef DECODE_VIDEO_TEXTURE
      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
    #endif
    diffuseColor *= sampledDiffuseColor;
  #endif

  // #include <color_fragment>
  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    diffuseColor.rgb *= vColor;
  #endif

  // #include <alphamap_fragment>

  #include <alphatest_fragment>

  // #include <specularmap_fragment>

  // #include <normal_fragment_begin>
  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;

  #ifdef FLAT_SHADED

    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );

  #else

    vec3 normal = normalize( vNormal );

    #ifdef DOUBLE_SIDED

      normal *= faceDirection;

    #endif

  #endif

  #ifdef USE_NORMALMAP

    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;

  #endif

  #ifdef USE_NORMALMAP_TANGENTSPACE

    #ifdef USE_TANGENT

      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn[0] *= faceDirection;
      tbn[1] *= faceDirection;

    #endif

  #endif

  #ifdef USE_CLEARCOAT_NORMALMAP

    #ifdef USE_TANGENT

      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn2[0] *= faceDirection;
      tbn2[1] *= faceDirection;

    #endif

  #endif

  // non perturbed normal for clearcoat among others

  vec3 nonPerturbedNormal = normal;

  #ifdef OUTLINE
    normal *= -1.0;
  #endif

  // #include <normal_fragment_maps>

  // COMPAT: pre-r151
  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

    #ifdef FLIP_SIDED

      normal = - normal;

    #endif

    #ifdef DOUBLE_SIDED

      normal = normal * faceDirection;

    #endif

    normal = normalize( normalMatrix * normal );

  // COMPAT: pre-r151
  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )

    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;

    // COMPAT: pre-r151
    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )

      normal = normalize( tbn * mapN );

    #else

      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );

    #endif

  #endif

  // #include <emissivemap_fragment>
  #ifdef USE_EMISSIVEMAP
    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;
    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;
  #endif

  #ifdef DEBUG_NORMAL
    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );
    return;
  #endif

  // -- MToon: lighting --------------------------------------------------------
  // accumulation
  // #include <lights_phong_fragment>
  MToonMaterial material;

  material.diffuseColor = diffuseColor.rgb;

  material.shadeColor = shadeColorFactor;
  #ifdef USE_SHADEMULTIPLYTEXTURE
    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;
  #endif

  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    material.shadeColor.rgb *= vColor;
  #endif

  material.shadingShift = shadingShiftFactor;
  #ifdef USE_SHADINGSHIFTTEXTURE
    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;
  #endif

  // #include <lights_fragment_begin>

  // MToon Specific changes:
  // Since we want to take shadows into account of shading instead of irradiance,
  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.

  // COMPAT: pre-r156 uses a struct GeometricContext
  #if THREE_VRM_THREE_REVISION >= 157
    vec3 geometryPosition = - vViewPosition;
    vec3 geometryNormal = normal;
    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    vec3 geometryClearcoatNormal;

    #ifdef USE_CLEARCOAT

      geometryClearcoatNormal = clearcoatNormal;

    #endif
  #else
    GeometricContext geometry;

    geometry.position = - vViewPosition;
    geometry.normal = normal;
    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    #ifdef USE_CLEARCOAT

      geometry.clearcoatNormal = clearcoatNormal;

    #endif
  #endif

  IncidentLight directLight;

  // since these variables will be used in unrolled loop, we have to define in prior
  float shadow;

  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

      pointLight = pointLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getPointLightInfo( pointLight, geometryPosition, directLight );
      #else
        getPointLightInfo( pointLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
      pointLightShadow = pointLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

    SpotLight spotLight;
    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

      spotLight = spotLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getSpotLightInfo( spotLight, geometryPosition, directLight );
      #else
        getSpotLightInfo( spotLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
      spotLightShadow = spotLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

      directionalLight = directionalLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getDirectionalLightInfo( directionalLight, directLight );
      #else
        getDirectionalLightInfo( directionalLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
      directionalLightShadow = directionalLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

  //   RectAreaLight rectAreaLight;

  //   #pragma unroll_loop_start
  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

  //     rectAreaLight = rectAreaLights[ i ];
  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

  //   }
  //   #pragma unroll_loop_end

  // #endif

  #if defined( RE_IndirectDiffuse )

    vec3 iblIrradiance = vec3( 0.0 );

    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

    // COMPAT: pre-r156 uses a struct GeometricContext
    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES
    #if THREE_VRM_THREE_REVISION >= 157
      #if defined( USE_LIGHT_PROBES )
        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
      #endif
    #else
      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
    #endif

    #if ( NUM_HEMI_LIGHTS > 0 )

      #pragma unroll_loop_start
      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

        // COMPAT: pre-r156 uses a struct GeometricContext
        #if THREE_VRM_THREE_REVISION >= 157
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
        #else
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
        #endif

      }
      #pragma unroll_loop_end

    #endif

  #endif

  // #if defined( RE_IndirectSpecular )

  //   vec3 radiance = vec3( 0.0 );
  //   vec3 clearcoatRadiance = vec3( 0.0 );

  // #endif

  #include <lights_fragment_maps>
  #include <lights_fragment_end>

  // modulation
  #include <aomap_fragment>

  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;

  #ifdef DEBUG_LITSHADERATE
    gl_FragColor = vec4( col, diffuseColor.a );
    postCorrection();
    return;
  #endif

  // -- MToon: rim lighting -----------------------------------------
  vec3 viewDir = normalize( vViewPosition );

  #ifndef PHYSICALLY_CORRECT_LIGHTS
    reflectedLight.directSpecular /= PI;
  #endif
  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );

  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );

  #ifdef USE_MATCAPTEXTURE
    {
      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );
      vec3 y = cross( viewDir, x ); // guaranteed to be normalized
      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );
      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;
      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;
      rim += matcapFactor * matcap;
    }
  #endif

  #ifdef USE_RIMMULTIPLYTEXTURE
    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;
  #endif

  col += rimMix * rim;

  // -- MToon: Emission --------------------------------------------------------
  col += totalEmissiveRadiance;

  // #include <envmap_fragment>

  // -- Almost done! -----------------------------------------------------------
  #if defined( OUTLINE )
    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );
  #endif

  #ifdef OPAQUE
    diffuseColor.a = 1.0;
  #endif

  gl_FragColor = vec4( col, diffuseColor.a );
  postCorrection();
}
`,Xh={None:"none"},Gr={None:"none",ScreenCoordinates:"screenCoordinates"},Gh={3e3:"",3001:"srgb"};function bn(s){return parseInt(xe,10)>=152?s.colorSpace:Gh[s.encoding]}var Yh=class extends ol{constructor(s={}){var t;super({vertexShader:jh,fragmentShader:qh}),this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.fog=!0,this.normalMapType=0,this._ignoreVertexColor=!0,this._v0CompatShade=!1,this._debugMode=Xh.None,this._outlineWidthMode=Gr.None,this._isOutline=!1,s.transparentWithZWrite&&(s.depthWrite=!0),delete s.transparentWithZWrite,s.fog=!0,s.lights=!0,s.clipping=!0,this.uniforms=nl.merge([Pe.common,Pe.normalmap,Pe.emissivemap,Pe.fog,Pe.lights,{litFactor:{value:new B(1,1,1)},mapUvTransform:{value:new U},colorAlpha:{value:1},normalMapUvTransform:{value:new U},shadeColorFactor:{value:new B(0,0,0)},shadeMultiplyTexture:{value:null},shadeMultiplyTextureUvTransform:{value:new U},shadingShiftFactor:{value:0},shadingShiftTexture:{value:null},shadingShiftTextureUvTransform:{value:new U},shadingShiftTextureScale:{value:1},shadingToonyFactor:{value:.9},giEqualizationFactor:{value:.9},matcapFactor:{value:new B(1,1,1)},matcapTexture:{value:null},matcapTextureUvTransform:{value:new U},parametricRimColorFactor:{value:new B(0,0,0)},rimMultiplyTexture:{value:null},rimMultiplyTextureUvTransform:{value:new U},rimLightingMixFactor:{value:1},parametricRimFresnelPowerFactor:{value:5},parametricRimLiftFactor:{value:0},emissive:{value:new B(0,0,0)},emissiveIntensity:{value:1},emissiveMapUvTransform:{value:new U},outlineWidthMultiplyTexture:{value:null},outlineWidthMultiplyTextureUvTransform:{value:new U},outlineWidthFactor:{value:0},outlineColorFactor:{value:new B(0,0,0)},outlineLightingMixFactor:{value:1},uvAnimationMaskTexture:{value:null},uvAnimationMaskTextureUvTransform:{value:new U},uvAnimationScrollXOffset:{value:0},uvAnimationScrollYOffset:{value:0},uvAnimationRotationPhase:{value:0}},(t=s.uniforms)!=null?t:{}]),this.setValues(s),this._uploadUniformsWorkaround(),this.customProgramCacheKey=()=>[...Object.entries(this._generateDefines()).map(([e,i])=>`${e}:${i}`),this.matcapTexture?`matcapTextureColorSpace:${bn(this.matcapTexture)}`:"",this.shadeMultiplyTexture?`shadeMultiplyTextureColorSpace:${bn(this.shadeMultiplyTexture)}`:"",this.rimMultiplyTexture?`rimMultiplyTextureColorSpace:${bn(this.rimMultiplyTexture)}`:""].join(","),this.onBeforeCompile=e=>{const i=parseInt(xe,10),n=Object.entries(Xr(Xr({},this._generateDefines()),this.defines)).filter(([r,o])=>!!o).map(([r,o])=>`#define ${r} ${o}`).join(`
`)+`
`;e.vertexShader=n+e.vertexShader,e.fragmentShader=n+e.fragmentShader,i<154&&(e.fragmentShader=e.fragmentShader.replace("#include <colorspace_fragment>","#include <encodings_fragment>"))}}get color(){return this.uniforms.litFactor.value}set color(s){this.uniforms.litFactor.value=s}get map(){return this.uniforms.map.value}set map(s){this.uniforms.map.value=s}get normalMap(){return this.uniforms.normalMap.value}set normalMap(s){this.uniforms.normalMap.value=s}get normalScale(){return this.uniforms.normalScale.value}set normalScale(s){this.uniforms.normalScale.value=s}get emissive(){return this.uniforms.emissive.value}set emissive(s){this.uniforms.emissive.value=s}get emissiveIntensity(){return this.uniforms.emissiveIntensity.value}set emissiveIntensity(s){this.uniforms.emissiveIntensity.value=s}get emissiveMap(){return this.uniforms.emissiveMap.value}set emissiveMap(s){this.uniforms.emissiveMap.value=s}get shadeColorFactor(){return this.uniforms.shadeColorFactor.value}set shadeColorFactor(s){this.uniforms.shadeColorFactor.value=s}get shadeMultiplyTexture(){return this.uniforms.shadeMultiplyTexture.value}set shadeMultiplyTexture(s){this.uniforms.shadeMultiplyTexture.value=s}get shadingShiftFactor(){return this.uniforms.shadingShiftFactor.value}set shadingShiftFactor(s){this.uniforms.shadingShiftFactor.value=s}get shadingShiftTexture(){return this.uniforms.shadingShiftTexture.value}set shadingShiftTexture(s){this.uniforms.shadingShiftTexture.value=s}get shadingShiftTextureScale(){return this.uniforms.shadingShiftTextureScale.value}set shadingShiftTextureScale(s){this.uniforms.shadingShiftTextureScale.value=s}get shadingToonyFactor(){return this.uniforms.shadingToonyFactor.value}set shadingToonyFactor(s){this.uniforms.shadingToonyFactor.value=s}get giEqualizationFactor(){return this.uniforms.giEqualizationFactor.value}set giEqualizationFactor(s){this.uniforms.giEqualizationFactor.value=s}get matcapFactor(){return this.uniforms.matcapFactor.value}set matcapFactor(s){this.uniforms.matcapFactor.value=s}get matcapTexture(){return this.uniforms.matcapTexture.value}set matcapTexture(s){this.uniforms.matcapTexture.value=s}get parametricRimColorFactor(){return this.uniforms.parametricRimColorFactor.value}set parametricRimColorFactor(s){this.uniforms.parametricRimColorFactor.value=s}get rimMultiplyTexture(){return this.uniforms.rimMultiplyTexture.value}set rimMultiplyTexture(s){this.uniforms.rimMultiplyTexture.value=s}get rimLightingMixFactor(){return this.uniforms.rimLightingMixFactor.value}set rimLightingMixFactor(s){this.uniforms.rimLightingMixFactor.value=s}get parametricRimFresnelPowerFactor(){return this.uniforms.parametricRimFresnelPowerFactor.value}set parametricRimFresnelPowerFactor(s){this.uniforms.parametricRimFresnelPowerFactor.value=s}get parametricRimLiftFactor(){return this.uniforms.parametricRimLiftFactor.value}set parametricRimLiftFactor(s){this.uniforms.parametricRimLiftFactor.value=s}get outlineWidthMultiplyTexture(){return this.uniforms.outlineWidthMultiplyTexture.value}set outlineWidthMultiplyTexture(s){this.uniforms.outlineWidthMultiplyTexture.value=s}get outlineWidthFactor(){return this.uniforms.outlineWidthFactor.value}set outlineWidthFactor(s){this.uniforms.outlineWidthFactor.value=s}get outlineColorFactor(){return this.uniforms.outlineColorFactor.value}set outlineColorFactor(s){this.uniforms.outlineColorFactor.value=s}get outlineLightingMixFactor(){return this.uniforms.outlineLightingMixFactor.value}set outlineLightingMixFactor(s){this.uniforms.outlineLightingMixFactor.value=s}get uvAnimationMaskTexture(){return this.uniforms.uvAnimationMaskTexture.value}set uvAnimationMaskTexture(s){this.uniforms.uvAnimationMaskTexture.value=s}get uvAnimationScrollXOffset(){return this.uniforms.uvAnimationScrollXOffset.value}set uvAnimationScrollXOffset(s){this.uniforms.uvAnimationScrollXOffset.value=s}get uvAnimationScrollYOffset(){return this.uniforms.uvAnimationScrollYOffset.value}set uvAnimationScrollYOffset(s){this.uniforms.uvAnimationScrollYOffset.value=s}get uvAnimationRotationPhase(){return this.uniforms.uvAnimationRotationPhase.value}set uvAnimationRotationPhase(s){this.uniforms.uvAnimationRotationPhase.value=s}get ignoreVertexColor(){return this._ignoreVertexColor}set ignoreVertexColor(s){this._ignoreVertexColor=s,this.needsUpdate=!0}get v0CompatShade(){return this._v0CompatShade}set v0CompatShade(s){this._v0CompatShade=s,this.needsUpdate=!0}get debugMode(){return this._debugMode}set debugMode(s){this._debugMode=s,this.needsUpdate=!0}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(s){this._outlineWidthMode=s,this.needsUpdate=!0}get isOutline(){return this._isOutline}set isOutline(s){this._isOutline=s,this.needsUpdate=!0}get isMToonMaterial(){return!0}update(s){this._uploadUniformsWorkaround(),this._updateUVAnimation(s)}copy(s){return super.copy(s),this.map=s.map,this.normalMap=s.normalMap,this.emissiveMap=s.emissiveMap,this.shadeMultiplyTexture=s.shadeMultiplyTexture,this.shadingShiftTexture=s.shadingShiftTexture,this.matcapTexture=s.matcapTexture,this.rimMultiplyTexture=s.rimMultiplyTexture,this.outlineWidthMultiplyTexture=s.outlineWidthMultiplyTexture,this.uvAnimationMaskTexture=s.uvAnimationMaskTexture,this.normalMapType=s.normalMapType,this.uvAnimationScrollXSpeedFactor=s.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=s.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=s.uvAnimationRotationSpeedFactor,this.ignoreVertexColor=s.ignoreVertexColor,this.v0CompatShade=s.v0CompatShade,this.debugMode=s.debugMode,this.outlineWidthMode=s.outlineWidthMode,this.isOutline=s.isOutline,this.needsUpdate=!0,this}_updateUVAnimation(s){this.uniforms.uvAnimationScrollXOffset.value+=s*this.uvAnimationScrollXSpeedFactor,this.uniforms.uvAnimationScrollYOffset.value+=s*this.uvAnimationScrollYSpeedFactor,this.uniforms.uvAnimationRotationPhase.value+=s*this.uvAnimationRotationSpeedFactor,this.uniforms.alphaTest.value=this.alphaTest,this.uniformsNeedUpdate=!0}_uploadUniformsWorkaround(){this.uniforms.opacity.value=this.opacity,this._updateTextureMatrix(this.uniforms.map,this.uniforms.mapUvTransform),this._updateTextureMatrix(this.uniforms.normalMap,this.uniforms.normalMapUvTransform),this._updateTextureMatrix(this.uniforms.emissiveMap,this.uniforms.emissiveMapUvTransform),this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture,this.uniforms.shadeMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.shadingShiftTexture,this.uniforms.shadingShiftTextureUvTransform),this._updateTextureMatrix(this.uniforms.matcapTexture,this.uniforms.matcapTextureUvTransform),this._updateTextureMatrix(this.uniforms.rimMultiplyTexture,this.uniforms.rimMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture,this.uniforms.outlineWidthMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture,this.uniforms.uvAnimationMaskTextureUvTransform),this.uniformsNeedUpdate=!0}_generateDefines(){const s=parseInt(xe,10),t=this.outlineWidthMultiplyTexture!==null,e=this.map!==null||this.normalMap!==null||this.emissiveMap!==null||this.shadeMultiplyTexture!==null||this.shadingShiftTexture!==null||this.rimMultiplyTexture!==null||this.uvAnimationMaskTexture!==null;return{THREE_VRM_THREE_REVISION:s,OUTLINE:this._isOutline,MTOON_USE_UV:t||e,MTOON_UVS_VERTEX_ONLY:t&&!e,V0_COMPAT_SHADE:this._v0CompatShade,USE_SHADEMULTIPLYTEXTURE:this.shadeMultiplyTexture!==null,USE_SHADINGSHIFTTEXTURE:this.shadingShiftTexture!==null,USE_MATCAPTEXTURE:this.matcapTexture!==null,USE_RIMMULTIPLYTEXTURE:this.rimMultiplyTexture!==null,USE_OUTLINEWIDTHMULTIPLYTEXTURE:this._isOutline&&this.outlineWidthMultiplyTexture!==null,USE_UVANIMATIONMASKTEXTURE:this.uvAnimationMaskTexture!==null,IGNORE_VERTEX_COLOR:this._ignoreVertexColor===!0,DEBUG_NORMAL:this._debugMode==="normal",DEBUG_LITSHADERATE:this._debugMode==="litShadeRate",DEBUG_UV:this._debugMode==="uv",OUTLINE_WIDTH_SCREEN:this._isOutline&&this._outlineWidthMode===Gr.ScreenCoordinates}}_updateTextureMatrix(s,t){s.value&&(s.value.matrixAutoUpdate&&s.value.updateMatrix(),t.value.copy(s.value.matrix))}},Zh=new Set(["1.0","1.0-beta"]),Fo=class Ci{get name(){return Ci.EXTENSION_NAME}constructor(t,e={}){var i,n,r,o;this.parser=t,this.materialType=(i=e.materialType)!=null?i:Yh,this.renderOrderOffset=(n=e.renderOrderOffset)!=null?n:0,this.v0CompatShade=(r=e.v0CompatShade)!=null?r:!1,this.debugMode=(o=e.debugMode)!=null?o:"none",this._mToonMaterialSet=new Set}beforeRoot(){return Yt(this,null,function*(){this._removeUnlitExtensionIfMToonExists()})}afterRoot(t){return Yt(this,null,function*(){t.userData.vrmMToonMaterials=Array.from(this._mToonMaterialSet)})}getMaterialType(t){return this._getMToonExtension(t)?this.materialType:null}extendMaterialParams(t,e){const i=this._getMToonExtension(t);return i?this._extendMaterialParams(i,e):null}loadMesh(t){return Yt(this,null,function*(){var e;const i=this.parser,r=(e=i.json.meshes)==null?void 0:e[t];if(r==null)throw new Error(`MToonMaterialLoaderPlugin: Attempt to use meshes[${t}] of glTF but the mesh doesn't exist`);const o=r.primitives,l=yield i.loadMesh(t);if(o.length===1){const a=l,h=o[0].material;h!=null&&this._setupPrimitive(a,h)}else{const a=l;for(let h=0;h<o.length;h++){const u=a.children[h],c=o[h].material;c!=null&&this._setupPrimitive(u,c)}}return l})}_removeUnlitExtensionIfMToonExists(){const i=this.parser.json.materials;i?.map((n,r)=>{var o;this._getMToonExtension(r)&&((o=n.extensions)!=null&&o.KHR_materials_unlit)&&delete n.extensions.KHR_materials_unlit})}_getMToonExtension(t){var e,i;const o=(e=this.parser.json.materials)==null?void 0:e[t];if(o==null){console.warn(`MToonMaterialLoaderPlugin: Attempt to use materials[${t}] of glTF but the material doesn't exist`);return}const l=(i=o.extensions)==null?void 0:i[Ci.EXTENSION_NAME];if(l==null)return;const a=l.specVersion;if(!Zh.has(a)){console.warn(`MToonMaterialLoaderPlugin: Unknown ${Ci.EXTENSION_NAME} specVersion "${a}"`);return}return l}_extendMaterialParams(t,e){return Yt(this,null,function*(){var i;delete e.metalness,delete e.roughness;const n=new Hh(this.parser,e);n.assignPrimitive("transparentWithZWrite",t.transparentWithZWrite),n.assignColor("shadeColorFactor",t.shadeColorFactor),n.assignTexture("shadeMultiplyTexture",t.shadeMultiplyTexture,!0),n.assignPrimitive("shadingShiftFactor",t.shadingShiftFactor),n.assignTexture("shadingShiftTexture",t.shadingShiftTexture,!0),n.assignPrimitive("shadingShiftTextureScale",(i=t.shadingShiftTexture)==null?void 0:i.scale),n.assignPrimitive("shadingToonyFactor",t.shadingToonyFactor),n.assignPrimitive("giEqualizationFactor",t.giEqualizationFactor),n.assignColor("matcapFactor",t.matcapFactor),n.assignTexture("matcapTexture",t.matcapTexture,!0),n.assignColor("parametricRimColorFactor",t.parametricRimColorFactor),n.assignTexture("rimMultiplyTexture",t.rimMultiplyTexture,!0),n.assignPrimitive("rimLightingMixFactor",t.rimLightingMixFactor),n.assignPrimitive("parametricRimFresnelPowerFactor",t.parametricRimFresnelPowerFactor),n.assignPrimitive("parametricRimLiftFactor",t.parametricRimLiftFactor),n.assignPrimitive("outlineWidthMode",t.outlineWidthMode),n.assignPrimitive("outlineWidthFactor",t.outlineWidthFactor),n.assignTexture("outlineWidthMultiplyTexture",t.outlineWidthMultiplyTexture,!1),n.assignColor("outlineColorFactor",t.outlineColorFactor),n.assignPrimitive("outlineLightingMixFactor",t.outlineLightingMixFactor),n.assignTexture("uvAnimationMaskTexture",t.uvAnimationMaskTexture,!1),n.assignPrimitive("uvAnimationScrollXSpeedFactor",t.uvAnimationScrollXSpeedFactor),n.assignPrimitive("uvAnimationScrollYSpeedFactor",t.uvAnimationScrollYSpeedFactor),n.assignPrimitive("uvAnimationRotationSpeedFactor",t.uvAnimationRotationSpeedFactor),n.assignPrimitive("v0CompatShade",this.v0CompatShade),n.assignPrimitive("debugMode",this.debugMode),yield n.pending})}_setupPrimitive(t,e){const i=this._getMToonExtension(e);if(i){const n=this._parseRenderOrder(i);t.renderOrder=n+this.renderOrderOffset,this._generateOutline(t),this._addToMaterialSet(t);return}}_shouldGenerateOutline(t){return typeof t.outlineWidthMode=="string"&&t.outlineWidthMode!=="none"&&typeof t.outlineWidthFactor=="number"&&t.outlineWidthFactor>0}_generateOutline(t){const e=t.material;if(!(e instanceof Vt)||!this._shouldGenerateOutline(e))return;t.material=[e];const i=e.clone();i.name+=" (Outline)",i.isOutline=!0,i.side=1,t.material.push(i);const n=t.geometry,r=n.index?n.index.count:n.attributes.position.count/3;n.addGroup(0,r,0),n.addGroup(0,r,1)}_addToMaterialSet(t){const e=t.material,i=new Set;Array.isArray(e)?e.forEach(n=>i.add(n)):i.add(e);for(const n of i)this._mToonMaterialSet.add(n)}_parseRenderOrder(t){var e;return(t.transparentWithZWrite?0:19)+((e=t.renderQueueOffsetNumber)!=null?e:0)}};Fo.EXTENSION_NAME="VRMC_materials_mtoon";var $h=Fo,Jh=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())}),zo=class Dn{get name(){return Dn.EXTENSION_NAME}constructor(t){this.parser=t}extendMaterialParams(t,e){return Jh(this,null,function*(){const i=this._getHDREmissiveMultiplierExtension(t);if(i==null)return;console.warn("VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead.");const n=i.emissiveMultiplier;e.emissiveIntensity=n})}_getHDREmissiveMultiplierExtension(t){var e,i;const o=(e=this.parser.json.materials)==null?void 0:e[t];if(o==null){console.warn(`VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${t}] of glTF but the material doesn't exist`);return}const l=(i=o.extensions)==null?void 0:i[Dn.EXTENSION_NAME];if(l!=null)return l}};zo.EXTENSION_NAME="VRMC_materials_hdr_emissiveMultiplier";var Qh=zo,Kh=Object.defineProperty,tu=Object.defineProperties,eu=Object.getOwnPropertyDescriptors,Yr=Object.getOwnPropertySymbols,iu=Object.prototype.hasOwnProperty,nu=Object.prototype.propertyIsEnumerable,Zr=(s,t,e)=>t in s?Kh(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,gt=(s,t)=>{for(var e in t||(t={}))iu.call(t,e)&&Zr(s,e,t[e]);if(Yr)for(var e of Yr(t))nu.call(t,e)&&Zr(s,e,t[e]);return s},$r=(s,t)=>tu(s,eu(t)),su=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())});function de(s){return Math.pow(s,2.2)}var ru=class{get name(){return"VRMMaterialsV0CompatPlugin"}constructor(s){var t;this.parser=s,this._renderQueueMapTransparent=new Map,this._renderQueueMapTransparentZWrite=new Map;const e=this.parser.json;e.extensionsUsed=(t=e.extensionsUsed)!=null?t:[],e.extensionsUsed.indexOf("KHR_texture_transform")===-1&&e.extensionsUsed.push("KHR_texture_transform")}beforeRoot(){return su(this,null,function*(){var s;const t=this.parser.json,e=(s=t.extensions)==null?void 0:s.VRM,i=e?.materialProperties;i&&(this._populateRenderQueueMap(i),i.forEach((n,r)=>{var o,l;const a=(o=t.materials)==null?void 0:o[r];if(a==null){console.warn(`VRMMaterialsV0CompatPlugin: Attempt to use materials[${r}] of glTF but the material doesn't exist`);return}if(n.shader==="VRM/MToon"){const h=this._parseV0MToonProperties(n,a);t.materials[r]=h}else if((l=n.shader)!=null&&l.startsWith("VRM/Unlit")){const h=this._parseV0UnlitProperties(n,a);t.materials[r]=h}else n.shader==="VRM_USE_GLTFSHADER"||console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${n.shader}`)}))})}_parseV0MToonProperties(s,t){var e,i,n,r,o,l,a,h,u,c,d,p,f,m,y,x,w,M,_,v,S,b,T,E,A,R,L,z,G,$,tt,J,ot,ft,H,Ut,Kn,ts,es,is,ns,ss,rs,os,as,ls,hs,us,cs,ds,ps,fs,ms,gs,ys;const xs=(i=(e=s.keywordMap)==null?void 0:e._ALPHABLEND_ON)!=null?i:!1,Wo=((n=s.floatProperties)==null?void 0:n._ZWrite)===1&&xs,Ho=this._v0ParseRenderQueue(s),_s=(o=(r=s.keywordMap)==null?void 0:r._ALPHATEST_ON)!=null?o:!1,jo=xs?"BLEND":_s?"MASK":"OPAQUE",qo=_s?(a=(l=s.floatProperties)==null?void 0:l._Cutoff)!=null?a:.5:void 0,Xo=((u=(h=s.floatProperties)==null?void 0:h._CullMode)!=null?u:2)===0,kt=this._portTextureTransform(s),Go=((d=(c=s.vectorProperties)==null?void 0:c._Color)!=null?d:[1,1,1,1]).map((Es,ya)=>ya===3?Es:de(Es)),Ms=(p=s.textureProperties)==null?void 0:p._MainTex,Yo=Ms!=null?{index:Ms,extensions:gt({},kt)}:void 0,Zo=(m=(f=s.floatProperties)==null?void 0:f._BumpScale)!=null?m:1,vs=(y=s.textureProperties)==null?void 0:y._BumpMap,$o=vs!=null?{index:vs,scale:Zo,extensions:gt({},kt)}:void 0,Jo=((w=(x=s.vectorProperties)==null?void 0:x._EmissionColor)!=null?w:[0,0,0,1]).map(de),ws=(M=s.textureProperties)==null?void 0:M._EmissionMap,Qo=ws!=null?{index:ws,extensions:gt({},kt)}:void 0,Ko=((v=(_=s.vectorProperties)==null?void 0:_._ShadeColor)!=null?v:[.97,.81,.86,1]).map(de),bs=(S=s.textureProperties)==null?void 0:S._ShadeTexture,ta=bs!=null?{index:bs,extensions:gt({},kt)}:void 0;let $e=(T=(b=s.floatProperties)==null?void 0:b._ShadeShift)!=null?T:0,Je=(A=(E=s.floatProperties)==null?void 0:E._ShadeToony)!=null?A:.9;Je=W.lerp(Je,1,.5+.5*$e),$e=-$e-(1-Je);const Ss=(L=(R=s.floatProperties)==null?void 0:R._IndirectLightIntensity)!=null?L:.1,ea=Ss?1-Ss:void 0,Gi=(z=s.textureProperties)==null?void 0:z._SphereAdd,ia=Gi!=null?[1,1,1]:void 0,na=Gi!=null?{index:Gi}:void 0,sa=($=(G=s.floatProperties)==null?void 0:G._RimLightingMix)!=null?$:0,Ts=(tt=s.textureProperties)==null?void 0:tt._RimTexture,ra=Ts!=null?{index:Ts,extensions:gt({},kt)}:void 0,oa=((ot=(J=s.vectorProperties)==null?void 0:J._RimColor)!=null?ot:[0,0,0,1]).map(de),aa=(H=(ft=s.floatProperties)==null?void 0:ft._RimFresnelPower)!=null?H:1,la=(Kn=(Ut=s.floatProperties)==null?void 0:Ut._RimLift)!=null?Kn:0,ha=["none","worldCoordinates","screenCoordinates"][(es=(ts=s.floatProperties)==null?void 0:ts._OutlineWidthMode)!=null?es:0];let Yi=(ns=(is=s.floatProperties)==null?void 0:is._OutlineWidth)!=null?ns:0;Yi=.01*Yi;const As=(ss=s.textureProperties)==null?void 0:ss._OutlineWidthTexture,ua=As!=null?{index:As,extensions:gt({},kt)}:void 0,ca=((os=(rs=s.vectorProperties)==null?void 0:rs._OutlineColor)!=null?os:[0,0,0]).map(de),da=((ls=(as=s.floatProperties)==null?void 0:as._OutlineColorMode)!=null?ls:0)===1?(us=(hs=s.floatProperties)==null?void 0:hs._OutlineLightingMix)!=null?us:1:0,Rs=(cs=s.textureProperties)==null?void 0:cs._UvAnimMaskTexture,pa=Rs!=null?{index:Rs,extensions:gt({},kt)}:void 0,fa=(ps=(ds=s.floatProperties)==null?void 0:ds._UvAnimScrollX)!=null?ps:0;let Qe=(ms=(fs=s.floatProperties)==null?void 0:fs._UvAnimScrollY)!=null?ms:0;Qe!=null&&(Qe=-Qe);const ma=(ys=(gs=s.floatProperties)==null?void 0:gs._UvAnimRotation)!=null?ys:0,ga={specVersion:"1.0",transparentWithZWrite:Wo,renderQueueOffsetNumber:Ho,shadeColorFactor:Ko,shadeMultiplyTexture:ta,shadingShiftFactor:$e,shadingToonyFactor:Je,giEqualizationFactor:ea,matcapFactor:ia,matcapTexture:na,rimLightingMixFactor:sa,rimMultiplyTexture:ra,parametricRimColorFactor:oa,parametricRimFresnelPowerFactor:aa,parametricRimLiftFactor:la,outlineWidthMode:ha,outlineWidthFactor:Yi,outlineWidthMultiplyTexture:ua,outlineColorFactor:ca,outlineLightingMixFactor:da,uvAnimationMaskTexture:pa,uvAnimationScrollXSpeedFactor:fa,uvAnimationScrollYSpeedFactor:Qe,uvAnimationRotationSpeedFactor:ma};return $r(gt({},t),{pbrMetallicRoughness:{baseColorFactor:Go,baseColorTexture:Yo},normalTexture:$o,emissiveTexture:Qo,emissiveFactor:Jo,alphaMode:jo,alphaCutoff:qo,doubleSided:Xo,extensions:{VRMC_materials_mtoon:ga}})}_parseV0UnlitProperties(s,t){var e,i,n,r,o;const l=s.shader==="VRM/UnlitTransparentZWrite",a=s.shader==="VRM/UnlitTransparent"||l,h=this._v0ParseRenderQueue(s),u=s.shader==="VRM/UnlitCutout",c=a?"BLEND":u?"MASK":"OPAQUE",d=u?(i=(e=s.floatProperties)==null?void 0:e._Cutoff)!=null?i:.5:void 0,p=this._portTextureTransform(s),f=((r=(n=s.vectorProperties)==null?void 0:n._Color)!=null?r:[1,1,1,1]).map(de),m=(o=s.textureProperties)==null?void 0:o._MainTex,y=m!=null?{index:m,extensions:gt({},p)}:void 0,x={specVersion:"1.0",transparentWithZWrite:l,renderQueueOffsetNumber:h,shadeColorFactor:f,shadeMultiplyTexture:y};return $r(gt({},t),{pbrMetallicRoughness:{baseColorFactor:f,baseColorTexture:y},alphaMode:c,alphaCutoff:d,extensions:{VRMC_materials_mtoon:x}})}_portTextureTransform(s){var t,e,i,n,r;const o=(t=s.vectorProperties)==null?void 0:t._MainTex;if(o==null)return{};const l=[(e=o?.[0])!=null?e:0,(i=o?.[1])!=null?i:0],a=[(n=o?.[2])!=null?n:1,(r=o?.[3])!=null?r:1];return l[1]=1-a[1]-l[1],{KHR_texture_transform:{offset:l,scale:a}}}_v0ParseRenderQueue(s){var t,e;const i=s.shader==="VRM/UnlitTransparentZWrite",n=((t=s.keywordMap)==null?void 0:t._ALPHABLEND_ON)!=null||s.shader==="VRM/UnlitTransparent"||i,r=((e=s.floatProperties)==null?void 0:e._ZWrite)===1||i;let o=0;if(n){const l=s.renderQueue;l!=null&&(r?o=this._renderQueueMapTransparentZWrite.get(l):o=this._renderQueueMapTransparent.get(l))}return o}_populateRenderQueueMap(s){const t=new Set,e=new Set;s.forEach(i=>{var n,r;const o=i.shader==="VRM/UnlitTransparentZWrite",l=((n=i.keywordMap)==null?void 0:n._ALPHABLEND_ON)!=null||i.shader==="VRM/UnlitTransparent"||o,a=((r=i.floatProperties)==null?void 0:r._ZWrite)===1||o;if(l){const h=i.renderQueue;h!=null&&(a?e.add(h):t.add(h))}}),t.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${t.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),e.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${e.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),Array.from(t).sort().forEach((i,n)=>{const r=Math.min(Math.max(n-t.size+1,-9),0);this._renderQueueMapTransparent.set(i,r)}),Array.from(e).sort().forEach((i,n)=>{const r=Math.min(Math.max(n,0),9);this._renderQueueMapTransparentZWrite.set(i,r)})}},Jr=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())}),Ft=new g,Sn=class extends _e{constructor(s){super(),this._attrPosition=new V(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(35048);const t=new K;t.setAttribute("position",this._attrPosition);const e=new Me({color:16711935,depthTest:!1,depthWrite:!1});this._line=new Xn(t,e),this.add(this._line),this.constraint=s}updateMatrixWorld(s){Ft.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,Ft.x,Ft.y,Ft.z),this.constraint.source&&Ft.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,Ft.x,Ft.y,Ft.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(s)}};function Qr(s,t){return t.set(s.elements[12],s.elements[13],s.elements[14])}var ou=new g,au=new g;function lu(s,t){return s.decompose(ou,t,au),t}function Vi(s){return s.invert?s.invert():s.inverse(),s}var Jn=class{constructor(s,t){this.destination=s,this.source=t,this.weight=1}},hu=new g,uu=new g,cu=new g,du=new I,pu=new I,fu=new I,mu=class extends Jn{get aimAxis(){return this._aimAxis}set aimAxis(s){this._aimAxis=s,this._v3AimAxis.set(s==="PositiveX"?1:s==="NegativeX"?-1:0,s==="PositiveY"?1:s==="NegativeY"?-1:0,s==="PositiveZ"?1:s==="NegativeZ"?-1:0)}get dependencies(){const s=new Set([this.source]);return this.destination.parent&&s.add(this.destination.parent),s}constructor(s,t){super(s,t),this._aimAxis="PositiveX",this._v3AimAxis=new g(1,0,0),this._dstRestQuat=new I}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);const s=du.identity(),t=pu.identity();this.destination.parent&&(lu(this.destination.parent.matrixWorld,s),Vi(t.copy(s)));const e=hu.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(s),i=Qr(this.source.matrixWorld,uu).sub(Qr(this.destination.matrixWorld,cu)).normalize(),n=fu.setFromUnitVectors(e,i).premultiply(t).multiply(s).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(n,this.weight)}};function gu(s,t){const e=[s];let i=s.parent;for(;i!==null;)e.unshift(i),i=i.parent;e.forEach(n=>{t(n)})}var yu=class{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(s){this._constraints.add(s);let t=this._objectConstraintsMap.get(s.destination);t==null&&(t=new Set,this._objectConstraintsMap.set(s.destination,t)),t.add(s)}deleteConstraint(s){this._constraints.delete(s),this._objectConstraintsMap.get(s.destination).delete(s)}setInitState(){const s=new Set,t=new Set;for(const e of this._constraints)this._processConstraint(e,s,t,i=>i.setInitState())}update(){const s=new Set,t=new Set;for(const e of this._constraints)this._processConstraint(e,s,t,i=>i.update())}_processConstraint(s,t,e,i){if(e.has(s))return;if(t.has(s))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");t.add(s);const n=s.dependencies;for(const r of n)gu(r,o=>{const l=this._objectConstraintsMap.get(o);if(l)for(const a of l)this._processConstraint(a,t,e,i)});i(s),e.add(s)}},xu=new I,_u=new I,Mu=class extends Jn{get dependencies(){return new Set([this.source])}constructor(s,t){super(s,t),this._dstRestQuat=new I,this._invSrcRestQuat=new I}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),Vi(this._invSrcRestQuat.copy(this.source.quaternion))}update(){const s=xu.copy(this._invSrcRestQuat).multiply(this.source.quaternion),t=_u.copy(this._dstRestQuat).multiply(s);this.destination.quaternion.copy(this._dstRestQuat).slerp(t,this.weight)}},vu=new g,wu=new I,bu=new I,Su=class extends Jn{get rollAxis(){return this._rollAxis}set rollAxis(s){this._rollAxis=s,this._v3RollAxis.set(s==="X"?1:0,s==="Y"?1:0,s==="Z"?1:0)}get dependencies(){return new Set([this.source])}constructor(s,t){super(s,t),this._rollAxis="X",this._v3RollAxis=new g(1,0,0),this._dstRestQuat=new I,this._invDstRestQuat=new I,this._invSrcRestQuatMulDstRestQuat=new I}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),Vi(this._invDstRestQuat.copy(this._dstRestQuat)),Vi(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){const s=wu.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),t=vu.copy(this._v3RollAxis).applyQuaternion(s),i=bu.setFromUnitVectors(t,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(s);this.destination.quaternion.copy(this._dstRestQuat).slerp(i,this.weight)}},Tu=new Set(["1.0","1.0-beta"]),No=class Ue{get name(){return Ue.EXTENSION_NAME}constructor(t,e){this.parser=t,this.helperRoot=e?.helperRoot}afterRoot(t){return Jr(this,null,function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)})}_import(t){return Jr(this,null,function*(){var e;const i=this.parser.json;if(!(((e=i.extensionsUsed)==null?void 0:e.indexOf(Ue.EXTENSION_NAME))!==-1))return null;const r=new yu,o=yield this.parser.getDependencies("node");return o.forEach((l,a)=>{var h;const u=i.nodes[a],c=(h=u?.extensions)==null?void 0:h[Ue.EXTENSION_NAME];if(c==null)return;const d=c.specVersion;if(!Tu.has(d)){console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${Ue.EXTENSION_NAME} specVersion "${d}"`);return}const p=c.constraint;if(p.roll!=null){const f=this._importRollConstraint(l,o,p.roll);r.addConstraint(f)}else if(p.aim!=null){const f=this._importAimConstraint(l,o,p.aim);r.addConstraint(f)}else if(p.rotation!=null){const f=this._importRotationConstraint(l,o,p.rotation);r.addConstraint(f)}}),t.scene.updateMatrixWorld(),r.setInitState(),r})}_importRollConstraint(t,e,i){const{source:n,rollAxis:r,weight:o}=i,l=e[n],a=new Su(t,l);if(r!=null&&(a.rollAxis=r),o!=null&&(a.weight=o),this.helperRoot){const h=new Sn(a);this.helperRoot.add(h)}return a}_importAimConstraint(t,e,i){const{source:n,aimAxis:r,weight:o}=i,l=e[n],a=new mu(t,l);if(r!=null&&(a.aimAxis=r),o!=null&&(a.weight=o),this.helperRoot){const h=new Sn(a);this.helperRoot.add(h)}return a}_importRotationConstraint(t,e,i){const{source:n,weight:r}=i,o=e[n],l=new Mu(t,o);if(r!=null&&(l.weight=r),this.helperRoot){const a=new Sn(l);this.helperRoot.add(a)}return l}};No.EXTENSION_NAME="VRMC_node_constraint";var Au=No,Pi=(s,t,e)=>new Promise((i,n)=>{var r=a=>{try{l(e.next(a))}catch(h){n(h)}},o=a=>{try{l(e.throw(a))}catch(h){n(h)}},l=a=>a.done?i(a.value):Promise.resolve(a.value).then(r,o);l((e=e.apply(s,t)).next())}),Qn=class{},Tn=new g,Gt=new g,Oo=class extends Qn{get type(){return"capsule"}constructor(s){var t,e,i,n;super(),this.offset=(t=s?.offset)!=null?t:new g(0,0,0),this.tail=(e=s?.tail)!=null?e:new g(0,0,0),this.radius=(i=s?.radius)!=null?i:0,this.inside=(n=s?.inside)!=null?n:!1}calculateCollision(s,t,e,i){Tn.setFromMatrixPosition(s),Gt.subVectors(this.tail,this.offset).applyMatrix4(s),Gt.sub(Tn);const n=Gt.lengthSq();i.copy(t).sub(Tn);const r=Gt.dot(i);r<=0||(n<=r||Gt.multiplyScalar(r/n),i.sub(Gt));const o=i.length(),l=this.inside?this.radius-e-o:o-e-this.radius;return l<0&&(i.multiplyScalar(1/o),this.inside&&i.negate()),l}},An=new g,Kr=new U,Vo=class extends Qn{get type(){return"plane"}constructor(s){var t,e;super(),this.offset=(t=s?.offset)!=null?t:new g(0,0,0),this.normal=(e=s?.normal)!=null?e:new g(0,0,1)}calculateCollision(s,t,e,i){i.setFromMatrixPosition(s),i.negate().add(t),Kr.getNormalMatrix(s),An.copy(this.normal).applyNormalMatrix(Kr).normalize();const n=i.dot(An)-e;return i.copy(An),n}},Ru=new g,Uo=class extends Qn{get type(){return"sphere"}constructor(s){var t,e,i;super(),this.offset=(t=s?.offset)!=null?t:new g(0,0,0),this.radius=(e=s?.radius)!=null?e:0,this.inside=(i=s?.inside)!=null?i:!1}calculateCollision(s,t,e,i){i.subVectors(t,Ru.setFromMatrixPosition(s));const n=i.length(),r=this.inside?this.radius-e-n:n-e-this.radius;return r<0&&(i.multiplyScalar(1/n),this.inside&&i.negate()),r}},yt=new g,Eu=class extends K{constructor(s){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new g,this._currentTail=new g,this._shape=s,this._attrPos=new V(new Float32Array(396),3),this.setAttribute("position",this._attrPos),this._attrIndex=new V(new Uint16Array(264),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let s=!1;const t=this._shape.radius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,s=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),s=!0);const e=yt.copy(this._shape.tail).divideScalar(this.worldScale);this._currentTail.distanceToSquared(e)>1e-10&&(this._currentTail.copy(e),s=!0),s&&this._buildPosition()}_buildPosition(){yt.copy(this._currentTail).sub(this._currentOffset);const s=yt.length()/this._currentRadius;for(let i=0;i<=16;i++){const n=i/16*Math.PI;this._attrPos.setXYZ(i,-Math.sin(n),-Math.cos(n),0),this._attrPos.setXYZ(17+i,s+Math.sin(n),Math.cos(n),0),this._attrPos.setXYZ(34+i,-Math.sin(n),0,-Math.cos(n)),this._attrPos.setXYZ(51+i,s+Math.sin(n),0,Math.cos(n))}for(let i=0;i<32;i++){const n=i/16*Math.PI;this._attrPos.setXYZ(68+i,0,Math.sin(n),Math.cos(n)),this._attrPos.setXYZ(100+i,s,Math.sin(n),Math.cos(n))}const t=Math.atan2(yt.y,Math.sqrt(yt.x*yt.x+yt.z*yt.z)),e=-Math.atan2(yt.z,yt.x);this.rotateZ(t),this.rotateY(e),this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let s=0;s<34;s++){const t=(s+1)%34;this._attrIndex.setXY(s*2,s,t),this._attrIndex.setXY(68+s*2,34+s,34+t)}for(let s=0;s<32;s++){const t=(s+1)%32;this._attrIndex.setXY(136+s*2,68+s,68+t),this._attrIndex.setXY(200+s*2,100+s,100+t)}this._attrIndex.needsUpdate=!0}},Pu=class extends K{constructor(s){super(),this.worldScale=1,this._currentOffset=new g,this._currentNormal=new g,this._shape=s,this._attrPos=new V(new Float32Array(6*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new V(new Uint16Array(10),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let s=!1;this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),s=!0),this._currentNormal.equals(this._shape.normal)||(this._currentNormal.copy(this._shape.normal),s=!0),s&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,-.5,-.5,0),this._attrPos.setXYZ(1,.5,-.5,0),this._attrPos.setXYZ(2,.5,.5,0),this._attrPos.setXYZ(3,-.5,.5,0),this._attrPos.setXYZ(4,0,0,0),this._attrPos.setXYZ(5,0,0,.25),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this.lookAt(this._currentNormal),this._attrPos.needsUpdate=!0}_buildIndex(){this._attrIndex.setXY(0,0,1),this._attrIndex.setXY(2,1,2),this._attrIndex.setXY(4,2,3),this._attrIndex.setXY(6,3,0),this._attrIndex.setXY(8,4,5),this._attrIndex.needsUpdate=!0}},Iu=class extends K{constructor(s){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new g,this._shape=s,this._attrPos=new V(new Float32Array(32*3*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new V(new Uint16Array(64*3),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let s=!1;const t=this._shape.radius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,s=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),s=!0),s&&this._buildPosition()}_buildPosition(){for(let s=0;s<32;s++){const t=s/16*Math.PI;this._attrPos.setXYZ(s,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+s,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+s,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let s=0;s<32;s++){const t=(s+1)%32;this._attrIndex.setXY(s*2,s,t),this._attrIndex.setXY(64+s*2,32+s,32+t),this._attrIndex.setXY(128+s*2,64+s,64+t)}this._attrIndex.needsUpdate=!0}},Lu=new g,Rn=class extends _e{constructor(s){if(super(),this.matrixAutoUpdate=!1,this.collider=s,this.collider.shape instanceof Uo)this._geometry=new Iu(this.collider.shape);else if(this.collider.shape instanceof Oo)this._geometry=new Eu(this.collider.shape);else if(this.collider.shape instanceof Vo)this._geometry=new Pu(this.collider.shape);else throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");const t=new Me({color:16711935,depthTest:!1,depthWrite:!1});this._line=new Wi(this._geometry,t),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(s){this.collider.updateWorldMatrix(!0,!1),this.matrix.copy(this.collider.matrixWorld);const t=this.matrix.elements;this._geometry.worldScale=Lu.set(t[0],t[1],t[2]).length(),this._geometry.update(),super.updateMatrixWorld(s)}},Cu=class extends K{constructor(s){super(),this.worldScale=1,this._currentRadius=0,this._currentTail=new g,this._springBone=s,this._attrPos=new V(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new V(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let s=!1;const t=this._springBone.settings.hitRadius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,s=!0),this._currentTail.equals(this._springBone.initialLocalChildPosition)||(this._currentTail.copy(this._springBone.initialLocalChildPosition),s=!0),s&&this._buildPosition()}_buildPosition(){for(let s=0;s<32;s++){const t=s/16*Math.PI;this._attrPos.setXYZ(s,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+s,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+s,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let s=0;s<32;s++){const t=(s+1)%32;this._attrIndex.setXY(s*2,s,t),this._attrIndex.setXY(64+s*2,32+s,32+t),this._attrIndex.setXY(128+s*2,64+s,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}},Bu=new g,Fu=class extends _e{constructor(s){super(),this.matrixAutoUpdate=!1,this.springBone=s,this._geometry=new Cu(this.springBone);const t=new Me({color:16776960,depthTest:!1,depthWrite:!1});this._line=new Wi(this._geometry,t),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(s){this.springBone.bone.updateWorldMatrix(!0,!1),this.matrix.copy(this.springBone.bone.matrixWorld);const t=this.matrix.elements;this._geometry.worldScale=Bu.set(t[0],t[1],t[2]).length(),this._geometry.update(),super.updateMatrixWorld(s)}},En=class extends D{constructor(s){super(),this.colliderMatrix=new P,this.shape=s}updateWorldMatrix(s,t){super.updateWorldMatrix(s,t),zu(this.colliderMatrix,this.matrixWorld,this.shape.offset)}};function zu(s,t,e){const i=t.elements;s.copy(t),e&&(s.elements[12]=i[0]*e.x+i[4]*e.y+i[8]*e.z+i[12],s.elements[13]=i[1]*e.x+i[5]*e.y+i[9]*e.z+i[13],s.elements[14]=i[2]*e.x+i[6]*e.y+i[10]*e.z+i[14])}var Nu=new P;function Ou(s){return s.invert?s.invert():s.getInverse(Nu.copy(s)),s}var Vu=class{constructor(s){this._inverseCache=new P,this._shouldUpdateInverse=!0,this.matrix=s;const t={set:(e,i,n)=>(this._shouldUpdateInverse=!0,e[i]=n,!0)};this._originalElements=s.elements,s.elements=new Proxy(s.elements,t)}get inverse(){return this._shouldUpdateInverse&&(Ou(this._inverseCache.copy(this.matrix)),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}},Pn=new P,pe=new g,Ne=new g,Oe=new g,Ve=new g,Uu=new P,ku=class{constructor(s,t,e={},i=[]){this._currentTail=new g,this._prevTail=new g,this._boneAxis=new g,this._worldSpaceBoneLength=0,this._center=null,this._initialLocalMatrix=new P,this._initialLocalRotation=new I,this._initialLocalChildPosition=new g;var n,r,o,l,a,h;this.bone=s,this.bone.matrixAutoUpdate=!1,this.child=t,this.settings={hitRadius:(n=e.hitRadius)!=null?n:0,stiffness:(r=e.stiffness)!=null?r:1,gravityPower:(o=e.gravityPower)!=null?o:0,gravityDir:(a=(l=e.gravityDir)==null?void 0:l.clone())!=null?a:new g(0,-1,0),dragForce:(h=e.dragForce)!=null?h:.4},this.colliderGroups=i}get dependencies(){const s=new Set,t=this.bone.parent;t&&s.add(t);for(let e=0;e<this.colliderGroups.length;e++)for(let i=0;i<this.colliderGroups[e].colliders.length;i++)s.add(this.colliderGroups[e].colliders[i]);return s}get center(){return this._center}set center(s){var t;(t=this._center)!=null&&t.userData.inverseCacheProxy&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=s,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new Vu(this._center.matrixWorld)))}get initialLocalChildPosition(){return this._initialLocalChildPosition}get _parentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:Pn}setInitState(){this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),this.child?this._initialLocalChildPosition.copy(this.child.position):this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);const s=this._getMatrixWorldToCenter();this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(s),this._prevTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix);const s=this._getMatrixWorldToCenter();this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(s),this._prevTail.copy(this._currentTail)}update(s){if(s<=0)return;this._calcWorldSpaceBoneLength();const t=Ne.copy(this._boneAxis).transformDirection(this._initialLocalMatrix).transformDirection(this._parentMatrixWorld);Ve.copy(this._currentTail).add(pe.subVectors(this._currentTail,this._prevTail).multiplyScalar(1-this.settings.dragForce)).applyMatrix4(this._getMatrixCenterToWorld()).addScaledVector(t,this.settings.stiffness*s).addScaledVector(this.settings.gravityDir,this.settings.gravityPower*s),Oe.setFromMatrixPosition(this.bone.matrixWorld),Ve.sub(Oe).normalize().multiplyScalar(this._worldSpaceBoneLength).add(Oe),this._collision(Ve),this._prevTail.copy(this._currentTail),this._currentTail.copy(Ve).applyMatrix4(this._getMatrixWorldToCenter());const e=Uu.multiplyMatrices(this._parentMatrixWorld,this._initialLocalMatrix).invert();this.bone.quaternion.setFromUnitVectors(this._boneAxis,pe.copy(Ve).applyMatrix4(e).normalize()).premultiply(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix)}_collision(s){for(let t=0;t<this.colliderGroups.length;t++)for(let e=0;e<this.colliderGroups[t].colliders.length;e++){const i=this.colliderGroups[t].colliders[e],n=i.shape.calculateCollision(i.colliderMatrix,s,this.settings.hitRadius,pe);if(n<0){s.addScaledVector(pe,-n),s.sub(Oe);const r=s.length();s.multiplyScalar(this._worldSpaceBoneLength/r).add(Oe)}}}_calcWorldSpaceBoneLength(){pe.setFromMatrixPosition(this.bone.matrixWorld),this.child?Ne.setFromMatrixPosition(this.child.matrixWorld):(Ne.copy(this._initialLocalChildPosition),Ne.applyMatrix4(this.bone.matrixWorld)),this._worldSpaceBoneLength=pe.sub(Ne).length()}_getMatrixCenterToWorld(){return this._center?this._center.matrixWorld:Pn}_getMatrixWorldToCenter(){return this._center?this._center.userData.inverseCacheProxy.inverse:Pn}};function Du(s,t){const e=[];let i=s;for(;i!==null;)e.unshift(i),i=i.parent;e.forEach(n=>{t(n)})}function Wn(s,t){s.children.forEach(e=>{t(e)||Wn(e,t)})}function Wu(s){var t;const e=new Map;for(const i of s){let n=i;do{const r=((t=e.get(n))!=null?t:0)+1;if(r===s.size)return n;e.set(n,r),n=n.parent}while(n!==null)}return null}var to=class{constructor(){this._joints=new Set,this._sortedJoints=[],this._hasWarnedCircularDependency=!1,this._ancestors=[],this._objectSpringBonesMap=new Map,this._isSortedJointsDirty=!1,this._relevantChildrenUpdated=this._relevantChildrenUpdated.bind(this)}get joints(){return this._joints}get springBones(){return console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead."),this._joints}get colliderGroups(){const s=new Set;return this._joints.forEach(t=>{t.colliderGroups.forEach(e=>{s.add(e)})}),Array.from(s)}get colliders(){const s=new Set;return this.colliderGroups.forEach(t=>{t.colliders.forEach(e=>{s.add(e)})}),Array.from(s)}addJoint(s){this._joints.add(s);let t=this._objectSpringBonesMap.get(s.bone);t==null&&(t=new Set,this._objectSpringBonesMap.set(s.bone,t)),t.add(s),this._isSortedJointsDirty=!0}addSpringBone(s){console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead."),this.addJoint(s)}deleteJoint(s){this._joints.delete(s),this._objectSpringBonesMap.get(s.bone).delete(s),this._isSortedJointsDirty=!0}deleteSpringBone(s){console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead."),this.deleteJoint(s)}setInitState(){this._sortJoints();for(let s=0;s<this._sortedJoints.length;s++){const t=this._sortedJoints[s];t.bone.updateMatrix(),t.bone.updateWorldMatrix(!1,!1),t.setInitState()}}reset(){this._sortJoints();for(let s=0;s<this._sortedJoints.length;s++){const t=this._sortedJoints[s];t.bone.updateMatrix(),t.bone.updateWorldMatrix(!1,!1),t.reset()}}update(s){this._sortJoints();for(let t=0;t<this._ancestors.length;t++)this._ancestors[t].updateWorldMatrix(t===0,!1);for(let t=0;t<this._sortedJoints.length;t++){const e=this._sortedJoints[t];e.bone.updateMatrix(),e.bone.updateWorldMatrix(!1,!1),e.update(s),Wn(e.bone,this._relevantChildrenUpdated)}}_sortJoints(){if(!this._isSortedJointsDirty)return;const s=[],t=new Set,e=new Set,i=new Set;for(const r of this._joints)this._insertJointSort(r,t,e,s,i);this._sortedJoints=s;const n=Wu(i);this._ancestors=[],n&&(this._ancestors.push(n),Wn(n,r=>{var o,l;return((l=(o=this._objectSpringBonesMap.get(r))==null?void 0:o.size)!=null?l:0)>0?!0:(this._ancestors.push(r),!1)})),this._isSortedJointsDirty=!1}_insertJointSort(s,t,e,i,n){if(e.has(s))return;if(t.has(s)){this._hasWarnedCircularDependency||(console.warn("VRMSpringBoneManager: Circular dependency detected"),this._hasWarnedCircularDependency=!0);return}t.add(s);const r=s.dependencies;for(const o of r){let l=!1,a=null;Du(o,h=>{const u=this._objectSpringBonesMap.get(h);if(u)for(const c of u)l=!0,this._insertJointSort(c,t,e,i,n);else l||(a=h)}),a&&n.add(a)}i.push(s),e.add(s)}_relevantChildrenUpdated(s){var t,e;return((e=(t=this._objectSpringBonesMap.get(s))==null?void 0:t.size)!=null?e:0)>0?!0:(s.updateWorldMatrix(!1,!1),!1)}},eo="VRMC_springBone_extended_collider",Hu=new Set(["1.0","1.0-beta"]),ju=new Set(["1.0"]),ko=class me{get name(){return me.EXTENSION_NAME}constructor(t,e){var i;this.parser=t,this.jointHelperRoot=e?.jointHelperRoot,this.colliderHelperRoot=e?.colliderHelperRoot,this.useExtendedColliders=(i=e?.useExtendedColliders)!=null?i:!0}afterRoot(t){return Pi(this,null,function*(){t.userData.vrmSpringBoneManager=yield this._import(t)})}_import(t){return Pi(this,null,function*(){const e=yield this._v1Import(t);if(e!=null)return e;const i=yield this._v0Import(t);return i??null})}_v1Import(t){return Pi(this,null,function*(){var e,i,n,r,o;const l=t.parser.json;if(!(((e=l.extensionsUsed)==null?void 0:e.indexOf(me.EXTENSION_NAME))!==-1))return null;const h=new to,u=yield t.parser.getDependencies("node"),c=(i=l.extensions)==null?void 0:i[me.EXTENSION_NAME];if(!c)return null;const d=c.specVersion;if(!Hu.has(d))return console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${me.EXTENSION_NAME} specVersion "${d}"`),null;const p=(n=c.colliders)==null?void 0:n.map((m,y)=>{var x,w,M,_,v,S,b,T,E,A,R,L,z,G,$;const tt=u[m.node];if(tt==null)return console.warn(`VRMSpringBoneLoaderPlugin: The collider #${y} attempted to use the node #${m.node} but not found`),null;const J=m.shape,ot=(x=m.extensions)==null?void 0:x[eo];if(this.useExtendedColliders&&ot!=null){const ft=ot.specVersion;if(!ju.has(ft))console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${eo} specVersion "${ft}". Fallbacking to the ${me.EXTENSION_NAME} definition`);else{const H=ot.shape;if(H.sphere)return this._importSphereCollider(tt,{offset:new g().fromArray((w=H.sphere.offset)!=null?w:[0,0,0]),radius:(M=H.sphere.radius)!=null?M:0,inside:(_=H.sphere.inside)!=null?_:!1});if(H.capsule)return this._importCapsuleCollider(tt,{offset:new g().fromArray((v=H.capsule.offset)!=null?v:[0,0,0]),radius:(S=H.capsule.radius)!=null?S:0,tail:new g().fromArray((b=H.capsule.tail)!=null?b:[0,0,0]),inside:(T=H.capsule.inside)!=null?T:!1});if(H.plane)return this._importPlaneCollider(tt,{offset:new g().fromArray((E=H.plane.offset)!=null?E:[0,0,0]),normal:new g().fromArray((A=H.plane.normal)!=null?A:[0,0,1])})}}if(J.sphere)return this._importSphereCollider(tt,{offset:new g().fromArray((R=J.sphere.offset)!=null?R:[0,0,0]),radius:(L=J.sphere.radius)!=null?L:0,inside:!1});if(J.capsule)return this._importCapsuleCollider(tt,{offset:new g().fromArray((z=J.capsule.offset)!=null?z:[0,0,0]),radius:(G=J.capsule.radius)!=null?G:0,tail:new g().fromArray(($=J.capsule.tail)!=null?$:[0,0,0]),inside:!1});throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${y} has no valid shape`)}),f=(r=c.colliderGroups)==null?void 0:r.map((m,y)=>{var x;return{colliders:((x=m.colliders)!=null?x:[]).flatMap(M=>{const _=p?.[M];return _??(console.warn(`VRMSpringBoneLoaderPlugin: The colliderGroup #${y} attempted to use a collider #${M} but not found`),[])}),name:m.name}});return(o=c.springs)==null||o.forEach((m,y)=>{var x;const w=m.joints,M=(x=m.colliderGroups)==null?void 0:x.map(S=>{const b=f?.[S];if(b==null)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${y} attempted to use a colliderGroup ${S} but not found`);return b}),_=m.center!=null?u[m.center]:void 0;let v;w.forEach(S=>{if(v){const b=v.node,T=u[b],E=S.node,A=u[E],R={hitRadius:v.hitRadius,dragForce:v.dragForce,gravityPower:v.gravityPower,stiffness:v.stiffness,gravityDir:v.gravityDir!=null?new g().fromArray(v.gravityDir):void 0},L=this._importJoint(T,A,R,M);_&&(L.center=_),h.addJoint(L)}v=S})}),h.setInitState(),h})}_v0Import(t){return Pi(this,null,function*(){var e,i,n;const r=t.parser.json;if(!(((e=r.extensionsUsed)==null?void 0:e.indexOf("VRM"))!==-1))return null;const l=(i=r.extensions)==null?void 0:i.VRM,a=l?.secondaryAnimation;if(!a)return null;const h=a?.boneGroups;if(!h)return null;const u=new to,c=yield t.parser.getDependencies("node"),d=(n=a.colliderGroups)==null?void 0:n.map(p=>{var f;const m=c[p.node];return{colliders:((f=p.colliders)!=null?f:[]).map((x,w)=>{var M,_,v;const S=new g(0,0,0);return x.offset&&S.set((M=x.offset.x)!=null?M:0,(_=x.offset.y)!=null?_:0,x.offset.z?-x.offset.z:0),this._importSphereCollider(m,{offset:S,radius:(v=x.radius)!=null?v:0,inside:!1})})}});return h?.forEach((p,f)=>{const m=p.bones;m&&m.forEach(y=>{var x,w,M,_;const v=c[y],S=new g;p.gravityDir?S.set((x=p.gravityDir.x)!=null?x:0,(w=p.gravityDir.y)!=null?w:0,(M=p.gravityDir.z)!=null?M:0):S.set(0,-1,0);const b=p.center!=null?c[p.center]:void 0,T={hitRadius:p.hitRadius,dragForce:p.dragForce,gravityPower:p.gravityPower,stiffness:p.stiffiness,gravityDir:S},E=(_=p.colliderGroups)==null?void 0:_.map(A=>{const R=d?.[A];if(R==null)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${f} attempted to use a colliderGroup ${A} but not found`);return R});v.traverse(A=>{var R;const L=(R=A.children[0])!=null?R:null,z=this._importJoint(A,L,T,E);b&&(z.center=b),u.addJoint(z)})})}),t.scene.updateMatrixWorld(),u.setInitState(),u})}_importJoint(t,e,i,n){const r=new ku(t,e,i,n);if(this.jointHelperRoot){const o=new Fu(r);this.jointHelperRoot.add(o),o.renderOrder=this.jointHelperRoot.renderOrder}return r}_importSphereCollider(t,e){const i=new Uo(e),n=new En(i);if(t.add(n),this.colliderHelperRoot){const r=new Rn(n);this.colliderHelperRoot.add(r),r.renderOrder=this.colliderHelperRoot.renderOrder}return n}_importCapsuleCollider(t,e){const i=new Oo(e),n=new En(i);if(t.add(n),this.colliderHelperRoot){const r=new Rn(n);this.colliderHelperRoot.add(r),r.renderOrder=this.colliderHelperRoot.renderOrder}return n}_importPlaneCollider(t,e){const i=new Vo(e),n=new En(i);if(t.add(n),this.colliderHelperRoot){const r=new Rn(n);this.colliderHelperRoot.add(r),r.renderOrder=this.colliderHelperRoot.renderOrder}return n}};ko.EXTENSION_NAME="VRMC_springBone";var qu=ko,Xc=class{get name(){return"VRMLoaderPlugin"}constructor(s,t){var e,i,n,r,o,l,a,h,u,c;this.parser=s;const d=t?.helperRoot,p=t?.autoUpdateHumanBones;this.expressionPlugin=(e=t?.expressionPlugin)!=null?e:new lh(s),this.firstPersonPlugin=(i=t?.firstPersonPlugin)!=null?i:new uh(s),this.humanoidPlugin=(n=t?.humanoidPlugin)!=null?n:new yh(s,{helperRoot:d,autoUpdateHumanBones:p}),this.lookAtPlugin=(r=t?.lookAtPlugin)!=null?r:new Ch(s,{helperRoot:d}),this.metaPlugin=(o=t?.metaPlugin)!=null?o:new zh(s),this.mtoonMaterialPlugin=(l=t?.mtoonMaterialPlugin)!=null?l:new $h(s),this.materialsHDREmissiveMultiplierPlugin=(a=t?.materialsHDREmissiveMultiplierPlugin)!=null?a:new Qh(s),this.materialsV0CompatPlugin=(h=t?.materialsV0CompatPlugin)!=null?h:new ru(s),this.springBonePlugin=(u=t?.springBonePlugin)!=null?u:new qu(s,{colliderHelperRoot:d,jointHelperRoot:d}),this.nodeConstraintPlugin=(c=t?.nodeConstraintPlugin)!=null?c:new Au(s,{helperRoot:d})}beforeRoot(){return Ai(this,null,function*(){yield this.materialsV0CompatPlugin.beforeRoot(),yield this.mtoonMaterialPlugin.beforeRoot()})}loadMesh(s){return Ai(this,null,function*(){return yield this.mtoonMaterialPlugin.loadMesh(s)})}getMaterialType(s){const t=this.mtoonMaterialPlugin.getMaterialType(s);return t??null}extendMaterialParams(s,t){return Ai(this,null,function*(){yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(s,t),yield this.mtoonMaterialPlugin.extendMaterialParams(s,t)})}afterRoot(s){return Ai(this,null,function*(){yield this.metaPlugin.afterRoot(s),yield this.humanoidPlugin.afterRoot(s),yield this.expressionPlugin.afterRoot(s),yield this.lookAtPlugin.afterRoot(s),yield this.firstPersonPlugin.afterRoot(s),yield this.springBonePlugin.afterRoot(s),yield this.nodeConstraintPlugin.afterRoot(s),yield this.mtoonMaterialPlugin.afterRoot(s);const t=s.userData.vrmMeta,e=s.userData.vrmHumanoid;if(t&&e){const i=new Oh({scene:s.scene,expressionManager:s.userData.vrmExpressionManager,firstPerson:s.userData.vrmFirstPerson,humanoid:e,lookAt:s.userData.vrmLookAt,meta:t,materials:s.userData.vrmMToonMaterials,springBoneManager:s.userData.vrmSpringBoneManager,nodeConstraintManager:s.userData.vrmNodeConstraintManager});s.userData.vrm=i}})}};function Xu(s){const t=new Set;return s.traverse(e=>{if(!e.isMesh)return;const i=e;t.add(i)}),t}function io(s,t,e){if(t.size===1){const o=t.values().next().value;if(o.weight===1)return s[o.index]}const i=new Float32Array(s[0].count*3);let n=0;if(e)n=1;else for(const o of t)n+=o.weight;for(const o of t){const l=s[o.index],a=o.weight/n;for(let h=0;h<l.count;h++)i[h*3+0]+=l.getX(h)*a,i[h*3+1]+=l.getY(h)*a,i[h*3+2]+=l.getZ(h)*a}return new V(i,3)}function Gu(s){var t;const e=Xu(s.scene),i=new Map,n=(t=s.expressionManager)==null?void 0:t.expressionMap;if(n!=null)for(const[r,o]of Object.entries(n)){const l=new Set;for(const a of o.binds)if(a instanceof Oi){if(a.weight!==0)for(const h of a.primitives){let u=i.get(h);u==null&&(u=new Map,i.set(h,u));let c=u.get(r);c==null&&(c=new Set,u.set(r,c)),c.add(a)}l.add(a)}for(const a of l)o.deleteBind(a)}for(const r of e){const o=i.get(r);if(o==null)continue;const l=r.geometry.morphAttributes;r.geometry.morphAttributes={};const a=r.geometry.clone();r.geometry=a;const h=a.morphTargetsRelative,u=l.position!=null,c=l.normal!=null,d={},p={},f=[];if(u||c){u&&(d.position=[]),c&&(d.normal=[]);let m=0;for(const[y,x]of o)u&&(d.position[m]=io(l.position,x,h)),c&&(d.normal[m]=io(l.normal,x,h)),n?.[y].addBind(new Oi({index:m,weight:1,primitives:[r]})),p[y]=m,f.push(0),m++}a.morphAttributes=d,r.morphTargetDictionary=p,r.morphTargetInfluences=f}}function Ui(s,t,e){if(s.getComponent)return s.getComponent(t,e);{let i=s.array[t*s.itemSize+e];return s.normalized&&(i=W.denormalize(i,s.array)),i}}function Do(s,t,e,i){s.setComponent?s.setComponent(t,e,i):(s.normalized&&(i=W.normalize(i,s.array)),s.array[t*s.itemSize+e]=i)}function Yu(s){var t;const e=Zu(s),i=new Set;for(const c of e)i.has(c.geometry)&&(c.geometry=ec(c.geometry)),i.add(c.geometry);const n=new Map;for(const c of i){const d=c.getAttribute("skinIndex"),p=(t=n.get(d))!=null?t:new Map;n.set(d,p);const f=c.getAttribute("skinWeight"),m=$u(d,f);p.set(f,m)}const r=new Map;for(const c of e){const d=Ju(c,n);r.set(c,d)}const o=[];for(const[c,d]of r){let p=!1;for(const f of o)if(Qu(d,f.boneInverseMap)){p=!0,f.meshes.add(c);for(const[y,x]of d)f.boneInverseMap.set(y,x);break}p||o.push({boneInverseMap:d,meshes:new Set([c])})}const l=new Map,a=new In,h=new In,u=new In;for(const c of o){const{boneInverseMap:d,meshes:p}=c,f=Array.from(d.keys()),m=Array.from(d.values()),y=new Ye(f,m),x=h.getOrCreate(y);for(const w of p){const M=w.geometry.getAttribute("skinIndex"),_=a.getOrCreate(M),v=w.skeleton.bones,S=v.map(E=>u.getOrCreate(E)).join(","),b=`${_};${x};${S}`;let T=l.get(b);T==null&&(T=M.clone(),Ku(T,v,f),l.set(b,T)),w.geometry.setAttribute("skinIndex",T)}for(const w of p)w.bind(y,new P)}}function Zu(s){const t=new Set;return s.traverse(e=>{if(!e.isSkinnedMesh)return;const i=e;t.add(i)}),t}function $u(s,t){const e=new Set;for(let i=0;i<s.count;i++)for(let n=0;n<s.itemSize;n++){const r=Ui(s,i,n);Ui(t,i,n)!==0&&e.add(r)}return e}function Ju(s,t){const e=new Map,i=s.skeleton,n=s.geometry,r=n.getAttribute("skinIndex"),o=n.getAttribute("skinWeight"),l=t.get(r),a=l?.get(o);if(!a)throw new Error("Unreachable. attributeUsedIndexSetMap does not know the skin index attribute or the skin weight attribute.");for(const h of a)e.set(i.bones[h],i.boneInverses[h]);return e}function Qu(s,t){for(const[e,i]of s.entries()){const n=t.get(e);if(n!=null&&!tc(i,n))return!1}return!0}function Ku(s,t,e){const i=new Map;for(const r of t)i.set(r,i.size);const n=new Map;for(const[r,o]of e.entries()){const l=i.get(o);n.set(l,r)}for(let r=0;r<s.count;r++)for(let o=0;o<s.itemSize;o++){const l=Ui(s,r,o),a=n.get(l);Do(s,r,o,a)}s.needsUpdate=!0}function tc(s,t,e){if(e=e||1e-4,s.elements.length!=t.elements.length)return!1;for(let i=0,n=s.elements.length;i<n;i++)if(Math.abs(s.elements[i]-t.elements[i])>e)return!1;return!0}var In=class{constructor(){this._objectIndexMap=new Map,this._index=0}get(s){return this._objectIndexMap.get(s)}getOrCreate(s){let t=this._objectIndexMap.get(s);return t==null&&(t=this._index,this._objectIndexMap.set(s,t),this._index++),t}};function ec(s){var t,e,i,n;const r=new K;r.name=s.name,r.setIndex(s.index);for(const[o,l]of Object.entries(s.attributes))r.setAttribute(o,l);for(const[o,l]of Object.entries(s.morphAttributes)){const a=o;r.morphAttributes[a]=l.concat()}r.morphTargetsRelative=s.morphTargetsRelative,r.groups=[];for(const o of s.groups)r.addGroup(o.start,o.count,o.materialIndex);return r.boundingSphere=(e=(t=s.boundingSphere)==null?void 0:t.clone())!=null?e:null,r.boundingBox=(n=(i=s.boundingBox)==null?void 0:i.clone())!=null?n:null,r.drawRange.start=s.drawRange.start,r.drawRange.count=s.drawRange.count,r.userData=s.userData,r}function no(s){if(Object.values(s).forEach(t=>{t?.isTexture&&t.dispose()}),s.isShaderMaterial){const t=s.uniforms;t&&Object.values(t).forEach(e=>{const i=e.value;i?.isTexture&&i.dispose()})}s.dispose()}function ic(s){const t=s.geometry;t&&t.dispose();const e=s.skeleton;e&&e.dispose();const i=s.material;i&&(Array.isArray(i)?i.forEach(n=>no(n)):i&&no(i))}function nc(s){s.traverse(ic)}function sc(s,t){var e,i;console.warn("VRMUtils.removeUnnecessaryJoints: removeUnnecessaryJoints is deprecated. Use combineSkeletons instead. combineSkeletons contributes more to the performance improvement. This function will be removed in the next major version.");const n=(e=t?.experimentalSameBoneCounts)!=null?e:!1,r=[];s.traverse(a=>{a.type==="SkinnedMesh"&&r.push(a)});const o=new Map;let l=0;for(const a of r){const u=a.geometry.getAttribute("skinIndex");if(o.has(u))continue;const c=new Map,d=new Map;for(let p=0;p<u.count;p++)for(let f=0;f<u.itemSize;f++){const m=Ui(u,p,f);let y=c.get(m);y==null&&(y=c.size,c.set(m,y),d.set(y,m)),Do(u,p,f,y)}u.needsUpdate=!0,o.set(u,d),l=Math.max(l,c.size)}for(const a of r){const u=a.geometry.getAttribute("skinIndex"),c=o.get(u),d=[],p=[],f=n?l:c.size;for(let y=0;y<f;y++){const x=(i=c.get(y))!=null?i:0;d.push(a.skeleton.bones[x]),p.push(a.skeleton.boneInverses[x])}const m=new Ye(d,p);a.bind(m,new P)}}function rc(s){const t=new Map;s.traverse(e=>{var i,n,r,o;if(!e.isMesh)return;const l=e,a=l.geometry,h=a.index;if(h==null)return;const u=t.get(a);if(u!=null){l.geometry=u;return}const c=Object.values(a.attributes)[0].count,d=new Array(c);let p=0;const f=h.array;for(let _=0;_<f.length;_++){const v=f[_];d[v]||(d[v]=!0,p++)}if(p===c)return;const m=[],y=[];let x=0;for(let _=0;_<d.length;_++)if(d[_]){const v=x++;m[_]=v,y[v]=_}const w=new K;w.name=a.name,w.morphTargetsRelative=a.morphTargetsRelative,a.groups.forEach(_=>{w.addGroup(_.start,_.count,_.materialIndex)}),w.boundingBox=(n=(i=a.boundingBox)==null?void 0:i.clone())!=null?n:null,w.boundingSphere=(o=(r=a.boundingSphere)==null?void 0:r.clone())!=null?o:null,w.setDrawRange(a.drawRange.start,a.drawRange.count),w.userData=a.userData,t.set(a,w);{const _=h.array,v=new _.constructor(_.length);for(let S=0;S<_.length;S++){const b=_[S],T=m[b];v[S]=T}w.setIndex(new V(v,1,!1))}Object.keys(a.attributes).forEach(_=>{const v=a.attributes[_];if(v.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const S=v.array,{itemSize:b,normalized:T}=v,E=new S.constructor(y.length*b);y.forEach((A,R)=>{for(let L=0;L<b;L++)E[R*b+L]=S[A*b+L]}),w.setAttribute(_,new V(E,b,T))});let M=!0;for(const[_,v]of Object.entries(a.morphAttributes)){const S=_;w.morphAttributes[S]=[];for(let b=0;b<v.length;b++){const T=v[b];if(T.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const E=T.array,{itemSize:A,normalized:R}=T,L=new E.constructor(y.length*A);y.forEach((z,G)=>{for(let $=0;$<A;$++)L[G*A+$]=E[z*A+$]}),M=M&&L.every(z=>z===0),w.morphAttributes[S][b]=new V(L,A,R)}}M&&(w.morphAttributes={}),l.geometry=w}),Array.from(t.keys()).forEach(e=>{e.dispose()})}function oc(s){var t;((t=s.meta)==null?void 0:t.metaVersion)==="0"&&(s.scene.rotation.y=Math.PI)}var be=class{constructor(){}};be.combineMorphs=Gu;be.combineSkeletons=Yu;be.deepDispose=nc;be.removeUnnecessaryJoints=sc;be.removeUnnecessaryVertices=rc;be.rotateVRM0=oc;/*!
 * @pixiv/three-vrm-core v3.4.1
 * The implementation of core features of VRM, for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-core is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-mtoon v3.4.1
 * MToon (toon material) module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier v3.4.1
 * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-v0compat v3.4.1
 * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-node-constraint v3.4.1
 * Node constraint module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-node-constraint is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-springbone v3.4.1
 * Spring bone module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-springbone is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */export{pl as $,dl as A,V as B,B as C,Wc as D,je as E,Vc as F,Wi as G,Xn as H,Ic as I,Lc as J,Cc as K,Ze as L,Fc as M,_c as N,D as O,Dc as P,I as Q,fc as R,zt as S,Tc as T,_e as U,F as V,ho as W,W as X,ul as Y,Ye as Z,Oc as _,Rc as a,bc as a0,Sc as a1,uo as a2,At as a3,Ni as a4,zi as a5,qi as a6,at as a7,uc as a8,ji as a9,Ot as aa,Rt as ab,cc as ac,ol as ad,Ec as ae,nl as af,Pe as ag,U as ah,xe as ai,Xc as aj,rt as ak,Bc as al,zc as am,Nc as an,pc as ao,Hc as ap,He as aq,Ja as ar,go as as,pt as at,wr as au,be as av,Ac as b,jc as c,Hn as d,kc as e,g as f,P as g,rr as h,Uc as i,qc as j,Pc as k,wc as l,vc as m,xc as n,Mc as o,yc as p,gc as q,mc as r,gl as s,Vt as t,Me as u,Fl as v,dc as w,Bn as x,O as y,K as z};
