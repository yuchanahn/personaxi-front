import"./BXQQiVcS.js";import"./knpjl46v.js";import"./Bit4kGOU.js";import"./gt9WcTCj.js";/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Ni="167",sd=0,yp=1,$f=2,qf=1,jf=100,Xf=204,Yf=205,Zf=3,xp=0,Qf="attached",eb="detached",Ux=300,TU=303,Jf=1e3,Ea=1001,Kf=1002,tm=1003,bU=1004,SU=1005,ib=1006,wU=1007,sb=1008,nb=1009,_p=1015,Dx=1023,rb=1028,sh=2300,nd=2301,du=2302,em=2400,im=2401,sm=2402,ob=2500,AU=0,NU=1,RU=2,ca=0,Ox="",Fs="srgb",Mp="srgb-linear",ab="display-p3",zx="display-p3-linear",rd="linear",nm="srgb",rm="rec709",om="p3",Ln=7680,am=519,od=35044,lb=35048,fn=2e3,ad=2001;let Dh=class{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const s=this._listeners[t];if(s!==void 0){const n=s.indexOf(e);n!==-1&&s.splice(n,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const i=this._listeners[t.type];if(i!==void 0){t.target=this;const s=i.slice(0);for(let n=0,r=s.length;n<r;n++)s[n].call(this,t);t.target=null}}};const me=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let lm=1234567;const Wo=Math.PI/180,Jo=180/Math.PI;function Si(){const o=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(me[o&255]+me[o>>8&255]+me[o>>16&255]+me[o>>24&255]+"-"+me[t&255]+me[t>>8&255]+"-"+me[t>>16&15|64]+me[t>>24&255]+"-"+me[e&63|128]+me[e>>8&255]+"-"+me[e>>16&255]+me[e>>24&255]+me[i&255]+me[i>>8&255]+me[i>>16&255]+me[i>>24&255]).toLowerCase()}function Jt(o,t,e){return Math.max(t,Math.min(e,o))}function vp(o,t){return(o%t+t)%t}function hb(o,t,e,i,s){return i+(o-t)*(s-i)/(e-t)}function ub(o,t,e){return o!==t?(e-o)/(t-o):0}function Ho(o,t,e){return(1-e)*o+e*t}function cb(o,t,e,i){return Ho(o,t,1-Math.exp(-e*i))}function db(o,t=1){return t-Math.abs(vp(o,t*2)-t)}function pb(o,t,e){return o<=t?0:o>=e?1:(o=(o-t)/(e-t),o*o*(3-2*o))}function fb(o,t,e){return o<=t?0:o>=e?1:(o=(o-t)/(e-t),o*o*o*(o*(o*6-15)+10))}function mb(o,t){return o+Math.floor(Math.random()*(t-o+1))}function gb(o,t){return o+Math.random()*(t-o)}function yb(o){return o*(.5-Math.random())}function xb(o){o!==void 0&&(lm=o);let t=lm+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function _b(o){return o*Wo}function Mb(o){return o*Jo}function vb(o){return(o&o-1)===0&&o!==0}function Tb(o){return Math.pow(2,Math.ceil(Math.log(o)/Math.LN2))}function bb(o){return Math.pow(2,Math.floor(Math.log(o)/Math.LN2))}function Sb(o,t,e,i,s){const n=Math.cos,r=Math.sin,a=n(e/2),l=r(e/2),h=n((t+i)/2),u=r((t+i)/2),c=n((t-i)/2),d=r((t-i)/2),p=n((i-t)/2),f=r((i-t)/2);switch(s){case"XYX":o.set(a*u,l*c,l*d,a*h);break;case"YZY":o.set(l*d,a*u,l*c,a*h);break;case"ZXZ":o.set(l*c,l*d,a*u,a*h);break;case"XZX":o.set(a*u,l*f,l*p,a*h);break;case"YXY":o.set(l*p,a*u,l*f,a*h);break;case"ZYZ":o.set(l*f,l*p,a*u,a*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}function Ti(o,t){switch(t.constructor){case Float32Array:return o;case Uint32Array:return o/4294967295;case Uint16Array:return o/65535;case Uint8Array:return o/255;case Int32Array:return Math.max(o/2147483647,-1);case Int16Array:return Math.max(o/32767,-1);case Int8Array:return Math.max(o/127,-1);default:throw new Error("Invalid component type.")}}function Mt(o,t){switch(t.constructor){case Float32Array:return o;case Uint32Array:return Math.round(o*4294967295);case Uint16Array:return Math.round(o*65535);case Uint8Array:return Math.round(o*255);case Int32Array:return Math.round(o*2147483647);case Int16Array:return Math.round(o*32767);case Int8Array:return Math.round(o*127);default:throw new Error("Invalid component type.")}}const zt={DEG2RAD:Wo,RAD2DEG:Jo,generateUUID:Si,clamp:Jt,euclideanModulo:vp,mapLinear:hb,inverseLerp:ub,lerp:Ho,damp:cb,pingpong:db,smoothstep:pb,smootherstep:fb,randInt:mb,randFloat:gb,randFloatSpread:yb,seededRandom:xb,degToRad:_b,radToDeg:Mb,isPowerOfTwo:vb,ceilPowerOfTwo:Tb,floorPowerOfTwo:bb,setQuaternionFromProperEuler:Sb,normalize:Mt,denormalize:Ti};let wt=class Vx{constructor(t=0,e=0){Vx.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Jt(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*s+t.x,this.y=n*s+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}},yt=class kx{constructor(t,e,i,s,n,r,a,l,h){kx.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,i,s,n,r,a,l,h)}set(t,e,i,s,n,r,a,l,h){const u=this.elements;return u[0]=t,u[1]=s,u[2]=a,u[3]=e,u[4]=n,u[5]=l,u[6]=i,u[7]=r,u[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[3],l=i[6],h=i[1],u=i[4],c=i[7],d=i[2],p=i[5],f=i[8],m=s[0],g=s[3],y=s[6],x=s[1],M=s[4],_=s[7],v=s[2],A=s[5],T=s[8];return n[0]=r*m+a*x+l*v,n[3]=r*g+a*M+l*A,n[6]=r*y+a*_+l*T,n[1]=h*m+u*x+c*v,n[4]=h*g+u*M+c*A,n[7]=h*y+u*_+c*T,n[2]=d*m+p*x+f*v,n[5]=d*g+p*M+f*A,n[8]=d*y+p*_+f*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],l=t[6],h=t[7],u=t[8];return e*r*u-e*a*h-i*n*u+i*a*l+s*n*h-s*r*l}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],l=t[6],h=t[7],u=t[8],c=u*r-a*h,d=a*l-u*n,p=h*n-r*l,f=e*c+i*d+s*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=c*m,t[1]=(s*h-u*i)*m,t[2]=(a*i-s*r)*m,t[3]=d*m,t[4]=(u*e-s*l)*m,t[5]=(s*n-a*e)*m,t[6]=p*m,t[7]=(i*l-h*e)*m,t[8]=(r*e-i*n)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,n,r,a){const l=Math.cos(n),h=Math.sin(n);return this.set(i*l,i*h,-i*(l*r+h*a)+r+t,-s*h,s*l,-s*(-h*r+l*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(pu.makeScale(t,e)),this}rotate(t){return this.premultiply(pu.makeRotation(-t)),this}translate(t,e){return this.premultiply(pu.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}};const pu=new yt;function wb(o){for(let t=o.length-1;t>=0;--t)if(o[t]>=65535)return!0;return!1}function ld(o){return document.createElementNS("http://www.w3.org/1999/xhtml",o)}const hm={};function Gx(o){o in hm||(hm[o]=!0,console.warn(o))}const um=new yt().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),cm=new yt().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),co={[Mp]:{transfer:rd,primaries:rm,luminanceCoefficients:[.2126,.7152,.0722],toReference:o=>o,fromReference:o=>o},[Fs]:{transfer:nm,primaries:rm,luminanceCoefficients:[.2126,.7152,.0722],toReference:o=>o.convertSRGBToLinear(),fromReference:o=>o.convertLinearToSRGB()},[zx]:{transfer:rd,primaries:om,luminanceCoefficients:[.2289,.6917,.0793],toReference:o=>o.applyMatrix3(cm),fromReference:o=>o.applyMatrix3(um)},[ab]:{transfer:nm,primaries:om,luminanceCoefficients:[.2289,.6917,.0793],toReference:o=>o.convertSRGBToLinear().applyMatrix3(cm),fromReference:o=>o.applyMatrix3(um).convertLinearToSRGB()}},Ab=new Set([Mp,zx]),di={enabled:!0,_workingColorSpace:Mp,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(o){if(!Ab.has(o))throw new Error(`Unsupported working color space, "${o}".`);this._workingColorSpace=o},convert:function(o,t,e){if(this.enabled===!1||t===e||!t||!e)return o;const i=co[t].toReference,s=co[e].fromReference;return s(i(o))},fromWorkingColorSpace:function(o,t){return this.convert(o,this._workingColorSpace,t)},toWorkingColorSpace:function(o,t){return this.convert(o,t,this._workingColorSpace)},getPrimaries:function(o){return co[o].primaries},getTransfer:function(o){return o===Ox?rd:co[o].transfer},getLuminanceCoefficients:function(o,t=this._workingColorSpace){return o.fromArray(co[t].luminanceCoefficients)}};function Br(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function fu(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}let Un,Nb=class{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Un===void 0&&(Un=ld("canvas")),Un.width=t.width,Un.height=t.height;const i=Un.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=Un}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=ld("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const s=i.getImageData(0,0,t.width,t.height),n=s.data;for(let r=0;r<n.length;r++)n[r]=Br(n[r]/255)*255;return i.putImageData(s,0,0),e}else if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(Br(e[i]/255)*255):e[i]=Br(e[i]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}},Rb=0,Eb=class{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Rb++}),this.uuid=Si(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let n;if(Array.isArray(s)){n=[];for(let r=0,a=s.length;r<a;r++)s[r].isDataTexture?n.push(mu(s[r].image)):n.push(mu(s[r]))}else n=mu(s);i.url=n}return e||(t.images[this.uuid]=i),i}};function mu(o){return typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&o instanceof ImageBitmap?Nb.getDataURL(o):o.data?{data:Array.from(o.data),width:o.width,height:o.height,type:o.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Cb=0,da=class Gl extends Dh{constructor(t=Gl.DEFAULT_IMAGE,e=Gl.DEFAULT_MAPPING,i=Ea,s=Ea,n=ib,r=sb,a=Dx,l=nb,h=Gl.DEFAULT_ANISOTROPY,u=Ox){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Cb++}),this.uuid=Si(),this.name="",this.source=new Eb(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=i,this.wrapT=s,this.magFilter=n,this.minFilter=r,this.anisotropy=h,this.format=a,this.internalFormat=null,this.type=l,this.offset=new wt(0,0),this.repeat=new wt(1,1),this.center=new wt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new yt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Ux)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Jf:t.x=t.x-Math.floor(t.x);break;case Ea:t.x=t.x<0?0:1;break;case Kf:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Jf:t.y=t.y-Math.floor(t.y);break;case Ea:t.y=t.y<0?0:1;break;case Kf:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}};da.DEFAULT_IMAGE=null;da.DEFAULT_MAPPING=Ux;da.DEFAULT_ANISOTROPY=1;let Fi=class Wx{constructor(t=0,e=0,i=0,s=1){Wx.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s+r[12]*n,this.y=r[1]*e+r[5]*i+r[9]*s+r[13]*n,this.z=r[2]*e+r[6]*i+r[10]*s+r[14]*n,this.w=r[3]*e+r[7]*i+r[11]*s+r[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,n;const l=t.elements,h=l[0],u=l[4],c=l[8],d=l[1],p=l[5],f=l[9],m=l[2],g=l[6],y=l[10];if(Math.abs(u-d)<.01&&Math.abs(c-m)<.01&&Math.abs(f-g)<.01){if(Math.abs(u+d)<.1&&Math.abs(c+m)<.1&&Math.abs(f+g)<.1&&Math.abs(h+p+y-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const M=(h+1)/2,_=(p+1)/2,v=(y+1)/2,A=(u+d)/4,T=(c+m)/4,w=(f+g)/4;return M>_&&M>v?M<.01?(i=0,s=.707106781,n=.707106781):(i=Math.sqrt(M),s=A/i,n=T/i):_>v?_<.01?(i=.707106781,s=0,n=.707106781):(s=Math.sqrt(_),i=A/s,n=w/s):v<.01?(i=.707106781,s=.707106781,n=0):(n=Math.sqrt(v),i=T/n,s=w/n),this.set(i,s,n,e),this}let x=Math.sqrt((g-f)*(g-f)+(c-m)*(c-m)+(d-u)*(d-u));return Math.abs(x)<.001&&(x=1),this.x=(g-f)/x,this.y=(c-m)/x,this.z=(d-u)/x,this.w=Math.acos((h+p+y-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}},rt=class{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=s}static slerpFlat(t,e,i,s,n,r,a){let l=i[s+0],h=i[s+1],u=i[s+2],c=i[s+3];const d=n[r+0],p=n[r+1],f=n[r+2],m=n[r+3];if(a===0){t[e+0]=l,t[e+1]=h,t[e+2]=u,t[e+3]=c;return}if(a===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(c!==m||l!==d||h!==p||u!==f){let g=1-a;const y=l*d+h*p+u*f+c*m,x=y>=0?1:-1,M=1-y*y;if(M>Number.EPSILON){const v=Math.sqrt(M),A=Math.atan2(v,y*x);g=Math.sin(g*A)/v,a=Math.sin(a*A)/v}const _=a*x;if(l=l*g+d*_,h=h*g+p*_,u=u*g+f*_,c=c*g+m*_,g===1-a){const v=1/Math.sqrt(l*l+h*h+u*u+c*c);l*=v,h*=v,u*=v,c*=v}}t[e]=l,t[e+1]=h,t[e+2]=u,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,s,n,r){const a=i[s],l=i[s+1],h=i[s+2],u=i[s+3],c=n[r],d=n[r+1],p=n[r+2],f=n[r+3];return t[e]=a*f+u*c+l*p-h*d,t[e+1]=l*f+u*d+h*c-a*p,t[e+2]=h*f+u*p+a*d-l*c,t[e+3]=u*f-a*c-l*d-h*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,s=t._y,n=t._z,r=t._order,a=Math.cos,l=Math.sin,h=a(i/2),u=a(s/2),c=a(n/2),d=l(i/2),p=l(s/2),f=l(n/2);switch(r){case"XYZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"YXZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"ZXY":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"ZYX":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"YZX":this._x=d*u*c+h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c-d*p*f;break;case"XZY":this._x=d*u*c-h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],a=e[5],l=e[9],h=e[2],u=e[6],c=e[10],d=i+a+c;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(n-h)*p,this._z=(r-s)*p}else if(i>a&&i>c){const p=2*Math.sqrt(1+i-a-c);this._w=(u-l)/p,this._x=.25*p,this._y=(s+r)/p,this._z=(n+h)/p}else if(a>c){const p=2*Math.sqrt(1+a-i-c);this._w=(n-h)/p,this._x=(s+r)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+c-i-a);this._w=(r-s)/p,this._x=(n+h)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Jt(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,a=e._x,l=e._y,h=e._z,u=e._w;return this._x=i*u+r*a+s*h-n*l,this._y=s*u+r*l+n*a-i*h,this._z=n*u+r*h+i*l-s*a,this._w=r*u-i*a-s*l-n*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,s=this._y,n=this._z,r=this._w;let a=r*t._w+i*t._x+s*t._y+n*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=s,this._z=n,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-e;return this._w=p*r+e*this._w,this._x=p*i+e*this._x,this._y=p*s+e*this._y,this._z=p*n+e*this._z,this.normalize(),this}const h=Math.sqrt(l),u=Math.atan2(h,a),c=Math.sin((1-e)*u)/h,d=Math.sin(e*u)/h;return this._w=r*c+this._w*d,this._x=i*c+this._x*d,this._y=s*c+this._y*d,this._z=n*c+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),s=Math.sqrt(1-i),n=Math.sqrt(i);return this.set(s*Math.sin(t),s*Math.cos(t),n*Math.sin(e),n*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}},S=class Hx{constructor(t=0,e=0,i=0){Hx.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(dm.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(dm.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*s,this.y=n[1]*e+n[4]*i+n[7]*s,this.z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this.y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this.z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,n=t.x,r=t.y,a=t.z,l=t.w,h=2*(r*s-a*i),u=2*(a*e-n*s),c=2*(n*i-r*e);return this.x=e+l*h+r*c-a*u,this.y=i+l*u+a*h-n*c,this.z=s+l*c+n*u-r*h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*s,this.y=n[1]*e+n[5]*i+n[9]*s,this.z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,a=e.y,l=e.z;return this.x=s*l-n*a,this.y=n*r-i*l,this.z=i*a-s*r,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return gu.copy(this).projectOnVector(t),this.sub(gu)}reflect(t){return this.sub(gu.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Jt(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}};const gu=new S,dm=new rt;let Ws=class{constructor(t=new S(1/0,1/0,1/0),e=new S(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(pi.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(pi.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=pi.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0){const n=i.getAttribute("position");if(e===!0&&n!==void 0&&t.isInstancedMesh!==!0)for(let r=0,a=n.count;r<a;r++)t.isMesh===!0?t.getVertexPosition(r,pi):pi.fromBufferAttribute(n,r),pi.applyMatrix4(t.matrixWorld),this.expandByPoint(pi);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),Ca.copy(t.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),Ca.copy(i.boundingBox)),Ca.applyMatrix4(t.matrixWorld),this.union(Ca)}const s=t.children;for(let n=0,r=s.length;n<r;n++)this.expandByObject(s[n],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,pi),pi.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(po),Pa.subVectors(this.max,po),Dn.subVectors(t.a,po),On.subVectors(t.b,po),zn.subVectors(t.c,po),xs.subVectors(On,Dn),_s.subVectors(zn,On),Xs.subVectors(Dn,zn);let e=[0,-xs.z,xs.y,0,-_s.z,_s.y,0,-Xs.z,Xs.y,xs.z,0,-xs.x,_s.z,0,-_s.x,Xs.z,0,-Xs.x,-xs.y,xs.x,0,-_s.y,_s.x,0,-Xs.y,Xs.x,0];return!yu(e,Dn,On,zn,Pa)||(e=[1,0,0,0,1,0,0,0,1],!yu(e,Dn,On,zn,Pa))?!1:(Fa.crossVectors(xs,_s),e=[Fa.x,Fa.y,Fa.z],yu(e,Dn,On,zn,Pa))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,pi).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(pi).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Hi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Hi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Hi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Hi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Hi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Hi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Hi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Hi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Hi),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}};const Hi=[new S,new S,new S,new S,new S,new S,new S,new S],pi=new S,Ca=new Ws,Dn=new S,On=new S,zn=new S,xs=new S,_s=new S,Xs=new S,po=new S,Pa=new S,Fa=new S,Ys=new S;function yu(o,t,e,i,s){for(let n=0,r=o.length-3;n<=r;n+=3){Ys.fromArray(o,n);const a=s.x*Math.abs(Ys.x)+s.y*Math.abs(Ys.y)+s.z*Math.abs(Ys.z),l=t.dot(Ys),h=e.dot(Ys),u=i.dot(Ys);if(Math.max(-Math.max(l,h,u),Math.min(l,h,u))>a)return!1}return!0}const Pb=new Ws,fo=new S,xu=new S;let ds=class{constructor(t=new S,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):Pb.setFromPoints(t).getCenter(i);let s=0;for(let n=0,r=t.length;n<r;n++)s=Math.max(s,i.distanceToSquared(t[n]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;fo.subVectors(t,this.center);const e=fo.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),s=(i-this.radius)*.5;this.center.addScaledVector(fo,s/i),this.radius+=s}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(xu.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(fo.copy(t.center).add(xu)),this.expandByPoint(fo.copy(t.center).sub(xu))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}};const $i=new S,_u=new S,Ia=new S,Ms=new S,Mu=new S,Ba=new S,vu=new S;let Oh=class{constructor(t=new S,e=new S(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,$i)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=$i.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):($i.copy(this.origin).addScaledVector(this.direction,e),$i.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){_u.copy(t).add(e).multiplyScalar(.5),Ia.copy(e).sub(t).normalize(),Ms.copy(this.origin).sub(_u);const n=t.distanceTo(e)*.5,r=-this.direction.dot(Ia),a=Ms.dot(this.direction),l=-Ms.dot(Ia),h=Ms.lengthSq(),u=Math.abs(1-r*r);let c,d,p,f;if(u>0)if(c=r*l-a,d=r*a-l,f=n*u,c>=0)if(d>=-f)if(d<=f){const m=1/u;c*=m,d*=m,p=c*(c+r*d+2*a)+d*(r*c+d+2*l)+h}else d=n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*l)+h;else d=-n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*l)+h;else d<=-f?(c=Math.max(0,-(-r*n+a)),d=c>0?-n:Math.min(Math.max(-n,-l),n),p=-c*c+d*(d+2*l)+h):d<=f?(c=0,d=Math.min(Math.max(-n,-l),n),p=d*(d+2*l)+h):(c=Math.max(0,-(r*n+a)),d=c>0?n:Math.min(Math.max(-n,-l),n),p=-c*c+d*(d+2*l)+h);else d=r>0?-n:n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*l)+h;return i&&i.copy(this.origin).addScaledVector(this.direction,c),s&&s.copy(_u).addScaledVector(Ia,d),p}intersectSphere(t,e){$i.subVectors(t.center,this.origin);const i=$i.dot(this.direction),s=$i.dot($i)-i*i,n=t.radius*t.radius;if(s>n)return null;const r=Math.sqrt(n-s),a=i-r,l=i+r;return l<0?null:a<0?this.at(l,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,n,r,a,l;const h=1/this.direction.x,u=1/this.direction.y,c=1/this.direction.z,d=this.origin;return h>=0?(i=(t.min.x-d.x)*h,s=(t.max.x-d.x)*h):(i=(t.max.x-d.x)*h,s=(t.min.x-d.x)*h),u>=0?(n=(t.min.y-d.y)*u,r=(t.max.y-d.y)*u):(n=(t.max.y-d.y)*u,r=(t.min.y-d.y)*u),i>r||n>s||((n>i||isNaN(i))&&(i=n),(r<s||isNaN(s))&&(s=r),c>=0?(a=(t.min.z-d.z)*c,l=(t.max.z-d.z)*c):(a=(t.max.z-d.z)*c,l=(t.min.z-d.z)*c),i>l||a>s)||((a>i||i!==i)&&(i=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(i>=0?i:s,e)}intersectsBox(t){return this.intersectBox(t,$i)!==null}intersectTriangle(t,e,i,s,n){Mu.subVectors(e,t),Ba.subVectors(i,t),vu.crossVectors(Mu,Ba);let r=this.direction.dot(vu),a;if(r>0){if(s)return null;a=1}else if(r<0)a=-1,r=-r;else return null;Ms.subVectors(this.origin,t);const l=a*this.direction.dot(Ba.crossVectors(Ms,Ba));if(l<0)return null;const h=a*this.direction.dot(Mu.cross(Ms));if(h<0||l+h>r)return null;const u=-a*Ms.dot(vu);return u<0?null:this.at(u/r,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}},ht=class hd{constructor(t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g){hd.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g)}set(t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g){const y=this.elements;return y[0]=t,y[4]=e,y[8]=i,y[12]=s,y[1]=n,y[5]=r,y[9]=a,y[13]=l,y[2]=h,y[6]=u,y[10]=c,y[14]=d,y[3]=p,y[7]=f,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new hd().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/Vn.setFromMatrixColumn(t,0).length(),n=1/Vn.setFromMatrixColumn(t,1).length(),r=1/Vn.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,s=t.y,n=t.z,r=Math.cos(i),a=Math.sin(i),l=Math.cos(s),h=Math.sin(s),u=Math.cos(n),c=Math.sin(n);if(t.order==="XYZ"){const d=r*u,p=r*c,f=a*u,m=a*c;e[0]=l*u,e[4]=-l*c,e[8]=h,e[1]=p+f*h,e[5]=d-m*h,e[9]=-a*l,e[2]=m-d*h,e[6]=f+p*h,e[10]=r*l}else if(t.order==="YXZ"){const d=l*u,p=l*c,f=h*u,m=h*c;e[0]=d+m*a,e[4]=f*a-p,e[8]=r*h,e[1]=r*c,e[5]=r*u,e[9]=-a,e[2]=p*a-f,e[6]=m+d*a,e[10]=r*l}else if(t.order==="ZXY"){const d=l*u,p=l*c,f=h*u,m=h*c;e[0]=d-m*a,e[4]=-r*c,e[8]=f+p*a,e[1]=p+f*a,e[5]=r*u,e[9]=m-d*a,e[2]=-r*h,e[6]=a,e[10]=r*l}else if(t.order==="ZYX"){const d=r*u,p=r*c,f=a*u,m=a*c;e[0]=l*u,e[4]=f*h-p,e[8]=d*h+m,e[1]=l*c,e[5]=m*h+d,e[9]=p*h-f,e[2]=-h,e[6]=a*l,e[10]=r*l}else if(t.order==="YZX"){const d=r*l,p=r*h,f=a*l,m=a*h;e[0]=l*u,e[4]=m-d*c,e[8]=f*c+p,e[1]=c,e[5]=r*u,e[9]=-a*u,e[2]=-h*u,e[6]=p*c+f,e[10]=d-m*c}else if(t.order==="XZY"){const d=r*l,p=r*h,f=a*l,m=a*h;e[0]=l*u,e[4]=-c,e[8]=h*u,e[1]=d*c+m,e[5]=r*u,e[9]=p*c-f,e[2]=f*c-p,e[6]=a*u,e[10]=m*c+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Fb,t,Ib)}lookAt(t,e,i){const s=this.elements;return Oe.subVectors(t,e),Oe.lengthSq()===0&&(Oe.z=1),Oe.normalize(),vs.crossVectors(i,Oe),vs.lengthSq()===0&&(Math.abs(i.z)===1?Oe.x+=1e-4:Oe.z+=1e-4,Oe.normalize(),vs.crossVectors(i,Oe)),vs.normalize(),La.crossVectors(Oe,vs),s[0]=vs.x,s[4]=La.x,s[8]=Oe.x,s[1]=vs.y,s[5]=La.y,s[9]=Oe.y,s[2]=vs.z,s[6]=La.z,s[10]=Oe.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[4],l=i[8],h=i[12],u=i[1],c=i[5],d=i[9],p=i[13],f=i[2],m=i[6],g=i[10],y=i[14],x=i[3],M=i[7],_=i[11],v=i[15],A=s[0],T=s[4],w=s[8],U=s[12],D=s[1],V=s[5],W=s[9],$=s[13],at=s[2],J=s[6],At=s[10],St=s[14],Pt=s[3],dt=s[7],tt=s[11],Rt=s[15];return n[0]=r*A+a*D+l*at+h*Pt,n[4]=r*T+a*V+l*J+h*dt,n[8]=r*w+a*W+l*At+h*tt,n[12]=r*U+a*$+l*St+h*Rt,n[1]=u*A+c*D+d*at+p*Pt,n[5]=u*T+c*V+d*J+p*dt,n[9]=u*w+c*W+d*At+p*tt,n[13]=u*U+c*$+d*St+p*Rt,n[2]=f*A+m*D+g*at+y*Pt,n[6]=f*T+m*V+g*J+y*dt,n[10]=f*w+m*W+g*At+y*tt,n[14]=f*U+m*$+g*St+y*Rt,n[3]=x*A+M*D+_*at+v*Pt,n[7]=x*T+M*V+_*J+v*dt,n[11]=x*w+M*W+_*At+v*tt,n[15]=x*U+M*$+_*St+v*Rt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],n=t[12],r=t[1],a=t[5],l=t[9],h=t[13],u=t[2],c=t[6],d=t[10],p=t[14],f=t[3],m=t[7],g=t[11],y=t[15];return f*(+n*l*c-s*h*c-n*a*d+i*h*d+s*a*p-i*l*p)+m*(+e*l*p-e*h*d+n*r*d-s*r*p+s*h*u-n*l*u)+g*(+e*h*c-e*a*p-n*r*c+i*r*p+n*a*u-i*h*u)+y*(-s*a*u-e*l*c+e*a*d+s*r*c-i*r*d+i*l*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],l=t[6],h=t[7],u=t[8],c=t[9],d=t[10],p=t[11],f=t[12],m=t[13],g=t[14],y=t[15],x=c*g*h-m*d*h+m*l*p-a*g*p-c*l*y+a*d*y,M=f*d*h-u*g*h-f*l*p+r*g*p+u*l*y-r*d*y,_=u*m*h-f*c*h+f*a*p-r*m*p-u*a*y+r*c*y,v=f*c*l-u*m*l-f*a*d+r*m*d+u*a*g-r*c*g,A=e*x+i*M+s*_+n*v;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/A;return t[0]=x*T,t[1]=(m*d*n-c*g*n-m*s*p+i*g*p+c*s*y-i*d*y)*T,t[2]=(a*g*n-m*l*n+m*s*h-i*g*h-a*s*y+i*l*y)*T,t[3]=(c*l*n-a*d*n-c*s*h+i*d*h+a*s*p-i*l*p)*T,t[4]=M*T,t[5]=(u*g*n-f*d*n+f*s*p-e*g*p-u*s*y+e*d*y)*T,t[6]=(f*l*n-r*g*n-f*s*h+e*g*h+r*s*y-e*l*y)*T,t[7]=(r*d*n-u*l*n+u*s*h-e*d*h-r*s*p+e*l*p)*T,t[8]=_*T,t[9]=(f*c*n-u*m*n-f*i*p+e*m*p+u*i*y-e*c*y)*T,t[10]=(r*m*n-f*a*n+f*i*h-e*m*h-r*i*y+e*a*y)*T,t[11]=(u*a*n-r*c*n-u*i*h+e*c*h+r*i*p-e*a*p)*T,t[12]=v*T,t[13]=(u*m*s-f*c*s+f*i*d-e*m*d-u*i*g+e*c*g)*T,t[14]=(f*a*s-r*m*s-f*i*l+e*m*l+r*i*g-e*a*g)*T,t[15]=(r*c*s-u*a*s+u*i*l-e*c*l-r*i*d+e*a*d)*T,this}scale(t){const e=this.elements,i=t.x,s=t.y,n=t.z;return e[0]*=i,e[4]*=s,e[8]*=n,e[1]*=i,e[5]*=s,e[9]*=n,e[2]*=i,e[6]*=s,e[10]*=n,e[3]*=i,e[7]*=s,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),n=1-i,r=t.x,a=t.y,l=t.z,h=n*r,u=n*a;return this.set(h*r+i,h*a-s*l,h*l+s*a,0,h*a+s*l,u*a+i,u*l-s*r,0,h*l-s*a,u*l+s*r,n*l*l+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,n,r){return this.set(1,i,n,0,t,1,r,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,n=e._x,r=e._y,a=e._z,l=e._w,h=n+n,u=r+r,c=a+a,d=n*h,p=n*u,f=n*c,m=r*u,g=r*c,y=a*c,x=l*h,M=l*u,_=l*c,v=i.x,A=i.y,T=i.z;return s[0]=(1-(m+y))*v,s[1]=(p+_)*v,s[2]=(f-M)*v,s[3]=0,s[4]=(p-_)*A,s[5]=(1-(d+y))*A,s[6]=(g+x)*A,s[7]=0,s[8]=(f+M)*T,s[9]=(g-x)*T,s[10]=(1-(d+m))*T,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let n=Vn.set(s[0],s[1],s[2]).length();const r=Vn.set(s[4],s[5],s[6]).length(),a=Vn.set(s[8],s[9],s[10]).length();this.determinant()<0&&(n=-n),t.x=s[12],t.y=s[13],t.z=s[14],fi.copy(this);const h=1/n,u=1/r,c=1/a;return fi.elements[0]*=h,fi.elements[1]*=h,fi.elements[2]*=h,fi.elements[4]*=u,fi.elements[5]*=u,fi.elements[6]*=u,fi.elements[8]*=c,fi.elements[9]*=c,fi.elements[10]*=c,e.setFromRotationMatrix(fi),i.x=n,i.y=r,i.z=a,this}makePerspective(t,e,i,s,n,r,a=fn){const l=this.elements,h=2*n/(e-t),u=2*n/(i-s),c=(e+t)/(e-t),d=(i+s)/(i-s);let p,f;if(a===fn)p=-(r+n)/(r-n),f=-2*r*n/(r-n);else if(a===ad)p=-r/(r-n),f=-r*n/(r-n);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=h,l[4]=0,l[8]=c,l[12]=0,l[1]=0,l[5]=u,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(t,e,i,s,n,r,a=fn){const l=this.elements,h=1/(e-t),u=1/(i-s),c=1/(r-n),d=(e+t)*h,p=(i+s)*u;let f,m;if(a===fn)f=(r+n)*c,m=-2*c;else if(a===ad)f=n*c,m=-1*c;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*h,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*u,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=m,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}};const Vn=new S,fi=new ht,Fb=new S(0,0,0),Ib=new S(1,1,1),vs=new S,La=new S,Oe=new S,pm=new ht,fm=new rt;let ps=class $x{constructor(t=0,e=0,i=0,s=$x.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,n=s[0],r=s[4],a=s[8],l=s[1],h=s[5],u=s[9],c=s[2],d=s[6],p=s[10];switch(e){case"XYZ":this._y=Math.asin(Jt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-r,n)):(this._x=Math.atan2(d,h),this._z=0);break;case"YXZ":this._x=Math.asin(-Jt(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-c,n),this._z=0);break;case"ZXY":this._x=Math.asin(Jt(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-c,p),this._z=Math.atan2(-r,h)):(this._y=0,this._z=Math.atan2(l,n));break;case"ZYX":this._y=Math.asin(-Jt(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,n)):(this._x=0,this._z=Math.atan2(-r,h));break;case"YZX":this._z=Math.asin(Jt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-c,n)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Jt(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(d,h),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return pm.makeRotationFromQuaternion(t),this.setFromRotationMatrix(pm,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return fm.setFromEuler(this),this.setFromQuaternion(fm,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}};ps.DEFAULT_ORDER="XYZ";let Bb=class{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}},Lb=0;const mm=new S,kn=new rt,qi=new ht,Ua=new S,mo=new S,Ub=new S,Db=new rt,gm=new S(1,0,0),ym=new S(0,1,0),xm=new S(0,0,1),_m={type:"added"},Ob={type:"removed"},Gn={type:"childadded",child:null},Tu={type:"childremoved",child:null};let Xt=class Wl extends Dh{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Lb++}),this.uuid=Si(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Wl.DEFAULT_UP.clone();const t=new S,e=new ps,i=new rt,s=new S(1,1,1);function n(){i.setFromEuler(e,!1)}function r(){e.setFromQuaternion(i,void 0,!1)}e._onChange(n),i._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new ht},normalMatrix:{value:new yt}}),this.matrix=new ht,this.matrixWorld=new ht,this.matrixAutoUpdate=Wl.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Wl.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Bb,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return kn.setFromAxisAngle(t,e),this.quaternion.multiply(kn),this}rotateOnWorldAxis(t,e){return kn.setFromAxisAngle(t,e),this.quaternion.premultiply(kn),this}rotateX(t){return this.rotateOnAxis(gm,t)}rotateY(t){return this.rotateOnAxis(ym,t)}rotateZ(t){return this.rotateOnAxis(xm,t)}translateOnAxis(t,e){return mm.copy(t).applyQuaternion(this.quaternion),this.position.add(mm.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(gm,t)}translateY(t){return this.translateOnAxis(ym,t)}translateZ(t){return this.translateOnAxis(xm,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(qi.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?Ua.copy(t):Ua.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),mo.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?qi.lookAt(mo,Ua,this.up):qi.lookAt(Ua,mo,this.up),this.quaternion.setFromRotationMatrix(qi),s&&(qi.extractRotation(s.matrixWorld),kn.setFromRotationMatrix(qi),this.quaternion.premultiply(kn.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(_m),Gn.child=t,this.dispatchEvent(Gn),Gn.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Ob),Tu.child=t,this.dispatchEvent(Tu),Tu.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),qi.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),qi.multiply(t.parent.matrixWorld)),t.applyMatrix4(qi),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(_m),Gn.child=t,this.dispatchEvent(Gn),Gn.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const r=this.children[i].getObjectByProperty(t,e);if(r!==void 0)return r}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const s=this.children;for(let n=0,r=s.length;n<r;n++)s[n].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(mo,t,Ub),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(mo,Db,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const s=this.children;for(let n=0,r=s.length;n<r;n++)s[n].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),s.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(s.type="BatchedMesh",s.perObjectFrustumCulled=this.perObjectFrustumCulled,s.sortObjects=this.sortObjects,s.drawRanges=this._drawRanges,s.reservedRanges=this._reservedRanges,s.visibility=this._visibility,s.active=this._active,s.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),s.maxInstanceCount=this._maxInstanceCount,s.maxVertexCount=this._maxVertexCount,s.maxIndexCount=this._maxIndexCount,s.geometryInitialized=this._geometryInitialized,s.geometryCount=this._geometryCount,s.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(s.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(s.boundingSphere={center:s.boundingSphere.center.toArray(),radius:s.boundingSphere.radius}),this.boundingBox!==null&&(s.boundingBox={min:s.boundingBox.min.toArray(),max:s.boundingBox.max.toArray()}));function n(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=n(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let h=0,u=l.length;h<u;h++){const c=l[h];n(t.shapes,c)}else n(t.shapes,l)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(n(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,h=this.material.length;l<h;l++)a.push(n(t.materials,this.material[l]));s.material=a}else s.material=n(t.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];s.animations.push(n(t.animations,l))}}if(e){const a=r(t.geometries),l=r(t.materials),h=r(t.textures),u=r(t.images),c=r(t.shapes),d=r(t.skeletons),p=r(t.animations),f=r(t.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),h.length>0&&(i.textures=h),u.length>0&&(i.images=u),c.length>0&&(i.shapes=c),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),f.length>0&&(i.nodes=f)}return i.object=s,i;function r(a){const l=[];for(const h in a){const u=a[h];delete u.metadata,l.push(u)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const s=t.children[i];this.add(s.clone())}return this}};Xt.DEFAULT_UP=new S(0,1,0);Xt.DEFAULT_MATRIX_AUTO_UPDATE=!0;Xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const mi=new S,ji=new S,bu=new S,Xi=new S,Wn=new S,Hn=new S,Mm=new S,Su=new S,wu=new S,Au=new S;let Da=class xr{constructor(t=new S,e=new S,i=new S){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),mi.subVectors(t,e),s.cross(mi);const n=s.lengthSq();return n>0?s.multiplyScalar(1/Math.sqrt(n)):s.set(0,0,0)}static getBarycoord(t,e,i,s,n){mi.subVectors(s,e),ji.subVectors(i,e),bu.subVectors(t,e);const r=mi.dot(mi),a=mi.dot(ji),l=mi.dot(bu),h=ji.dot(ji),u=ji.dot(bu),c=r*h-a*a;if(c===0)return n.set(0,0,0),null;const d=1/c,p=(h*l-a*u)*d,f=(r*u-a*l)*d;return n.set(1-p-f,f,p)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,Xi)===null?!1:Xi.x>=0&&Xi.y>=0&&Xi.x+Xi.y<=1}static getInterpolation(t,e,i,s,n,r,a,l){return this.getBarycoord(t,e,i,s,Xi)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(n,Xi.x),l.addScaledVector(r,Xi.y),l.addScaledVector(a,Xi.z),l)}static isFrontFacing(t,e,i,s){return mi.subVectors(i,e),ji.subVectors(t,e),mi.cross(ji).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return mi.subVectors(this.c,this.b),ji.subVectors(this.a,this.b),mi.cross(ji).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return xr.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return xr.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,i,s,n){return xr.getInterpolation(t,this.a,this.b,this.c,e,i,s,n)}containsPoint(t){return xr.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return xr.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,n=this.c;let r,a;Wn.subVectors(s,i),Hn.subVectors(n,i),Su.subVectors(t,i);const l=Wn.dot(Su),h=Hn.dot(Su);if(l<=0&&h<=0)return e.copy(i);wu.subVectors(t,s);const u=Wn.dot(wu),c=Hn.dot(wu);if(u>=0&&c<=u)return e.copy(s);const d=l*c-u*h;if(d<=0&&l>=0&&u<=0)return r=l/(l-u),e.copy(i).addScaledVector(Wn,r);Au.subVectors(t,n);const p=Wn.dot(Au),f=Hn.dot(Au);if(f>=0&&p<=f)return e.copy(n);const m=p*h-l*f;if(m<=0&&h>=0&&f<=0)return a=h/(h-f),e.copy(i).addScaledVector(Hn,a);const g=u*f-p*c;if(g<=0&&c-u>=0&&p-f>=0)return Mm.subVectors(n,s),a=(c-u)/(c-u+(p-f)),e.copy(s).addScaledVector(Mm,a);const y=1/(g+m+d);return r=m*y,a=d*y,e.copy(i).addScaledVector(Wn,r).addScaledVector(Hn,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}};const qx={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Ts={h:0,s:0,l:0},Oa={h:0,s:0,l:0};function Nu(o,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?o+(t-o)*6*e:e<1/2?t:e<2/3?o+(t-o)*6*(2/3-e):o}let lt=class{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(e===void 0&&i===void 0){const s=t;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=Fs){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,di.toWorkingColorSpace(this,e),this}setRGB(t,e,i,s=di.workingColorSpace){return this.r=t,this.g=e,this.b=i,di.toWorkingColorSpace(this,s),this}setHSL(t,e,i,s=di.workingColorSpace){if(t=vp(t,1),e=Jt(e,0,1),i=Jt(i,0,1),e===0)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,r=2*i-n;this.r=Nu(r,n,t+1/3),this.g=Nu(r,n,t),this.b=Nu(r,n,t-1/3)}return di.toWorkingColorSpace(this,s),this}setStyle(t,e=Fs){function i(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let s;if(s=/^(\w+)\(([^\)]*)\)/.exec(t)){let n;const r=s[1],a=s[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(n[4]),this.setRGB(Math.min(255,parseInt(n[1],10))/255,Math.min(255,parseInt(n[2],10))/255,Math.min(255,parseInt(n[3],10))/255,e);if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(n[4]),this.setRGB(Math.min(100,parseInt(n[1],10))/100,Math.min(100,parseInt(n[2],10))/100,Math.min(100,parseInt(n[3],10))/100,e);break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(n[4]),this.setHSL(parseFloat(n[1])/360,parseFloat(n[2])/100,parseFloat(n[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=s[1],r=n.length;if(r===3)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(r===6)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=Fs){const i=qx[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Br(t.r),this.g=Br(t.g),this.b=Br(t.b),this}copyLinearToSRGB(t){return this.r=fu(t.r),this.g=fu(t.g),this.b=fu(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=Fs){return di.fromWorkingColorSpace(ge.copy(this),t),Math.round(Jt(ge.r*255,0,255))*65536+Math.round(Jt(ge.g*255,0,255))*256+Math.round(Jt(ge.b*255,0,255))}getHexString(t=Fs){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=di.workingColorSpace){di.fromWorkingColorSpace(ge.copy(this),e);const i=ge.r,s=ge.g,n=ge.b,r=Math.max(i,s,n),a=Math.min(i,s,n);let l,h;const u=(a+r)/2;if(a===r)l=0,h=0;else{const c=r-a;switch(h=u<=.5?c/(r+a):c/(2-r-a),r){case i:l=(s-n)/c+(s<n?6:0);break;case s:l=(n-i)/c+2;break;case n:l=(i-s)/c+4;break}l/=6}return t.h=l,t.s=h,t.l=u,t}getRGB(t,e=di.workingColorSpace){return di.fromWorkingColorSpace(ge.copy(this),e),t.r=ge.r,t.g=ge.g,t.b=ge.b,t}getStyle(t=Fs){di.fromWorkingColorSpace(ge.copy(this),t);const e=ge.r,i=ge.g,s=ge.b;return t!==Fs?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(i*255)},${Math.round(s*255)})`}offsetHSL(t,e,i){return this.getHSL(Ts),this.setHSL(Ts.h+t,Ts.s+e,Ts.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Ts),t.getHSL(Oa);const i=Ho(Ts.h,Oa.h,e),s=Ho(Ts.s,Oa.s,e),n=Ho(Ts.l,Oa.l,e);return this.setHSL(i,s,n),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,s=this.b,n=t.elements;return this.r=n[0]*e+n[3]*i+n[6]*s,this.g=n[1]*e+n[4]*i+n[7]*s,this.b=n[2]*e+n[5]*i+n[8]*s,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};const ge=new lt;lt.NAMES=qx;let zb=0,fs=class extends Dh{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:zb++}),this.uuid=Si(),this.name="",this.type="Material",this.blending=qf,this.side=sd,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Xf,this.blendDst=Yf,this.blendEquation=jf,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new lt(0,0,0),this.blendAlpha=0,this.depthFunc=Zf,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=am,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Ln,this.stencilZFail=Ln,this.stencilZPass=Ln,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const s=this[e];if(s===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==qf&&(i.blending=this.blending),this.side!==sd&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==Xf&&(i.blendSrc=this.blendSrc),this.blendDst!==Yf&&(i.blendDst=this.blendDst),this.blendEquation!==jf&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==Zf&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==am&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Ln&&(i.stencilFail=this.stencilFail),this.stencilZFail!==Ln&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==Ln&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function s(n){const r=[];for(const a in n){const l=n[a];delete l.metadata,r.push(l)}return r}if(e){const n=s(t.textures),r=s(t.images);n.length>0&&(i.textures=n),r.length>0&&(i.images=r)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const s=e.length;i=new Array(s);for(let n=0;n!==s;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}onBeforeRender(){console.warn("Material: onBeforeRender() has been removed.")}},ud=class extends fs{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new lt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ps,this.combine=xp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}};const Vt=new S,za=new wt;let It=class{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i,this.usage=od,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=_p,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return Gx("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,n=this.itemSize;s<n;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)za.fromBufferAttribute(this,e),za.applyMatrix3(t),this.setXY(e,za.x,za.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)Vt.fromBufferAttribute(this,e),Vt.applyMatrix3(t),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)Vt.fromBufferAttribute(this,e),Vt.applyMatrix4(t),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Vt.fromBufferAttribute(this,e),Vt.applyNormalMatrix(t),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Vt.fromBufferAttribute(this,e),Vt.transformDirection(t),this.setXYZ(e,Vt.x,Vt.y,Vt.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=Ti(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=Mt(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Ti(e,this.array)),e}setX(t,e){return this.normalized&&(e=Mt(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Ti(e,this.array)),e}setY(t,e){return this.normalized&&(e=Mt(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Ti(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Mt(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Ti(e,this.array)),e}setW(t,e){return this.normalized&&(e=Mt(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=Mt(e,this.array),i=Mt(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.normalized&&(e=Mt(e,this.array),i=Mt(i,this.array),s=Mt(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t*=this.itemSize,this.normalized&&(e=Mt(e,this.array),i=Mt(i,this.array),s=Mt(s,this.array),n=Mt(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==od&&(t.usage=this.usage),t}},Vb=class extends It{constructor(t,e,i){super(new Uint16Array(t),e,i)}},kb=class extends It{constructor(t,e,i){super(new Uint32Array(t),e,i)}},Ko=class extends It{constructor(t,e,i){super(new Float32Array(t),e,i)}},Gb=0;const ei=new ht,Ru=new Xt,$n=new S,ze=new Ws,go=new Ws,Zt=new S;let Ke=class jx extends Dh{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Gb++}),this.uuid=Si(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(wb(t)?kb:Vb)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const n=new yt().getNormalMatrix(t);i.applyNormalMatrix(n),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ei.makeRotationFromQuaternion(t),this.applyMatrix4(ei),this}rotateX(t){return ei.makeRotationX(t),this.applyMatrix4(ei),this}rotateY(t){return ei.makeRotationY(t),this.applyMatrix4(ei),this}rotateZ(t){return ei.makeRotationZ(t),this.applyMatrix4(ei),this}translate(t,e,i){return ei.makeTranslation(t,e,i),this.applyMatrix4(ei),this}scale(t,e,i){return ei.makeScale(t,e,i),this.applyMatrix4(ei),this}lookAt(t){return Ru.lookAt(t),Ru.updateMatrix(),this.applyMatrix4(Ru.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter($n).negate(),this.translate($n.x,$n.y,$n.z),this}setFromPoints(t){const e=[];for(let i=0,s=t.length;i<s;i++){const n=t[i];e.push(n.x,n.y,n.z||0)}return this.setAttribute("position",new Ko(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ws);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new S(-1/0,-1/0,-1/0),new S(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,s=e.length;i<s;i++){const n=e[i];ze.setFromBufferAttribute(n),this.morphTargetsRelative?(Zt.addVectors(this.boundingBox.min,ze.min),this.boundingBox.expandByPoint(Zt),Zt.addVectors(this.boundingBox.max,ze.max),this.boundingBox.expandByPoint(Zt)):(this.boundingBox.expandByPoint(ze.min),this.boundingBox.expandByPoint(ze.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ds);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new S,1/0);return}if(t){const i=this.boundingSphere.center;if(ze.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const a=e[n];go.setFromBufferAttribute(a),this.morphTargetsRelative?(Zt.addVectors(ze.min,go.min),ze.expandByPoint(Zt),Zt.addVectors(ze.max,go.max),ze.expandByPoint(Zt)):(ze.expandByPoint(go.min),ze.expandByPoint(go.max))}ze.getCenter(i);let s=0;for(let n=0,r=t.count;n<r;n++)Zt.fromBufferAttribute(t,n),s=Math.max(s,i.distanceToSquared(Zt));if(e)for(let n=0,r=e.length;n<r;n++){const a=e[n],l=this.morphTargetsRelative;for(let h=0,u=a.count;h<u;h++)Zt.fromBufferAttribute(a,h),l&&($n.fromBufferAttribute(t,h),Zt.add($n)),s=Math.max(s,i.distanceToSquared(Zt))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.position,s=e.normal,n=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new It(new Float32Array(4*i.count),4));const r=this.getAttribute("tangent"),a=[],l=[];for(let w=0;w<i.count;w++)a[w]=new S,l[w]=new S;const h=new S,u=new S,c=new S,d=new wt,p=new wt,f=new wt,m=new S,g=new S;function y(w,U,D){h.fromBufferAttribute(i,w),u.fromBufferAttribute(i,U),c.fromBufferAttribute(i,D),d.fromBufferAttribute(n,w),p.fromBufferAttribute(n,U),f.fromBufferAttribute(n,D),u.sub(h),c.sub(h),p.sub(d),f.sub(d);const V=1/(p.x*f.y-f.x*p.y);isFinite(V)&&(m.copy(u).multiplyScalar(f.y).addScaledVector(c,-p.y).multiplyScalar(V),g.copy(c).multiplyScalar(p.x).addScaledVector(u,-f.x).multiplyScalar(V),a[w].add(m),a[U].add(m),a[D].add(m),l[w].add(g),l[U].add(g),l[D].add(g))}let x=this.groups;x.length===0&&(x=[{start:0,count:t.count}]);for(let w=0,U=x.length;w<U;++w){const D=x[w],V=D.start,W=D.count;for(let $=V,at=V+W;$<at;$+=3)y(t.getX($+0),t.getX($+1),t.getX($+2))}const M=new S,_=new S,v=new S,A=new S;function T(w){v.fromBufferAttribute(s,w),A.copy(v);const U=a[w];M.copy(U),M.sub(v.multiplyScalar(v.dot(U))).normalize(),_.crossVectors(A,U);const V=_.dot(l[w])<0?-1:1;r.setXYZW(w,M.x,M.y,M.z,V)}for(let w=0,U=x.length;w<U;++w){const D=x[w],V=D.start,W=D.count;for(let $=V,at=V+W;$<at;$+=3)T(t.getX($+0)),T(t.getX($+1)),T(t.getX($+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new It(new Float32Array(e.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const s=new S,n=new S,r=new S,a=new S,l=new S,h=new S,u=new S,c=new S;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),g=t.getX(d+2);s.fromBufferAttribute(e,f),n.fromBufferAttribute(e,m),r.fromBufferAttribute(e,g),u.subVectors(r,n),c.subVectors(s,n),u.cross(c),a.fromBufferAttribute(i,f),l.fromBufferAttribute(i,m),h.fromBufferAttribute(i,g),a.add(u),l.add(u),h.add(u),i.setXYZ(f,a.x,a.y,a.z),i.setXYZ(m,l.x,l.y,l.z),i.setXYZ(g,h.x,h.y,h.z)}else for(let d=0,p=e.count;d<p;d+=3)s.fromBufferAttribute(e,d+0),n.fromBufferAttribute(e,d+1),r.fromBufferAttribute(e,d+2),u.subVectors(r,n),c.subVectors(s,n),u.cross(c),i.setXYZ(d+0,u.x,u.y,u.z),i.setXYZ(d+1,u.x,u.y,u.z),i.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Zt.fromBufferAttribute(t,e),Zt.normalize(),t.setXYZ(e,Zt.x,Zt.y,Zt.z)}toNonIndexed(){function t(a,l){const h=a.array,u=a.itemSize,c=a.normalized,d=new h.constructor(l.length*u);let p=0,f=0;for(let m=0,g=l.length;m<g;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*u;for(let y=0;y<u;y++)d[f++]=h[p++]}return new It(d,u,c)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new jx,i=this.index.array,s=this.attributes;for(const a in s){const l=s[a],h=t(l,i);e.setAttribute(a,h)}const n=this.morphAttributes;for(const a in n){const l=[],h=n[a];for(let u=0,c=h.length;u<c;u++){const d=h[u],p=t(d,i);l.push(p)}e.morphAttributes[a]=l}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let a=0,l=r.length;a<l;a++){const h=r[a];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const h in l)l[h]!==void 0&&(t[h]=l[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const l in i){const h=i[l];t.data.attributes[l]=h.toJSON(t.data)}const s={};let n=!1;for(const l in this.morphAttributes){const h=this.morphAttributes[l],u=[];for(let c=0,d=h.length;c<d;c++){const p=h[c];u.push(p.toJSON(t.data))}u.length>0&&(s[l]=u,n=!0)}n&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const s=t.attributes;for(const h in s){const u=s[h];this.setAttribute(h,u.clone(e))}const n=t.morphAttributes;for(const h in n){const u=[],c=n[h];for(let d=0,p=c.length;d<p;d++)u.push(c[d].clone(e));this.morphAttributes[h]=u}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let h=0,u=r.length;h<u;h++){const c=r[h];this.addGroup(c.start,c.count,c.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}};const vm=new ht,Zs=new Oh,Va=new ds,Tm=new S,qn=new S,jn=new S,Xn=new S,Eu=new S,ka=new S,Ga=new wt,Wa=new wt,Ha=new wt,bm=new S,Sm=new S,wm=new S,$a=new S,qa=new S;let ta=class extends Xt{constructor(t=new Ke,e=new ud){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}getVertexPosition(t,e){const i=this.geometry,s=i.attributes.position,n=i.morphAttributes.position,r=i.morphTargetsRelative;e.fromBufferAttribute(s,t);const a=this.morphTargetInfluences;if(n&&a){ka.set(0,0,0);for(let l=0,h=n.length;l<h;l++){const u=a[l],c=n[l];u!==0&&(Eu.fromBufferAttribute(c,t),r?ka.addScaledVector(Eu,u):ka.addScaledVector(Eu.sub(e),u))}e.add(ka)}return e}raycast(t,e){const i=this.geometry,s=this.material,n=this.matrixWorld;s!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),Va.copy(i.boundingSphere),Va.applyMatrix4(n),Zs.copy(t.ray).recast(t.near),!(Va.containsPoint(Zs.origin)===!1&&(Zs.intersectSphere(Va,Tm)===null||Zs.origin.distanceToSquared(Tm)>(t.far-t.near)**2))&&(vm.copy(n).invert(),Zs.copy(t.ray).applyMatrix4(vm),!(i.boundingBox!==null&&Zs.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(t,e,Zs)))}_computeIntersections(t,e,i){let s;const n=this.geometry,r=this.material,a=n.index,l=n.attributes.position,h=n.attributes.uv,u=n.attributes.uv1,c=n.attributes.normal,d=n.groups,p=n.drawRange;if(a!==null)if(Array.isArray(r))for(let f=0,m=d.length;f<m;f++){const g=d[f],y=r[g.materialIndex],x=Math.max(g.start,p.start),M=Math.min(a.count,Math.min(g.start+g.count,p.start+p.count));for(let _=x,v=M;_<v;_+=3){const A=a.getX(_),T=a.getX(_+1),w=a.getX(_+2);s=ja(this,y,t,i,h,u,c,A,T,w),s&&(s.faceIndex=Math.floor(_/3),s.face.materialIndex=g.materialIndex,e.push(s))}}else{const f=Math.max(0,p.start),m=Math.min(a.count,p.start+p.count);for(let g=f,y=m;g<y;g+=3){const x=a.getX(g),M=a.getX(g+1),_=a.getX(g+2);s=ja(this,r,t,i,h,u,c,x,M,_),s&&(s.faceIndex=Math.floor(g/3),e.push(s))}}else if(l!==void 0)if(Array.isArray(r))for(let f=0,m=d.length;f<m;f++){const g=d[f],y=r[g.materialIndex],x=Math.max(g.start,p.start),M=Math.min(l.count,Math.min(g.start+g.count,p.start+p.count));for(let _=x,v=M;_<v;_+=3){const A=_,T=_+1,w=_+2;s=ja(this,y,t,i,h,u,c,A,T,w),s&&(s.faceIndex=Math.floor(_/3),s.face.materialIndex=g.materialIndex,e.push(s))}}else{const f=Math.max(0,p.start),m=Math.min(l.count,p.start+p.count);for(let g=f,y=m;g<y;g+=3){const x=g,M=g+1,_=g+2;s=ja(this,r,t,i,h,u,c,x,M,_),s&&(s.faceIndex=Math.floor(g/3),e.push(s))}}}};function Wb(o,t,e,i,s,n,r,a){let l;if(t.side===yp?l=i.intersectTriangle(r,n,s,!0,a):l=i.intersectTriangle(s,n,r,t.side===sd,a),l===null)return null;qa.copy(a),qa.applyMatrix4(o.matrixWorld);const h=e.ray.origin.distanceTo(qa);return h<e.near||h>e.far?null:{distance:h,point:qa.clone(),object:o}}function ja(o,t,e,i,s,n,r,a,l,h){o.getVertexPosition(a,qn),o.getVertexPosition(l,jn),o.getVertexPosition(h,Xn);const u=Wb(o,t,e,i,qn,jn,Xn,$a);if(u){s&&(Ga.fromBufferAttribute(s,a),Wa.fromBufferAttribute(s,l),Ha.fromBufferAttribute(s,h),u.uv=Da.getInterpolation($a,qn,jn,Xn,Ga,Wa,Ha,new wt)),n&&(Ga.fromBufferAttribute(n,a),Wa.fromBufferAttribute(n,l),Ha.fromBufferAttribute(n,h),u.uv1=Da.getInterpolation($a,qn,jn,Xn,Ga,Wa,Ha,new wt)),r&&(bm.fromBufferAttribute(r,a),Sm.fromBufferAttribute(r,l),wm.fromBufferAttribute(r,h),u.normal=Da.getInterpolation($a,qn,jn,Xn,bm,Sm,wm,new S),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const c={a,b:l,c:h,normal:new S,materialIndex:0};Da.getNormal(qn,jn,Xn,c.normal),u.face=c}return u}function Tp(o){const t={};for(const e in o){t[e]={};for(const i in o[e]){const s=o[e][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][i]=null):t[e][i]=s.clone():Array.isArray(s)?t[e][i]=s.slice():t[e][i]=s}}return t}function Hb(o){const t={};for(let e=0;e<o.length;e++){const i=Tp(o[e]);for(const s in i)t[s]=i[s]}return t}function $b(o){const t=[];for(let e=0;e<o.length;e++)t.push(o[e].clone());return t}const Xx={clone:Tp,merge:Hb};var qb=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,jb=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;let Yx=class extends fs{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=qb,this.fragmentShader=jb,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Tp(t.uniforms),this.uniformsGroups=$b(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const s in this.uniforms){const r=this.uniforms[s].value;r&&r.isTexture?e.uniforms[s]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[s]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[s]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[s]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[s]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[s]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[s]={type:"m4",value:r.toArray()}:e.uniforms[s]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}},Zx=class extends Xt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ht,this.projectionMatrix=new ht,this.projectionMatrixInverse=new ht,this.coordinateSystem=fn}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}};const bs=new S,Am=new wt,Nm=new wt;let Qx=class extends Zx{constructor(t=50,e=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Jo*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Wo*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Jo*2*Math.atan(Math.tan(Wo*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){bs.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(bs.x,bs.y).multiplyScalar(-t/bs.z),bs.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(bs.x,bs.y).multiplyScalar(-t/bs.z)}getViewSize(t,e){return this.getViewBounds(t,Am,Nm),e.subVectors(Nm,Am)}setViewOffset(t,e,i,s,n,r){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Wo*.5*this.fov)/this.zoom,i=2*e,s=this.aspect*i,n=-.5*s;const r=this.view;if(this.view!==null&&this.view.enabled){const l=r.fullWidth,h=r.fullHeight;n+=r.offsetX*s/l,e-=r.offsetY*i/h,s*=r.width/l,i*=r.height/h}const a=this.filmOffset;a!==0&&(n+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+s,e,e-i,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}};const Cu=new S,Xb=new S,Yb=new yt;let Yn=class{constructor(t=new S(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=Cu.subVectors(i,e).cross(Xb.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(Cu),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const n=-(t.start.dot(this.normal)+this.constant)/s;return n<0||n>1?null:e.copy(t.start).addScaledVector(i,n)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||Yb.getNormalMatrix(t),s=this.coplanarPoint(Cu).applyMatrix4(t),n=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}};const Qs=new ds,Xa=new S;let Zb=class{constructor(t=new Yn,e=new Yn,i=new Yn,s=new Yn,n=new Yn,r=new Yn){this.planes=[t,e,i,s,n,r]}set(t,e,i,s,n,r){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(s),a[4].copy(n),a[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=fn){const i=this.planes,s=t.elements,n=s[0],r=s[1],a=s[2],l=s[3],h=s[4],u=s[5],c=s[6],d=s[7],p=s[8],f=s[9],m=s[10],g=s[11],y=s[12],x=s[13],M=s[14],_=s[15];if(i[0].setComponents(l-n,d-h,g-p,_-y).normalize(),i[1].setComponents(l+n,d+h,g+p,_+y).normalize(),i[2].setComponents(l+r,d+u,g+f,_+x).normalize(),i[3].setComponents(l-r,d-u,g-f,_-x).normalize(),i[4].setComponents(l-a,d-c,g-m,_-M).normalize(),e===fn)i[5].setComponents(l+a,d+c,g+m,_+M).normalize();else if(e===ad)i[5].setComponents(a,c,m,M).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),Qs.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),Qs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(Qs)}intersectsSprite(t){return Qs.center.set(0,0,0),Qs.radius=.7071067811865476,Qs.applyMatrix4(t.matrixWorld),this.intersectsSphere(Qs)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let n=0;n<6;n++)if(e[n].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(Xa.x=s.normal.x>0?t.max.x:t.min.x,Xa.y=s.normal.y>0?t.max.y:t.min.y,Xa.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(Xa)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}};const Bi={common:{diffuse:{value:new lt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new yt},alphaMap:{value:null},alphaMapTransform:{value:new yt},alphaTest:{value:0}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new yt},normalScale:{value:new wt(1,1)}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new yt}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new lt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}}};let Qb=class extends Zx{constructor(t=-1,e=1,i=1,s=-1,n=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=n,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,n,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let n=i-t,r=i+t,a=s+e,l=s-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=h*this.view.offsetX,r=n+h*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(n,r,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}};class Jr extends Xt{constructor(){super(),this.isGroup=!0,this.type="Group"}}let QU=class{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=od,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=Si()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return Gx("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,n=this.stride;s<n;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Si()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Si()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}};const Se=new S;let KU=class Jx{constructor(t,e,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)Se.fromBufferAttribute(this,e),Se.applyMatrix4(t),this.setXYZ(e,Se.x,Se.y,Se.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)Se.fromBufferAttribute(this,e),Se.applyNormalMatrix(t),this.setXYZ(e,Se.x,Se.y,Se.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)Se.fromBufferAttribute(this,e),Se.transformDirection(t),this.setXYZ(e,Se.x,Se.y,Se.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=Ti(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=Mt(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=Mt(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=Mt(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=Mt(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=Mt(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Ti(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Ti(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Ti(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Ti(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=Mt(e,this.array),i=Mt(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=Mt(e,this.array),i=Mt(i,this.array),s=Mt(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=Mt(e,this.array),i=Mt(i,this.array),s=Mt(s,this.array),n=Mt(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=n,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return new It(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Jx(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}};const Rm=new S,Em=new Fi,Cm=new Fi,Jb=new S,Pm=new ht,Ya=new S,Pu=new ds,Fm=new ht,Fu=new Oh;class Kb extends ta{constructor(t,e){super(t,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=Qf,this.bindMatrix=new ht,this.bindMatrixInverse=new ht,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const t=this.geometry;this.boundingBox===null&&(this.boundingBox=new Ws),this.boundingBox.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,Ya),this.boundingBox.expandByPoint(Ya)}computeBoundingSphere(){const t=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new ds),this.boundingSphere.makeEmpty();const e=t.getAttribute("position");for(let i=0;i<e.count;i++)this.getVertexPosition(i,Ya),this.boundingSphere.expandByPoint(Ya)}copy(t,e){return super.copy(t,e),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}raycast(t,e){const i=this.material,s=this.matrixWorld;i!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Pu.copy(this.boundingSphere),Pu.applyMatrix4(s),t.ray.intersectsSphere(Pu)!==!1&&(Fm.copy(s).invert(),Fu.copy(t.ray).applyMatrix4(Fm),!(this.boundingBox!==null&&Fu.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(t,e,Fu)))}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Fi,e=this.geometry.attributes.skinWeight;for(let i=0,s=e.count;i<s;i++){t.fromBufferAttribute(e,i);const n=1/t.manhattanLength();n!==1/0?t.multiplyScalar(n):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode===Qf?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===eb?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(t,e){const i=this.skeleton,s=this.geometry;Em.fromBufferAttribute(s.attributes.skinIndex,t),Cm.fromBufferAttribute(s.attributes.skinWeight,t),Rm.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let n=0;n<4;n++){const r=Cm.getComponent(n);if(r!==0){const a=Em.getComponent(n);Pm.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),e.addScaledVector(Jb.copy(Rm).applyMatrix4(Pm),r)}}return e.applyMatrix4(this.bindMatrixInverse)}}class tS extends Xt{constructor(){super(),this.isBone=!0,this.type="Bone"}}let Kx=class extends da{constructor(t=null,e=1,i=1,s,n,r,a,l,h=tm,u=tm,c,d){super(null,r,a,l,h,u,s,n,c,d),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}};const Im=new ht,eS=new ht;class pa{constructor(t=[],e=[]){this.uuid=Si(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const t=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(t.length*16),e.length===0)this.calculateInverses();else if(t.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,s=this.bones.length;i<s;i++)this.boneInverses.push(new ht)}}calculateInverses(){this.boneInverses.length=0;for(let t=0,e=this.bones.length;t<e;t++){const i=new ht;this.bones[t]&&i.copy(this.bones[t].matrixWorld).invert(),this.boneInverses.push(i)}}pose(){for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&i.matrixWorld.copy(this.boneInverses[t]).invert()}for(let t=0,e=this.bones.length;t<e;t++){const i=this.bones[t];i&&(i.parent&&i.parent.isBone?(i.matrix.copy(i.parent.matrixWorld).invert(),i.matrix.multiply(i.matrixWorld)):i.matrix.copy(i.matrixWorld),i.matrix.decompose(i.position,i.quaternion,i.scale))}}update(){const t=this.bones,e=this.boneInverses,i=this.boneMatrices,s=this.boneTexture;for(let n=0,r=t.length;n<r;n++){const a=t[n]?t[n].matrixWorld:eS;Im.multiplyMatrices(a,e[n]),Im.toArray(i,n*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new pa(this.bones,this.boneInverses)}computeBoneTexture(){let t=Math.sqrt(this.bones.length*4);t=Math.ceil(t/4)*4,t=Math.max(t,4);const e=new Float32Array(t*t*4);e.set(this.boneMatrices);const i=new Kx(e,t,t,Dx,_p);return i.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=i,this}getBoneByName(t){for(let e=0,i=this.bones.length;e<i;e++){const s=this.bones[e];if(s.name===t)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(t,e){this.uuid=t.uuid;for(let i=0,s=t.bones.length;i<s;i++){const n=t.bones[i];let r=e[n];r===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",n),r=new tS),this.bones.push(r),this.boneInverses.push(new ht().fromArray(t.boneInverses[i]))}return this.init(),this}toJSON(){const t={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};t.uuid=this.uuid;const e=this.bones,i=this.boneInverses;for(let s=0,n=e.length;s<n;s++){const r=e[s];t.bones.push(r.uuid);const a=i[s];t.boneInverses.push(a.toArray())}return t}}let Bm=class extends It{constructor(t,e,i,s=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}};const Zn=new ht,Lm=new ht,Za=[],Um=new Ws,iS=new ht,yo=new ta,xo=new ds;class iD extends ta{constructor(t,e,i){super(t,e),this.isInstancedMesh=!0,this.instanceMatrix=new Bm(new Float32Array(i*16),16),this.instanceColor=null,this.morphTexture=null,this.count=i,this.boundingBox=null,this.boundingSphere=null;for(let s=0;s<i;s++)this.setMatrixAt(s,iS)}computeBoundingBox(){const t=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new Ws),t.boundingBox===null&&t.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,Zn),Um.copy(t.boundingBox).applyMatrix4(Zn),this.boundingBox.union(Um)}computeBoundingSphere(){const t=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new ds),t.boundingSphere===null&&t.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<e;i++)this.getMatrixAt(i,Zn),xo.copy(t.boundingSphere).applyMatrix4(Zn),this.boundingSphere.union(xo)}copy(t,e){return super.copy(t,e),this.instanceMatrix.copy(t.instanceMatrix),t.morphTexture!==null&&(this.morphTexture=t.morphTexture.clone()),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}getMorphAt(t,e){const i=e.morphTargetInfluences,s=this.morphTexture.source.data.data,n=i.length+1,r=t*n+1;for(let a=0;a<i.length;a++)i[a]=s[r+a]}raycast(t,e){const i=this.matrixWorld,s=this.count;if(yo.geometry=this.geometry,yo.material=this.material,yo.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),xo.copy(this.boundingSphere),xo.applyMatrix4(i),t.ray.intersectsSphere(xo)!==!1))for(let n=0;n<s;n++){this.getMatrixAt(n,Zn),Lm.multiplyMatrices(i,Zn),yo.matrixWorld=Lm,yo.raycast(t,Za);for(let r=0,a=Za.length;r<a;r++){const l=Za[r];l.instanceId=n,l.object=this,e.push(l)}Za.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Bm(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}setMorphAt(t,e){const i=e.morphTargetInfluences,s=i.length+1;this.morphTexture===null&&(this.morphTexture=new Kx(new Float32Array(s*this.count),s,this.count,rb,_p));const n=this.morphTexture.source.data.data;let r=0;for(let h=0;h<i.length;h++)r+=i[h];const a=this.geometry.morphTargetsRelative?1:1-r,l=s*t;n[l]=a,n.set(i,l+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}let Kr=class extends fs{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new lt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}};const nh=new S,rh=new S,Dm=new ht,_o=new Oh,Qa=new ds,Iu=new S,Om=new S;class bp extends Xt{constructor(t=new Ke,e=new Kr){super(),this.isLine=!0,this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[0];for(let s=1,n=e.count;s<n;s++)nh.fromBufferAttribute(e,s-1),rh.fromBufferAttribute(e,s),i[s]=i[s-1],i[s]+=nh.distanceTo(rh);t.setAttribute("lineDistance",new Ko(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Line.threshold,r=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Qa.copy(i.boundingSphere),Qa.applyMatrix4(s),Qa.radius+=n,t.ray.intersectsSphere(Qa)===!1)return;Dm.copy(s).invert(),_o.copy(t.ray).applyMatrix4(Dm);const a=n/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,h=this.isLineSegments?2:1,u=i.index,d=i.attributes.position;if(u!==null){const p=Math.max(0,r.start),f=Math.min(u.count,r.start+r.count);for(let m=p,g=f-1;m<g;m+=h){const y=u.getX(m),x=u.getX(m+1),M=Ja(this,t,_o,l,y,x);M&&e.push(M)}if(this.isLineLoop){const m=u.getX(f-1),g=u.getX(p),y=Ja(this,t,_o,l,m,g);y&&e.push(y)}}else{const p=Math.max(0,r.start),f=Math.min(d.count,r.start+r.count);for(let m=p,g=f-1;m<g;m+=h){const y=Ja(this,t,_o,l,m,m+1);y&&e.push(y)}if(this.isLineLoop){const m=Ja(this,t,_o,l,f-1,p);m&&e.push(m)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}}function Ja(o,t,e,i,s,n){const r=o.geometry.attributes.position;if(nh.fromBufferAttribute(r,s),rh.fromBufferAttribute(r,n),e.distanceSqToSegment(nh,rh,Iu,Om)>i)return;Iu.applyMatrix4(o.matrixWorld);const l=t.ray.origin.distanceTo(Iu);if(!(l<t.near||l>t.far))return{distance:l,point:Om.clone().applyMatrix4(o.matrixWorld),index:s,face:null,faceIndex:null,object:o}}const zm=new S,Vm=new S;class zh extends bp{constructor(t,e){super(t,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.index===null){const e=t.attributes.position,i=[];for(let s=0,n=e.count;s<n;s+=2)zm.fromBufferAttribute(e,s),Vm.fromBufferAttribute(e,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+zm.distanceTo(Vm);t.setAttribute("lineDistance",new Ko(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class nD extends bp{constructor(t,e){super(t,e),this.isLineLoop=!0,this.type="LineLoop"}}let sS=class extends fs{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new lt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}};const km=new ht,cd=new Oh,Ka=new ds,tl=new S;class oD extends Xt{constructor(t=new Ke,e=new sS){super(),this.isPoints=!0,this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,n=t.params.Points.threshold,r=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Ka.copy(i.boundingSphere),Ka.applyMatrix4(s),Ka.radius+=n,t.ray.intersectsSphere(Ka)===!1)return;km.copy(s).invert(),cd.copy(t.ray).applyMatrix4(km);const a=n/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,h=i.index,c=i.attributes.position;if(h!==null){const d=Math.max(0,r.start),p=Math.min(h.count,r.start+r.count);for(let f=d,m=p;f<m;f++){const g=h.getX(f);tl.fromBufferAttribute(c,g),Gm(tl,g,l,s,t,e,this)}}else{const d=Math.max(0,r.start),p=Math.min(c.count,r.start+r.count);for(let f=d,m=p;f<m;f++)tl.fromBufferAttribute(c,f),Gm(tl,f,l,s,t,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}}function Gm(o,t,e,i,s,n,r){const a=cd.distanceSqToPoint(o);if(a<e){const l=new S;cd.closestPointToPoint(o,l),l.applyMatrix4(i);const h=s.ray.origin.distanceTo(l);if(h<s.near||h>s.far)return;n.push({distance:h,distanceToRay:Math.sqrt(a),point:l,index:t,face:null,object:r})}}class aD{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,s=this.getPoint(0),n=0;e.push(0);for(let r=1;r<=t;r++)i=this.getPoint(r/t),n+=i.distanceTo(s),e.push(n),s=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let s=0;const n=i.length;let r;e?r=e:r=t*i[n-1];let a=0,l=n-1,h;for(;a<=l;)if(s=Math.floor(a+(l-a)/2),h=i[s]-r,h<0)a=s+1;else if(h>0)l=s-1;else{l=s;break}if(s=l,i[s]===r)return s/(n-1);const u=i[s],d=i[s+1]-u,p=(r-u)/d;return(s+p)/(n-1)}getTangent(t,e){let s=t-1e-4,n=t+1e-4;s<0&&(s=0),n>1&&(n=1);const r=this.getPoint(s),a=this.getPoint(n),l=e||(r.isVector2?new wt:new S);return l.copy(a).sub(r).normalize(),l}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new S,s=[],n=[],r=[],a=new S,l=new ht;for(let p=0;p<=t;p++){const f=p/t;s[p]=this.getTangentAt(f,new S)}n[0]=new S,r[0]=new S;let h=Number.MAX_VALUE;const u=Math.abs(s[0].x),c=Math.abs(s[0].y),d=Math.abs(s[0].z);u<=h&&(h=u,i.set(1,0,0)),c<=h&&(h=c,i.set(0,1,0)),d<=h&&i.set(0,0,1),a.crossVectors(s[0],i).normalize(),n[0].crossVectors(s[0],a),r[0].crossVectors(s[0],n[0]);for(let p=1;p<=t;p++){if(n[p]=n[p-1].clone(),r[p]=r[p-1].clone(),a.crossVectors(s[p-1],s[p]),a.length()>Number.EPSILON){a.normalize();const f=Math.acos(Jt(s[p-1].dot(s[p]),-1,1));n[p].applyMatrix4(l.makeRotationAxis(a,f))}r[p].crossVectors(s[p],n[p])}if(e===!0){let p=Math.acos(Jt(n[0].dot(n[t]),-1,1));p/=t,s[0].dot(a.crossVectors(n[0],n[t]))>0&&(p=-p);for(let f=1;f<=t;f++)n[f].applyMatrix4(l.makeRotationAxis(s[f],p*f)),r[f].crossVectors(s[f],n[f])}return{tangents:s,normals:n,binormals:r}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}const nS={triangulate:function(o,t,e=2){const i=t&&t.length,s=i?t[0]*e:o.length;let n=t0(o,0,s,e,!0);const r=[];if(!n||n.next===n.prev)return r;let a,l,h,u,c,d,p;if(i&&(n=hS(o,t,n,e)),o.length>80*e){a=h=o[0],l=u=o[1];for(let f=e;f<s;f+=e)c=o[f],d=o[f+1],c<a&&(a=c),d<l&&(l=d),c>h&&(h=c),d>u&&(u=d);p=Math.max(h-a,u-l),p=p!==0?32767/p:0}return ea(n,r,e,a,l,p,0),r}};function t0(o,t,e,i,s){let n,r;if(s===MS(o,t,e,i)>0)for(n=t;n<e;n+=i)r=Wm(n,o[n],o[n+1],r);else for(n=e-i;n>=t;n-=i)r=Wm(n,o[n],o[n+1],r);return r&&Vh(r,r.next)&&(sa(r),r=r.next),r}function Mn(o,t){if(!o)return o;t||(t=o);let e=o,i;do if(i=!1,!e.steiner&&(Vh(e,e.next)||Ut(e.prev,e,e.next)===0)){if(sa(e),e=t=e.prev,e===e.next)break;i=!0}else e=e.next;while(i||e!==t);return t}function ea(o,t,e,i,s,n,r){if(!o)return;!r&&n&&fS(o,i,s,n);let a=o,l,h;for(;o.prev!==o.next;){if(l=o.prev,h=o.next,n?oS(o,i,s,n):rS(o)){t.push(l.i/e|0),t.push(o.i/e|0),t.push(h.i/e|0),sa(o),o=h.next,a=h.next;continue}if(o=h,o===a){r?r===1?(o=aS(Mn(o),t,e),ea(o,t,e,i,s,n,2)):r===2&&lS(o,t,e,i,s,n):ea(Mn(o),t,e,i,s,n,1);break}}}function rS(o){const t=o.prev,e=o,i=o.next;if(Ut(t,e,i)>=0)return!1;const s=t.x,n=e.x,r=i.x,a=t.y,l=e.y,h=i.y,u=s<n?s<r?s:r:n<r?n:r,c=a<l?a<h?a:h:l<h?l:h,d=s>n?s>r?s:r:n>r?n:r,p=a>l?a>h?a:h:l>h?l:h;let f=i.next;for(;f!==t;){if(f.x>=u&&f.x<=d&&f.y>=c&&f.y<=p&&Tr(s,a,n,l,r,h,f.x,f.y)&&Ut(f.prev,f,f.next)>=0)return!1;f=f.next}return!0}function oS(o,t,e,i){const s=o.prev,n=o,r=o.next;if(Ut(s,n,r)>=0)return!1;const a=s.x,l=n.x,h=r.x,u=s.y,c=n.y,d=r.y,p=a<l?a<h?a:h:l<h?l:h,f=u<c?u<d?u:d:c<d?c:d,m=a>l?a>h?a:h:l>h?l:h,g=u>c?u>d?u:d:c>d?c:d,y=dd(p,f,t,e,i),x=dd(m,g,t,e,i);let M=o.prevZ,_=o.nextZ;for(;M&&M.z>=y&&_&&_.z<=x;){if(M.x>=p&&M.x<=m&&M.y>=f&&M.y<=g&&M!==s&&M!==r&&Tr(a,u,l,c,h,d,M.x,M.y)&&Ut(M.prev,M,M.next)>=0||(M=M.prevZ,_.x>=p&&_.x<=m&&_.y>=f&&_.y<=g&&_!==s&&_!==r&&Tr(a,u,l,c,h,d,_.x,_.y)&&Ut(_.prev,_,_.next)>=0))return!1;_=_.nextZ}for(;M&&M.z>=y;){if(M.x>=p&&M.x<=m&&M.y>=f&&M.y<=g&&M!==s&&M!==r&&Tr(a,u,l,c,h,d,M.x,M.y)&&Ut(M.prev,M,M.next)>=0)return!1;M=M.prevZ}for(;_&&_.z<=x;){if(_.x>=p&&_.x<=m&&_.y>=f&&_.y<=g&&_!==s&&_!==r&&Tr(a,u,l,c,h,d,_.x,_.y)&&Ut(_.prev,_,_.next)>=0)return!1;_=_.nextZ}return!0}function aS(o,t,e){let i=o;do{const s=i.prev,n=i.next.next;!Vh(s,n)&&e0(s,i,i.next,n)&&ia(s,n)&&ia(n,s)&&(t.push(s.i/e|0),t.push(i.i/e|0),t.push(n.i/e|0),sa(i),sa(i.next),i=o=n),i=i.next}while(i!==o);return Mn(i)}function lS(o,t,e,i,s,n){let r=o;do{let a=r.next.next;for(;a!==r.prev;){if(r.i!==a.i&&yS(r,a)){let l=i0(r,a);r=Mn(r,r.next),l=Mn(l,l.next),ea(r,t,e,i,s,n,0),ea(l,t,e,i,s,n,0);return}a=a.next}r=r.next}while(r!==o)}function hS(o,t,e,i){const s=[];let n,r,a,l,h;for(n=0,r=t.length;n<r;n++)a=t[n]*i,l=n<r-1?t[n+1]*i:o.length,h=t0(o,a,l,i,!1),h===h.next&&(h.steiner=!0),s.push(gS(h));for(s.sort(uS),n=0;n<s.length;n++)e=cS(s[n],e);return e}function uS(o,t){return o.x-t.x}function cS(o,t){const e=dS(o,t);if(!e)return t;const i=i0(e,o);return Mn(i,i.next),Mn(e,e.next)}function dS(o,t){let e=t,i=-1/0,s;const n=o.x,r=o.y;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const d=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=n&&d>i&&(i=d,s=e.x<e.next.x?e:e.next,d===n))return s}e=e.next}while(e!==t);if(!s)return null;const a=s,l=s.x,h=s.y;let u=1/0,c;e=s;do n>=e.x&&e.x>=l&&n!==e.x&&Tr(r<h?n:i,r,l,h,r<h?i:n,r,e.x,e.y)&&(c=Math.abs(r-e.y)/(n-e.x),ia(e,o)&&(c<u||c===u&&(e.x>s.x||e.x===s.x&&pS(s,e)))&&(s=e,u=c)),e=e.next;while(e!==a);return s}function pS(o,t){return Ut(o.prev,o,t.prev)<0&&Ut(t.next,o,o.next)<0}function fS(o,t,e,i){let s=o;do s.z===0&&(s.z=dd(s.x,s.y,t,e,i)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==o);s.prevZ.nextZ=null,s.prevZ=null,mS(s)}function mS(o){let t,e,i,s,n,r,a,l,h=1;do{for(e=o,o=null,n=null,r=0;e;){for(r++,i=e,a=0,t=0;t<h&&(a++,i=i.nextZ,!!i);t++);for(l=h;a>0||l>0&&i;)a!==0&&(l===0||!i||e.z<=i.z)?(s=e,e=e.nextZ,a--):(s=i,i=i.nextZ,l--),n?n.nextZ=s:o=s,s.prevZ=n,n=s;e=i}n.nextZ=null,h*=2}while(r>1);return o}function dd(o,t,e,i,s){return o=(o-e)*s|0,t=(t-i)*s|0,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,o|t<<1}function gS(o){let t=o,e=o;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==o);return e}function Tr(o,t,e,i,s,n,r,a){return(s-r)*(t-a)>=(o-r)*(n-a)&&(o-r)*(i-a)>=(e-r)*(t-a)&&(e-r)*(n-a)>=(s-r)*(i-a)}function yS(o,t){return o.next.i!==t.i&&o.prev.i!==t.i&&!xS(o,t)&&(ia(o,t)&&ia(t,o)&&_S(o,t)&&(Ut(o.prev,o,t.prev)||Ut(o,t.prev,t))||Vh(o,t)&&Ut(o.prev,o,o.next)>0&&Ut(t.prev,t,t.next)>0)}function Ut(o,t,e){return(t.y-o.y)*(e.x-t.x)-(t.x-o.x)*(e.y-t.y)}function Vh(o,t){return o.x===t.x&&o.y===t.y}function e0(o,t,e,i){const s=il(Ut(o,t,e)),n=il(Ut(o,t,i)),r=il(Ut(e,i,o)),a=il(Ut(e,i,t));return!!(s!==n&&r!==a||s===0&&el(o,e,t)||n===0&&el(o,i,t)||r===0&&el(e,o,i)||a===0&&el(e,t,i))}function el(o,t,e){return t.x<=Math.max(o.x,e.x)&&t.x>=Math.min(o.x,e.x)&&t.y<=Math.max(o.y,e.y)&&t.y>=Math.min(o.y,e.y)}function il(o){return o>0?1:o<0?-1:0}function xS(o,t){let e=o;do{if(e.i!==o.i&&e.next.i!==o.i&&e.i!==t.i&&e.next.i!==t.i&&e0(e,e.next,o,t))return!0;e=e.next}while(e!==o);return!1}function ia(o,t){return Ut(o.prev,o,o.next)<0?Ut(o,t,o.next)>=0&&Ut(o,o.prev,t)>=0:Ut(o,t,o.prev)<0||Ut(o,o.next,t)<0}function _S(o,t){let e=o,i=!1;const s=(o.x+t.x)/2,n=(o.y+t.y)/2;do e.y>n!=e.next.y>n&&e.next.y!==e.y&&s<(e.next.x-e.x)*(n-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==o);return i}function i0(o,t){const e=new pd(o.i,o.x,o.y),i=new pd(t.i,t.x,t.y),s=o.next,n=t.prev;return o.next=t,t.prev=o,e.next=s,s.prev=e,i.next=e,e.prev=i,n.next=i,i.prev=n,i}function Wm(o,t,e,i){const s=new pd(o,t,e);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function sa(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function pd(o,t,e){this.i=o,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function MS(o,t,e,i){let s=0;for(let n=t,r=e-i;n<e;n+=i)s+=(o[r]-o[n])*(o[n+1]+o[r+1]),r=n;return s}class s0{static area(t){const e=t.length;let i=0;for(let s=e-1,n=0;n<e;s=n++)i+=t[s].x*t[n].y-t[n].x*t[s].y;return i*.5}static isClockWise(t){return s0.area(t)<0}static triangulateShape(t,e){const i=[],s=[],n=[];Hm(t),$m(i,t);let r=t.length;e.forEach(Hm);for(let l=0;l<e.length;l++)s.push(r),r+=e[l].length,$m(i,e[l]);const a=nS.triangulate(i,s);for(let l=0;l<a.length;l+=3)n.push(a.slice(l,l+3));return n}}function Hm(o){const t=o.length;t>2&&o[t-1].equals(o[0])&&o.pop()}function $m(o,t){for(let e=0;e<t.length;e++)o.push(t[e].x),o.push(t[e].y)}let vS=class extends fs{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new lt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ca,this.normalScale=new wt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ps,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}},hD=class extends vS{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new wt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Jt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new lt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new lt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new lt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}},cD=class extends fs{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new lt(16777215),this.specular=new lt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ca,this.normalScale=new wt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ps,this.combine=xp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}},pD=class extends fs{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new lt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ca,this.normalScale=new wt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ps,this.combine=xp,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}};function sl(o,t,e){return!o||!e&&o.constructor===t?o:typeof t.BYTES_PER_ELEMENT=="number"?new t(o):Array.prototype.slice.call(o)}function TS(o){return ArrayBuffer.isView(o)&&!(o instanceof DataView)}function bS(o){function t(s,n){return o[s]-o[n]}const e=o.length,i=new Array(e);for(let s=0;s!==e;++s)i[s]=s;return i.sort(t),i}function qm(o,t,e){const i=o.length,s=new o.constructor(i);for(let n=0,r=0;r!==i;++n){const a=e[n]*t;for(let l=0;l!==t;++l)s[r++]=o[a+l]}return s}function n0(o,t,e,i){let s=1,n=o[0];for(;n!==void 0&&n[i]===void 0;)n=o[s++];if(n===void 0)return;let r=n[i];if(r!==void 0)if(Array.isArray(r))do r=n[i],r!==void 0&&(t.push(n.time),e.push.apply(e,r)),n=o[s++];while(n!==void 0);else if(r.toArray!==void 0)do r=n[i],r!==void 0&&(t.push(n.time),r.toArray(e,e.length)),n=o[s++];while(n!==void 0);else do r=n[i],r!==void 0&&(t.push(n.time),e.push(r)),n=o[s++];while(n!==void 0)}let kh=class{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],n=e[i-1];i:{t:{let r;e:{s:if(!(t<s)){for(let a=i+2;;){if(s===void 0){if(t<n)break s;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(n=s,s=e[++i],t<s)break t}r=e.length;break e}if(!(t>=n)){const a=e[1];t<a&&(i=2,n=a);for(let l=i-2;;){if(n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(s=n,n=e[--i-1],t>=n)break t}r=i,i=0;break e}break i}for(;i<r;){const a=i+r>>>1;t<e[a]?r=a:i=a+1}if(s=e[i],n=e[i-1],n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,n,s)}return this.interpolate_(i,n,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,n=t*s;for(let r=0;r!==s;++r)e[r]=i[n+r];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}},SS=class extends kh{constructor(t,e,i,s){super(t,e,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:em,endingEnd:em}}intervalChanged_(t,e,i){const s=this.parameterPositions;let n=t-2,r=t+1,a=s[n],l=s[r];if(a===void 0)switch(this.getSettings_().endingStart){case im:n=t,a=2*e-i;break;case sm:n=s.length-2,a=e+s[n]-s[n+1];break;default:n=t,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case im:r=t,l=2*i-e;break;case sm:r=1,l=i+s[1]-s[0];break;default:r=t-1,l=e}const h=(i-e)*.5,u=this.valueSize;this._weightPrev=h/(e-a),this._weightNext=h/(l-i),this._offsetPrev=n*u,this._offsetNext=r*u}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,l=t*a,h=l-a,u=this._offsetPrev,c=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(i-e)/(s-e),m=f*f,g=m*f,y=-d*g+2*d*m-d*f,x=(1+d)*g+(-1.5-2*d)*m+(-.5+d)*f+1,M=(-1-p)*g+(1.5+p)*m+.5*f,_=p*g-p*m;for(let v=0;v!==a;++v)n[v]=y*r[u+v]+x*r[h+v]+M*r[l+v]+_*r[c+v];return n}},wS=class extends kh{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,l=t*a,h=l-a,u=(i-e)/(s-e),c=1-u;for(let d=0;d!==a;++d)n[d]=r[h+d]*c+r[l+d]*u;return n}},AS=class extends kh{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}},ki=class{constructor(t,e,i,s){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=sl(e,this.TimeBufferType),this.values=sl(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:sl(t.times,Array),values:sl(t.values,Array)};const s=t.getInterpolation();s!==t.DefaultInterpolation&&(i.interpolation=s)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new AS(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new wS(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new SS(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case sh:e=this.InterpolantFactoryMethodDiscrete;break;case nd:e=this.InterpolantFactoryMethodLinear;break;case du:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return sh;case this.InterpolantFactoryMethodLinear:return nd;case this.InterpolantFactoryMethodSmooth:return du}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let n=0,r=s-1;for(;n!==s&&i[n]<t;)++n;for(;r!==-1&&i[r]>e;)--r;if(++r,n!==0||r!==s){n>=r&&(r=Math.max(r,1),n=r-1);const a=this.getValueSize();this.times=i.slice(n,r),this.values=this.values.slice(n*a,r*a)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,n=i.length;n===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let r=null;for(let a=0;a!==n;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),t=!1;break}if(r!==null&&r>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,r),t=!1;break}r=l}if(s!==void 0&&TS(s))for(let a=0,l=s.length;a!==l;++a){const h=s[a];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,h),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),i=this.getValueSize(),s=this.getInterpolation()===du,n=t.length-1;let r=1;for(let a=1;a<n;++a){let l=!1;const h=t[a],u=t[a+1];if(h!==u&&(a!==1||h!==t[0]))if(s)l=!0;else{const c=a*i,d=c-i,p=c+i;for(let f=0;f!==i;++f){const m=e[c+f];if(m!==e[d+f]||m!==e[p+f]){l=!0;break}}}if(l){if(a!==r){t[r]=t[a];const c=a*i,d=r*i;for(let p=0;p!==i;++p)e[d+p]=e[c+p]}++r}}if(n>0){t[r]=t[n];for(let a=n*i,l=r*i,h=0;h!==i;++h)e[l+h]=e[a+h];++r}return r!==t.length?(this.times=t.slice(0,r),this.values=e.slice(0,r*i)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),i=this.constructor,s=new i(this.name,t,e);return s.createInterpolant=this.createInterpolant,s}};ki.prototype.TimeBufferType=Float32Array;ki.prototype.ValueBufferType=Float32Array;ki.prototype.DefaultInterpolation=nd;let to=class extends ki{constructor(t,e,i){super(t,e,i)}};to.prototype.ValueTypeName="bool";to.prototype.ValueBufferType=Array;to.prototype.DefaultInterpolation=sh;to.prototype.InterpolantFactoryMethodLinear=void 0;to.prototype.InterpolantFactoryMethodSmooth=void 0;let r0=class extends ki{};r0.prototype.ValueTypeName="color";let oh=class extends ki{};oh.prototype.ValueTypeName="number";let NS=class extends kh{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,l=(i-e)/(s-e);let h=t*a;for(let u=h+a;h!==u;h+=4)rt.slerpFlat(n,0,r,h-a,r,h,l);return n}},Gh=class extends ki{InterpolantFactoryMethodLinear(t){return new NS(this.times,this.values,this.getValueSize(),t)}};Gh.prototype.ValueTypeName="quaternion";Gh.prototype.InterpolantFactoryMethodSmooth=void 0;let eo=class extends ki{constructor(t,e,i){super(t,e,i)}};eo.prototype.ValueTypeName="string";eo.prototype.ValueBufferType=Array;eo.prototype.DefaultInterpolation=sh;eo.prototype.InterpolantFactoryMethodLinear=void 0;eo.prototype.InterpolantFactoryMethodSmooth=void 0;let ah=class extends ki{};ah.prototype.ValueTypeName="vector";let ND=class{constructor(t="",e=-1,i=[],s=ob){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=Si(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let r=0,a=i.length;r!==a;++r)e.push(ES(i[r]).scale(s));const n=new this(t.name,t.duration,e,t.blendMode);return n.uuid=t.uuid,n}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let n=0,r=i.length;n!==r;++n)e.push(ki.toJSON(i[n]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const n=e.length,r=[];for(let a=0;a<n;a++){let l=[],h=[];l.push((a+n-1)%n,a,(a+1)%n),h.push(0,1,0);const u=bS(l);l=qm(l,1,u),h=qm(h,1,u),!s&&l[0]===0&&(l.push(n),h.push(h[0])),r.push(new oh(".morphTargetInfluences["+e[a].name+"]",l,h).scale(1/i))}return new this(t,-1,r)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const s=t;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===e)return i[s];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},n=/^([\w-]*?)([\d]+)$/;for(let a=0,l=t.length;a<l;a++){const h=t[a],u=h.name.match(n);if(u&&u.length>1){const c=u[1];let d=s[c];d||(s[c]=d=[]),d.push(h)}}const r=[];for(const a in s)r.push(this.CreateFromMorphTargetSequence(a,s[a],e,i));return r}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(c,d,p,f,m){if(p.length!==0){const g=[],y=[];n0(p,g,y,f),g.length!==0&&m.push(new c(d,g,y))}},s=[],n=t.name||"default",r=t.fps||30,a=t.blendMode;let l=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const d=h[c].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let m=0;m<d[f].morphTargets.length;m++)p[d[f].morphTargets[m]]=-1;for(const m in p){const g=[],y=[];for(let x=0;x!==d[f].morphTargets.length;++x){const M=d[f];g.push(M.time),y.push(M.morphTarget===m?1:0)}s.push(new oh(".morphTargetInfluence["+m+"]",g,y))}l=p.length*r}else{const p=".bones["+e[c].name+"]";i(ah,p+".position",d,"pos",s),i(Gh,p+".quaternion",d,"rot",s),i(ah,p+".scale",d,"scl",s)}}return s.length===0?null:new this(n,l,s,a)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,s=t.length;i!==s;++i){const n=this.tracks[i];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}};function RS(o){switch(o.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return oh;case"vector":case"vector2":case"vector3":case"vector4":return ah;case"color":return r0;case"quaternion":return Gh;case"bool":case"boolean":return to;case"string":return eo}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+o)}function ES(o){if(o.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=RS(o.type);if(o.times===void 0){const e=[],i=[];n0(o.keys,e,i,"value"),o.times=e,o.values=i}return t.parse!==void 0?t.parse(o):new t(o.name,o.times,o.values,o.interpolation)}const Ds={enabled:!1,files:{},add:function(o,t){this.enabled!==!1&&(this.files[o]=t)},get:function(o){if(this.enabled!==!1)return this.files[o]},remove:function(o){delete this.files[o]},clear:function(){this.files={}}};class CS{constructor(t,e,i){const s=this;let n=!1,r=0,a=0,l;const h=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(u){a++,n===!1&&s.onStart!==void 0&&s.onStart(u,r,a),n=!0},this.itemEnd=function(u){r++,s.onProgress!==void 0&&s.onProgress(u,r,a),r===a&&(n=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(u){s.onError!==void 0&&s.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,c){return h.push(u,c),this},this.removeHandler=function(u){const c=h.indexOf(u);return c!==-1&&h.splice(c,2),this},this.getHandler=function(u){for(let c=0,d=h.length;c<d;c+=2){const p=h[c],f=h[c+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const PS=new CS;class fa{constructor(t){this.manager=t!==void 0?t:PS,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(s,n){i.load(t,s,e,n)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}fa.DEFAULT_MATERIAL_NAME="__DEFAULT";const Yi={};class FS extends Error{constructor(t,e){super(t),this.response=e}}class ED extends fa{constructor(t){super(t)}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=Ds.get(t);if(n!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(n),this.manager.itemEnd(t)},0),n;if(Yi[t]!==void 0){Yi[t].push({onLoad:e,onProgress:i,onError:s});return}Yi[t]=[],Yi[t].push({onLoad:e,onProgress:i,onError:s});const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(r).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||h.body===void 0||h.body.getReader===void 0)return h;const u=Yi[t],c=h.body.getReader(),d=h.headers.get("X-File-Size")||h.headers.get("Content-Length"),p=d?parseInt(d):0,f=p!==0;let m=0;const g=new ReadableStream({start(y){x();function x(){c.read().then(({done:M,value:_})=>{if(M)y.close();else{m+=_.byteLength;const v=new ProgressEvent("progress",{lengthComputable:f,loaded:m,total:p});for(let A=0,T=u.length;A<T;A++){const w=u[A];w.onProgress&&w.onProgress(v)}y.enqueue(_),x()}},M=>{y.error(M)})}}});return new Response(g)}else throw new FS(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`,h)}).then(h=>{switch(l){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return h.json();default:if(a===void 0)return h.text();{const c=/charset="?([^;"\s]*)"?/i.exec(a),d=c&&c[1]?c[1].toLowerCase():void 0,p=new TextDecoder(d);return h.arrayBuffer().then(f=>p.decode(f))}}}).then(h=>{Ds.add(t,h);const u=Yi[t];delete Yi[t];for(let c=0,d=u.length;c<d;c++){const p=u[c];p.onLoad&&p.onLoad(h)}}).catch(h=>{const u=Yi[t];if(u===void 0)throw this.manager.itemError(t),h;delete Yi[t];for(let c=0,d=u.length;c<d;c++){const p=u[c];p.onError&&p.onError(h)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class o0 extends fa{constructor(t){super(t)}load(t,e,i,s){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=Ds.get(t);if(r!==void 0)return n.manager.itemStart(t),setTimeout(function(){e&&e(r),n.manager.itemEnd(t)},0),r;const a=ld("img");function l(){u(),Ds.add(t,this),e&&e(this),n.manager.itemEnd(t)}function h(c){u(),s&&s(c),n.manager.itemError(t),n.manager.itemEnd(t)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",h,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",h,!1),t.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),n.manager.itemStart(t),a.src=t,a}}class CD extends fa{constructor(t){super(t)}load(t,e,i,s){const n=new da,r=new o0(this.manager);return r.setCrossOrigin(this.crossOrigin),r.setPath(this.path),r.load(t,function(a){n.image=a,n.needsUpdate=!0,e!==void 0&&e(n)},i,s),n}}let Wh=class extends Xt{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new lt(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(e.object.target=this.target.uuid),e}};const Bu=new ht,jm=new S,Xm=new S;let Sp=class{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new wt(512,512),this.map=null,this.mapPass=null,this.matrix=new ht,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Zb,this._frameExtents=new wt(1,1),this._viewportCount=1,this._viewports=[new Fi(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;jm.setFromMatrixPosition(t.matrixWorld),e.position.copy(jm),Xm.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Xm),e.updateMatrixWorld(),Bu.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Bu),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(Bu)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}},IS=class extends Sp{constructor(){super(new Qx(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=Jo*2*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,n=t.distance||e.far;(i!==e.fov||s!==e.aspect||n!==e.far)&&(e.fov=i,e.aspect=s,e.far=n,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}},BD=class extends Wh{constructor(t,e,i=0,s=Math.PI/3,n=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Xt.DEFAULT_UP),this.updateMatrix(),this.target=new Xt,this.distance=i,this.angle=s,this.penumbra=n,this.decay=r,this.map=null,this.shadow=new IS}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}};const Ym=new ht,Mo=new S,Lu=new S;let BS=class extends Sp{constructor(){super(new Qx(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new wt(4,2),this._viewportCount=6,this._viewports=[new Fi(2,1,1,1),new Fi(0,1,1,1),new Fi(3,1,1,1),new Fi(1,1,1,1),new Fi(3,0,1,1),new Fi(1,0,1,1)],this._cubeDirections=[new S(1,0,0),new S(-1,0,0),new S(0,0,1),new S(0,0,-1),new S(0,1,0),new S(0,-1,0)],this._cubeUps=[new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,1,0),new S(0,0,1),new S(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,n=t.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),Mo.setFromMatrixPosition(t.matrixWorld),i.position.copy(Mo),Lu.copy(i.position),Lu.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(Lu),i.updateMatrixWorld(),s.makeTranslation(-Mo.x,-Mo.y,-Mo.z),Ym.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ym)}},DD=class extends Wh{constructor(t,e,i=0,s=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new BS}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}},LS=class extends Sp{constructor(){super(new Qb(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}},VD=class extends Wh{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Xt.DEFAULT_UP),this.updateMatrix(),this.target=new Xt,this.shadow=new LS}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}},GD=class extends Wh{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}};class HD{static decodeText(t){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(t);let e="";for(let i=0,s=t.length;i<s;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.slice(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class $D extends fa{constructor(t){super(t),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const n=this,r=Ds.get(t);if(r!==void 0){if(n.manager.itemStart(t),r.then){r.then(h=>{e&&e(h),n.manager.itemEnd(t)}).catch(h=>{s&&s(h)});return}return setTimeout(function(){e&&e(r),n.manager.itemEnd(t)},0),r}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader;const l=fetch(t,a).then(function(h){return h.blob()}).then(function(h){return createImageBitmap(h,Object.assign(n.options,{colorSpaceConversion:"none"}))}).then(function(h){return Ds.add(t,h),e&&e(h),n.manager.itemEnd(t),h}).catch(function(h){s&&s(h),Ds.remove(t),n.manager.itemError(t),n.manager.itemEnd(t)});Ds.add(t,l),n.manager.itemStart(t)}}const wp="\\[\\]\\.:\\/",US=new RegExp("["+wp+"]","g"),Ap="[^"+wp+"]",DS="[^"+wp.replace("\\.","")+"]",OS=/((?:WC+[\/:])*)/.source.replace("WC",Ap),zS=/(WCOD+)?/.source.replace("WCOD",DS),VS=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Ap),kS=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Ap),GS=new RegExp("^"+OS+zS+VS+kS+"$"),WS=["material","materials","bones","map"];let HS=class{constructor(t,e,i){const s=i||Ot.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,s)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];s!==void 0&&s.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,n=i.length;s!==n;++s)i[s].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}},Ot=class _r{constructor(t,e,i){this.path=e,this.parsedPath=i||_r.parseTrackName(e),this.node=_r.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new _r.Composite(t,e,i):new _r(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(US,"")}static parseTrackName(t){const e=GS.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const n=i.nodeName.substring(s+1);WS.indexOf(n)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=n)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(n){for(let r=0;r<n.length;r++){const a=n[r];if(a.name===e||a.uuid===e)return a;const l=i(a.children);if(l)return l}return null},s=i(t.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)t[e++]=i[s]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,s=e.propertyName;let n=e.propertyIndex;if(t||(t=_r.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let h=e.objectIndex;switch(i){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let u=0;u<t.length;u++)if(t[u].name===h){h=u;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[i]}if(h!==void 0){if(t[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[h]}}const r=t[s];if(r===void 0){const h=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+s+" but it wasn't found.",t);return}let a=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(n!==void 0){if(s==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[n]!==void 0&&(n=t.morphTargetDictionary[n])}l=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=n}else r.fromArray!==void 0&&r.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(l=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=s;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}};Ot.Composite=HS;Ot.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ot.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ot.prototype.GetterByBindingType=[Ot.prototype._getValue_direct,Ot.prototype._getValue_array,Ot.prototype._getValue_arrayElement,Ot.prototype._getValue_toArray];Ot.prototype.SetterByBindingTypeAndVersioning=[[Ot.prototype._setValue_direct,Ot.prototype._setValue_direct_setNeedsUpdate,Ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ot.prototype._setValue_array,Ot.prototype._setValue_array_setNeedsUpdate,Ot.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ot.prototype._setValue_arrayElement,Ot.prototype._setValue_arrayElement_setNeedsUpdate,Ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ot.prototype._setValue_fromArray,Ot.prototype._setValue_fromArray_setNeedsUpdate,Ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Zm{constructor(t,e,i,s,n){this.isGLBufferAttribute=!0,this.name="",this.buffer=t,this.type=e,this.itemSize=i,this.elementSize=s,this.count=n,this.version=0}set needsUpdate(t){t===!0&&this.version++}setBuffer(t){return this.buffer=t,this}setType(t,e){return this.type=t,this.elementSize=e,this}setItemSize(t){return this.itemSize=t,this}setCount(t){return this.count=t,this}}class $S extends zh{constructor(t=1){const e=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new Ke;s.setAttribute("position",new Ko(e,3)),s.setAttribute("color",new Ko(i,3));const n=new Kr({vertexColors:!0,toneMapped:!1});super(s,n),this.type="AxesHelper"}setColors(t,e,i){const s=new lt,n=this.geometry.attributes.color.array;return s.set(t),s.toArray(n,0),s.toArray(n,3),s.set(e),s.toArray(n,6),s.toArray(n,9),s.set(i),s.toArray(n,12),s.toArray(n,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ni}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ni);/*!
 * @pixiv/three-vrm-materials-mtoon v3.4.1
 * MToon (toon material) module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */var qS=Object.defineProperty,Qm=Object.getOwnPropertySymbols,jS=Object.prototype.hasOwnProperty,XS=Object.prototype.propertyIsEnumerable,Jm=(o,t,e)=>t in o?qS(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,Km=(o,t)=>{for(var e in t||(t={}))jS.call(t,e)&&Jm(o,e,t[e]);if(Qm)for(var e of Qm(t))XS.call(t,e)&&Jm(o,e,t[e]);return o},mn=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),YS={"":3e3,srgb:3001};function ZS(o,t){parseInt(Ni,10)>=152?o.colorSpace=t:o.encoding=YS[t]}var QS=class{get pending(){return Promise.all(this._pendings)}constructor(t,e){this._parser=t,this._materialParams=e,this._pendings=[]}assignPrimitive(t,e){e!=null&&(this._materialParams[t]=e)}assignColor(t,e,i){e!=null&&(this._materialParams[t]=new lt().fromArray(e),i&&this._materialParams[t].convertSRGBToLinear())}assignTexture(t,e,i){return mn(this,null,function*(){const s=mn(this,null,function*(){e!=null&&(yield this._parser.assignTexture(this._materialParams,t,e),i&&ZS(this._materialParams[t],"srgb"))});return this._pendings.push(s),s})}assignTextureByIndex(t,e,i){return mn(this,null,function*(){return this.assignTexture(t,e!=null?{index:e}:void 0,i)})}},JS=`// #define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif

#include <common>

// #include <uv_pars_vertex>
#ifdef MTOON_USE_UV
  varying vec2 vUv;

  // COMPAT: pre-r151 uses a common uvTransform
  #if THREE_VRM_THREE_REVISION < 151
    uniform mat3 uvTransform;
  #endif
#endif

// #include <uv2_pars_vertex>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
    uniform mat3 uv2Transform;
  #endif
#endif

// #include <displacementmap_pars_vertex>
// #include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
  uniform sampler2D outlineWidthMultiplyTexture;
  uniform mat3 outlineWidthMultiplyTextureUvTransform;
#endif

uniform float outlineWidthFactor;

void main() {

  // #include <uv_vertex>
  #ifdef MTOON_USE_UV
    // COMPAT: pre-r151 uses a common uvTransform
    #if THREE_VRM_THREE_REVISION >= 151
      vUv = uv;
    #else
      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    #endif
  #endif

  // #include <uv2_vertex>
  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap
  #if THREE_VRM_THREE_REVISION < 151
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
    #endif
  #endif

  #include <color_vertex>

  #include <beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>

  // we need this to compute the outline properly
  objectNormal = normalize( objectNormal );

  #include <defaultnormal_vertex>

  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
    vNormal = normalize( transformedNormal );
  #endif

  #include <begin_vertex>

  #include <morphtarget_vertex>
  #include <skinning_vertex>
  // #include <displacementmap_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>

  vViewPosition = - mvPosition.xyz;

  #ifdef OUTLINE
    float worldNormalLength = length( transformedNormal );
    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;

    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;
      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;
      outlineOffset *= outlineTex;
    #endif

    #ifdef OUTLINE_WIDTH_SCREEN
      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );

    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic
  #endif

  #include <worldpos_vertex>
  // #include <envmap_vertex>
  #include <shadowmap_vertex>
  #include <fog_vertex>

}`,KS=`// #define PHONG

uniform vec3 litFactor;

uniform float opacity;

uniform vec3 shadeColorFactor;
#ifdef USE_SHADEMULTIPLYTEXTURE
  uniform sampler2D shadeMultiplyTexture;
  uniform mat3 shadeMultiplyTextureUvTransform;
#endif

uniform float shadingShiftFactor;
uniform float shadingToonyFactor;

#ifdef USE_SHADINGSHIFTTEXTURE
  uniform sampler2D shadingShiftTexture;
  uniform mat3 shadingShiftTextureUvTransform;
  uniform float shadingShiftTextureScale;
#endif

uniform float giEqualizationFactor;

uniform vec3 parametricRimColorFactor;
#ifdef USE_RIMMULTIPLYTEXTURE
  uniform sampler2D rimMultiplyTexture;
  uniform mat3 rimMultiplyTextureUvTransform;
#endif
uniform float rimLightingMixFactor;
uniform float parametricRimFresnelPowerFactor;
uniform float parametricRimLiftFactor;

#ifdef USE_MATCAPTEXTURE
  uniform vec3 matcapFactor;
  uniform sampler2D matcapTexture;
  uniform mat3 matcapTextureUvTransform;
#endif

uniform vec3 emissive;
uniform float emissiveIntensity;

uniform vec3 outlineColorFactor;
uniform float outlineLightingMixFactor;

#ifdef USE_UVANIMATIONMASKTEXTURE
  uniform sampler2D uvAnimationMaskTexture;
  uniform mat3 uvAnimationMaskTextureUvTransform;
#endif

uniform float uvAnimationScrollXOffset;
uniform float uvAnimationScrollYOffset;
uniform float uvAnimationRotationPhase;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>

// #include <uv_pars_fragment>
#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
  varying vec2 vUv;
#endif

// #include <uv2_pars_fragment>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
  #endif
#endif

#include <map_pars_fragment>

#ifdef USE_MAP
  uniform mat3 mapUvTransform;
#endif

// #include <alphamap_pars_fragment>

#include <alphatest_pars_fragment>

#include <aomap_pars_fragment>
// #include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>

#ifdef USE_EMISSIVEMAP
  uniform mat3 emissiveMapUvTransform;
#endif

// #include <envmap_common_pars_fragment>
// #include <envmap_pars_fragment>
// #include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>

// #include <bsdfs>
// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>
#if THREE_VRM_THREE_REVISION < 151
  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
    return RECIPROCAL_PI * diffuseColor;
  }
#endif

#include <lights_pars_begin>

#include <normal_pars_fragment>

// #include <lights_phong_pars_fragment>
varying vec3 vViewPosition;

struct MToonMaterial {
  vec3 diffuseColor;
  vec3 shadeColor;
  float shadingShift;
};

float linearstep( float a, float b, float t ) {
  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );
}

/**
 * Convert NdotL into toon shading factor using shadingShift and shadingToony
 */
float getShading(
  const in float dotNL,
  const in float shadow,
  const in float shadingShift
) {
  float shading = dotNL;
  shading = shading + shadingShift;
  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );
  shading *= shadow;
  return shading;
}

/**
 * Mix diffuseColor and shadeColor using shading factor and light color
 */
vec3 getDiffuse(
  const in MToonMaterial material,
  const in float shading,
  in vec3 lightColor
) {
  #ifdef DEBUG_LITSHADERATE
    return vec3( BRDF_Lambert( shading * lightColor ) );
  #endif

  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );

  // The "comment out if you want to PBR absolutely" line
  #ifdef V0_COMPAT_SHADE
    col = min( col, material.diffuseColor );
  #endif

  return col;
}

// COMPAT: pre-r156 uses a struct GeometricContext
#if THREE_VRM_THREE_REVISION >= 157
  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#else
  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#endif

#define RE_Direct RE_Direct_MToon
#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon
#define Material_LightProbeLOD( material ) (0)

#include <shadowmap_pars_fragment>
// #include <bumpmap_pars_fragment>

// #include <normalmap_pars_fragment>
#ifdef USE_NORMALMAP

  uniform sampler2D normalMap;
  uniform mat3 normalMapUvTransform;
  uniform vec2 normalScale;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

  uniform mat3 normalMatrix;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )

  // Per-Pixel Tangent Space Normal Mapping
  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

  // three-vrm specific change: it requires \`uv\` as an input in order to support uv scrolls

  // Temporary compat against shader change @ Three.js r126, r151
  #if THREE_VRM_THREE_REVISION >= 151

    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

      vec3 q0 = dFdx( eye_pos.xyz );
      vec3 q1 = dFdy( eye_pos.xyz );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = surf_norm;

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

      return mat3( T * scale, B * scale, N );

    }

  #else

    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = normalize( surf_norm );

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0
      // TODO: Is this still required? Or shall I make a PR about it?
      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {
        return surf_norm;
      }

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

    }

  #endif

#endif

// #include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// == post correction ==========================================================
void postCorrection() {
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
  #include <dithering_fragment>
}

// == main procedure ===========================================================
void main() {
  #include <clipping_planes_fragment>

  vec2 uv = vec2(0.5, 0.5);

  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
    uv = vUv;

    float uvAnimMask = 1.0;
    #ifdef USE_UVANIMATIONMASKTEXTURE
      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;
      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;
    #endif

    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );
    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );
    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;
    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;
  #endif

  #ifdef DEBUG_UV
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
      gl_FragColor = vec4( uv, 0.0, 1.0 );
    #endif
    return;
  #endif

  vec4 diffuseColor = vec4( litFactor, opacity );
  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;

  #include <logdepthbuf_fragment>

  // #include <map_fragment>
  #ifdef USE_MAP
    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;
    vec4 sampledDiffuseColor = texture2D( map, mapUv );
    #ifdef DECODE_VIDEO_TEXTURE
      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
    #endif
    diffuseColor *= sampledDiffuseColor;
  #endif

  // #include <color_fragment>
  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    diffuseColor.rgb *= vColor;
  #endif

  // #include <alphamap_fragment>

  #include <alphatest_fragment>

  // #include <specularmap_fragment>

  // #include <normal_fragment_begin>
  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;

  #ifdef FLAT_SHADED

    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );

  #else

    vec3 normal = normalize( vNormal );

    #ifdef DOUBLE_SIDED

      normal *= faceDirection;

    #endif

  #endif

  #ifdef USE_NORMALMAP

    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;

  #endif

  #ifdef USE_NORMALMAP_TANGENTSPACE

    #ifdef USE_TANGENT

      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn[0] *= faceDirection;
      tbn[1] *= faceDirection;

    #endif

  #endif

  #ifdef USE_CLEARCOAT_NORMALMAP

    #ifdef USE_TANGENT

      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn2[0] *= faceDirection;
      tbn2[1] *= faceDirection;

    #endif

  #endif

  // non perturbed normal for clearcoat among others

  vec3 nonPerturbedNormal = normal;

  #ifdef OUTLINE
    normal *= -1.0;
  #endif

  // #include <normal_fragment_maps>

  // COMPAT: pre-r151
  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

    #ifdef FLIP_SIDED

      normal = - normal;

    #endif

    #ifdef DOUBLE_SIDED

      normal = normal * faceDirection;

    #endif

    normal = normalize( normalMatrix * normal );

  // COMPAT: pre-r151
  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )

    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;

    // COMPAT: pre-r151
    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )

      normal = normalize( tbn * mapN );

    #else

      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );

    #endif

  #endif

  // #include <emissivemap_fragment>
  #ifdef USE_EMISSIVEMAP
    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;
    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;
  #endif

  #ifdef DEBUG_NORMAL
    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );
    return;
  #endif

  // -- MToon: lighting --------------------------------------------------------
  // accumulation
  // #include <lights_phong_fragment>
  MToonMaterial material;

  material.diffuseColor = diffuseColor.rgb;

  material.shadeColor = shadeColorFactor;
  #ifdef USE_SHADEMULTIPLYTEXTURE
    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;
  #endif

  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    material.shadeColor.rgb *= vColor;
  #endif

  material.shadingShift = shadingShiftFactor;
  #ifdef USE_SHADINGSHIFTTEXTURE
    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;
  #endif

  // #include <lights_fragment_begin>

  // MToon Specific changes:
  // Since we want to take shadows into account of shading instead of irradiance,
  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.

  // COMPAT: pre-r156 uses a struct GeometricContext
  #if THREE_VRM_THREE_REVISION >= 157
    vec3 geometryPosition = - vViewPosition;
    vec3 geometryNormal = normal;
    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    vec3 geometryClearcoatNormal;

    #ifdef USE_CLEARCOAT

      geometryClearcoatNormal = clearcoatNormal;

    #endif
  #else
    GeometricContext geometry;

    geometry.position = - vViewPosition;
    geometry.normal = normal;
    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    #ifdef USE_CLEARCOAT

      geometry.clearcoatNormal = clearcoatNormal;

    #endif
  #endif

  IncidentLight directLight;

  // since these variables will be used in unrolled loop, we have to define in prior
  float shadow;

  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

      pointLight = pointLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getPointLightInfo( pointLight, geometryPosition, directLight );
      #else
        getPointLightInfo( pointLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
      pointLightShadow = pointLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

    SpotLight spotLight;
    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

      spotLight = spotLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getSpotLightInfo( spotLight, geometryPosition, directLight );
      #else
        getSpotLightInfo( spotLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
      spotLightShadow = spotLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

      directionalLight = directionalLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getDirectionalLightInfo( directionalLight, directLight );
      #else
        getDirectionalLightInfo( directionalLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
      directionalLightShadow = directionalLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

  //   RectAreaLight rectAreaLight;

  //   #pragma unroll_loop_start
  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

  //     rectAreaLight = rectAreaLights[ i ];
  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

  //   }
  //   #pragma unroll_loop_end

  // #endif

  #if defined( RE_IndirectDiffuse )

    vec3 iblIrradiance = vec3( 0.0 );

    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

    // COMPAT: pre-r156 uses a struct GeometricContext
    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES
    #if THREE_VRM_THREE_REVISION >= 157
      #if defined( USE_LIGHT_PROBES )
        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
      #endif
    #else
      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
    #endif

    #if ( NUM_HEMI_LIGHTS > 0 )

      #pragma unroll_loop_start
      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

        // COMPAT: pre-r156 uses a struct GeometricContext
        #if THREE_VRM_THREE_REVISION >= 157
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
        #else
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
        #endif

      }
      #pragma unroll_loop_end

    #endif

  #endif

  // #if defined( RE_IndirectSpecular )

  //   vec3 radiance = vec3( 0.0 );
  //   vec3 clearcoatRadiance = vec3( 0.0 );

  // #endif

  #include <lights_fragment_maps>
  #include <lights_fragment_end>

  // modulation
  #include <aomap_fragment>

  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;

  #ifdef DEBUG_LITSHADERATE
    gl_FragColor = vec4( col, diffuseColor.a );
    postCorrection();
    return;
  #endif

  // -- MToon: rim lighting -----------------------------------------
  vec3 viewDir = normalize( vViewPosition );

  #ifndef PHYSICALLY_CORRECT_LIGHTS
    reflectedLight.directSpecular /= PI;
  #endif
  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );

  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );

  #ifdef USE_MATCAPTEXTURE
    {
      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );
      vec3 y = cross( viewDir, x ); // guaranteed to be normalized
      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );
      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;
      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;
      rim += matcapFactor * matcap;
    }
  #endif

  #ifdef USE_RIMMULTIPLYTEXTURE
    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;
  #endif

  col += rimMix * rim;

  // -- MToon: Emission --------------------------------------------------------
  col += totalEmissiveRadiance;

  // #include <envmap_fragment>

  // -- Almost done! -----------------------------------------------------------
  #if defined( OUTLINE )
    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );
  #endif

  #ifdef OPAQUE
    diffuseColor.a = 1.0;
  #endif

  gl_FragColor = vec4( col, diffuseColor.a );
  postCorrection();
}
`,tw={None:"none"},tg={None:"none",ScreenCoordinates:"screenCoordinates"},ew={3e3:"",3001:"srgb"};function Uu(o){return parseInt(Ni,10)>=152?o.colorSpace:ew[o.encoding]}var iw=class extends Yx{constructor(t={}){var e;super({vertexShader:JS,fragmentShader:KS}),this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.fog=!0,this.normalMapType=ca,this._ignoreVertexColor=!0,this._v0CompatShade=!1,this._debugMode=tw.None,this._outlineWidthMode=tg.None,this._isOutline=!1,t.transparentWithZWrite&&(t.depthWrite=!0),delete t.transparentWithZWrite,t.fog=!0,t.lights=!0,t.clipping=!0,this.uniforms=Xx.merge([Bi.common,Bi.normalmap,Bi.emissivemap,Bi.fog,Bi.lights,{litFactor:{value:new lt(1,1,1)},mapUvTransform:{value:new yt},colorAlpha:{value:1},normalMapUvTransform:{value:new yt},shadeColorFactor:{value:new lt(0,0,0)},shadeMultiplyTexture:{value:null},shadeMultiplyTextureUvTransform:{value:new yt},shadingShiftFactor:{value:0},shadingShiftTexture:{value:null},shadingShiftTextureUvTransform:{value:new yt},shadingShiftTextureScale:{value:1},shadingToonyFactor:{value:.9},giEqualizationFactor:{value:.9},matcapFactor:{value:new lt(1,1,1)},matcapTexture:{value:null},matcapTextureUvTransform:{value:new yt},parametricRimColorFactor:{value:new lt(0,0,0)},rimMultiplyTexture:{value:null},rimMultiplyTextureUvTransform:{value:new yt},rimLightingMixFactor:{value:1},parametricRimFresnelPowerFactor:{value:5},parametricRimLiftFactor:{value:0},emissive:{value:new lt(0,0,0)},emissiveIntensity:{value:1},emissiveMapUvTransform:{value:new yt},outlineWidthMultiplyTexture:{value:null},outlineWidthMultiplyTextureUvTransform:{value:new yt},outlineWidthFactor:{value:0},outlineColorFactor:{value:new lt(0,0,0)},outlineLightingMixFactor:{value:1},uvAnimationMaskTexture:{value:null},uvAnimationMaskTextureUvTransform:{value:new yt},uvAnimationScrollXOffset:{value:0},uvAnimationScrollYOffset:{value:0},uvAnimationRotationPhase:{value:0}},(e=t.uniforms)!=null?e:{}]),this.setValues(t),this._uploadUniformsWorkaround(),this.customProgramCacheKey=()=>[...Object.entries(this._generateDefines()).map(([i,s])=>`${i}:${s}`),this.matcapTexture?`matcapTextureColorSpace:${Uu(this.matcapTexture)}`:"",this.shadeMultiplyTexture?`shadeMultiplyTextureColorSpace:${Uu(this.shadeMultiplyTexture)}`:"",this.rimMultiplyTexture?`rimMultiplyTextureColorSpace:${Uu(this.rimMultiplyTexture)}`:""].join(","),this.onBeforeCompile=i=>{const s=parseInt(Ni,10),n=Object.entries(Km(Km({},this._generateDefines()),this.defines)).filter(([r,a])=>!!a).map(([r,a])=>`#define ${r} ${a}`).join(`
`)+`
`;i.vertexShader=n+i.vertexShader,i.fragmentShader=n+i.fragmentShader,s<154&&(i.fragmentShader=i.fragmentShader.replace("#include <colorspace_fragment>","#include <encodings_fragment>"))}}get color(){return this.uniforms.litFactor.value}set color(t){this.uniforms.litFactor.value=t}get map(){return this.uniforms.map.value}set map(t){this.uniforms.map.value=t}get normalMap(){return this.uniforms.normalMap.value}set normalMap(t){this.uniforms.normalMap.value=t}get normalScale(){return this.uniforms.normalScale.value}set normalScale(t){this.uniforms.normalScale.value=t}get emissive(){return this.uniforms.emissive.value}set emissive(t){this.uniforms.emissive.value=t}get emissiveIntensity(){return this.uniforms.emissiveIntensity.value}set emissiveIntensity(t){this.uniforms.emissiveIntensity.value=t}get emissiveMap(){return this.uniforms.emissiveMap.value}set emissiveMap(t){this.uniforms.emissiveMap.value=t}get shadeColorFactor(){return this.uniforms.shadeColorFactor.value}set shadeColorFactor(t){this.uniforms.shadeColorFactor.value=t}get shadeMultiplyTexture(){return this.uniforms.shadeMultiplyTexture.value}set shadeMultiplyTexture(t){this.uniforms.shadeMultiplyTexture.value=t}get shadingShiftFactor(){return this.uniforms.shadingShiftFactor.value}set shadingShiftFactor(t){this.uniforms.shadingShiftFactor.value=t}get shadingShiftTexture(){return this.uniforms.shadingShiftTexture.value}set shadingShiftTexture(t){this.uniforms.shadingShiftTexture.value=t}get shadingShiftTextureScale(){return this.uniforms.shadingShiftTextureScale.value}set shadingShiftTextureScale(t){this.uniforms.shadingShiftTextureScale.value=t}get shadingToonyFactor(){return this.uniforms.shadingToonyFactor.value}set shadingToonyFactor(t){this.uniforms.shadingToonyFactor.value=t}get giEqualizationFactor(){return this.uniforms.giEqualizationFactor.value}set giEqualizationFactor(t){this.uniforms.giEqualizationFactor.value=t}get matcapFactor(){return this.uniforms.matcapFactor.value}set matcapFactor(t){this.uniforms.matcapFactor.value=t}get matcapTexture(){return this.uniforms.matcapTexture.value}set matcapTexture(t){this.uniforms.matcapTexture.value=t}get parametricRimColorFactor(){return this.uniforms.parametricRimColorFactor.value}set parametricRimColorFactor(t){this.uniforms.parametricRimColorFactor.value=t}get rimMultiplyTexture(){return this.uniforms.rimMultiplyTexture.value}set rimMultiplyTexture(t){this.uniforms.rimMultiplyTexture.value=t}get rimLightingMixFactor(){return this.uniforms.rimLightingMixFactor.value}set rimLightingMixFactor(t){this.uniforms.rimLightingMixFactor.value=t}get parametricRimFresnelPowerFactor(){return this.uniforms.parametricRimFresnelPowerFactor.value}set parametricRimFresnelPowerFactor(t){this.uniforms.parametricRimFresnelPowerFactor.value=t}get parametricRimLiftFactor(){return this.uniforms.parametricRimLiftFactor.value}set parametricRimLiftFactor(t){this.uniforms.parametricRimLiftFactor.value=t}get outlineWidthMultiplyTexture(){return this.uniforms.outlineWidthMultiplyTexture.value}set outlineWidthMultiplyTexture(t){this.uniforms.outlineWidthMultiplyTexture.value=t}get outlineWidthFactor(){return this.uniforms.outlineWidthFactor.value}set outlineWidthFactor(t){this.uniforms.outlineWidthFactor.value=t}get outlineColorFactor(){return this.uniforms.outlineColorFactor.value}set outlineColorFactor(t){this.uniforms.outlineColorFactor.value=t}get outlineLightingMixFactor(){return this.uniforms.outlineLightingMixFactor.value}set outlineLightingMixFactor(t){this.uniforms.outlineLightingMixFactor.value=t}get uvAnimationMaskTexture(){return this.uniforms.uvAnimationMaskTexture.value}set uvAnimationMaskTexture(t){this.uniforms.uvAnimationMaskTexture.value=t}get uvAnimationScrollXOffset(){return this.uniforms.uvAnimationScrollXOffset.value}set uvAnimationScrollXOffset(t){this.uniforms.uvAnimationScrollXOffset.value=t}get uvAnimationScrollYOffset(){return this.uniforms.uvAnimationScrollYOffset.value}set uvAnimationScrollYOffset(t){this.uniforms.uvAnimationScrollYOffset.value=t}get uvAnimationRotationPhase(){return this.uniforms.uvAnimationRotationPhase.value}set uvAnimationRotationPhase(t){this.uniforms.uvAnimationRotationPhase.value=t}get ignoreVertexColor(){return this._ignoreVertexColor}set ignoreVertexColor(t){this._ignoreVertexColor=t,this.needsUpdate=!0}get v0CompatShade(){return this._v0CompatShade}set v0CompatShade(t){this._v0CompatShade=t,this.needsUpdate=!0}get debugMode(){return this._debugMode}set debugMode(t){this._debugMode=t,this.needsUpdate=!0}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(t){this._outlineWidthMode=t,this.needsUpdate=!0}get isOutline(){return this._isOutline}set isOutline(t){this._isOutline=t,this.needsUpdate=!0}get isMToonMaterial(){return!0}update(t){this._uploadUniformsWorkaround(),this._updateUVAnimation(t)}copy(t){return super.copy(t),this.map=t.map,this.normalMap=t.normalMap,this.emissiveMap=t.emissiveMap,this.shadeMultiplyTexture=t.shadeMultiplyTexture,this.shadingShiftTexture=t.shadingShiftTexture,this.matcapTexture=t.matcapTexture,this.rimMultiplyTexture=t.rimMultiplyTexture,this.outlineWidthMultiplyTexture=t.outlineWidthMultiplyTexture,this.uvAnimationMaskTexture=t.uvAnimationMaskTexture,this.normalMapType=t.normalMapType,this.uvAnimationScrollXSpeedFactor=t.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=t.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=t.uvAnimationRotationSpeedFactor,this.ignoreVertexColor=t.ignoreVertexColor,this.v0CompatShade=t.v0CompatShade,this.debugMode=t.debugMode,this.outlineWidthMode=t.outlineWidthMode,this.isOutline=t.isOutline,this.needsUpdate=!0,this}_updateUVAnimation(t){this.uniforms.uvAnimationScrollXOffset.value+=t*this.uvAnimationScrollXSpeedFactor,this.uniforms.uvAnimationScrollYOffset.value+=t*this.uvAnimationScrollYSpeedFactor,this.uniforms.uvAnimationRotationPhase.value+=t*this.uvAnimationRotationSpeedFactor,this.uniforms.alphaTest.value=this.alphaTest,this.uniformsNeedUpdate=!0}_uploadUniformsWorkaround(){this.uniforms.opacity.value=this.opacity,this._updateTextureMatrix(this.uniforms.map,this.uniforms.mapUvTransform),this._updateTextureMatrix(this.uniforms.normalMap,this.uniforms.normalMapUvTransform),this._updateTextureMatrix(this.uniforms.emissiveMap,this.uniforms.emissiveMapUvTransform),this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture,this.uniforms.shadeMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.shadingShiftTexture,this.uniforms.shadingShiftTextureUvTransform),this._updateTextureMatrix(this.uniforms.matcapTexture,this.uniforms.matcapTextureUvTransform),this._updateTextureMatrix(this.uniforms.rimMultiplyTexture,this.uniforms.rimMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture,this.uniforms.outlineWidthMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture,this.uniforms.uvAnimationMaskTextureUvTransform),this.uniformsNeedUpdate=!0}_generateDefines(){const t=parseInt(Ni,10),e=this.outlineWidthMultiplyTexture!==null,i=this.map!==null||this.normalMap!==null||this.emissiveMap!==null||this.shadeMultiplyTexture!==null||this.shadingShiftTexture!==null||this.rimMultiplyTexture!==null||this.uvAnimationMaskTexture!==null;return{THREE_VRM_THREE_REVISION:t,OUTLINE:this._isOutline,MTOON_USE_UV:e||i,MTOON_UVS_VERTEX_ONLY:e&&!i,V0_COMPAT_SHADE:this._v0CompatShade,USE_SHADEMULTIPLYTEXTURE:this.shadeMultiplyTexture!==null,USE_SHADINGSHIFTTEXTURE:this.shadingShiftTexture!==null,USE_MATCAPTEXTURE:this.matcapTexture!==null,USE_RIMMULTIPLYTEXTURE:this.rimMultiplyTexture!==null,USE_OUTLINEWIDTHMULTIPLYTEXTURE:this._isOutline&&this.outlineWidthMultiplyTexture!==null,USE_UVANIMATIONMASKTEXTURE:this.uvAnimationMaskTexture!==null,IGNORE_VERTEX_COLOR:this._ignoreVertexColor===!0,DEBUG_NORMAL:this._debugMode==="normal",DEBUG_LITSHADERATE:this._debugMode==="litShadeRate",DEBUG_UV:this._debugMode==="uv",OUTLINE_WIDTH_SCREEN:this._isOutline&&this._outlineWidthMode===tg.ScreenCoordinates}}_updateTextureMatrix(t,e){t.value&&(t.value.matrixAutoUpdate&&t.value.updateMatrix(),e.value.copy(t.value.matrix))}},sw=new Set(["1.0","1.0-beta"]),a0=class Hl{get name(){return Hl.EXTENSION_NAME}constructor(t,e={}){var i,s,n,r;this.parser=t,this.materialType=(i=e.materialType)!=null?i:iw,this.renderOrderOffset=(s=e.renderOrderOffset)!=null?s:0,this.v0CompatShade=(n=e.v0CompatShade)!=null?n:!1,this.debugMode=(r=e.debugMode)!=null?r:"none",this._mToonMaterialSet=new Set}beforeRoot(){return mn(this,null,function*(){this._removeUnlitExtensionIfMToonExists()})}afterRoot(t){return mn(this,null,function*(){t.userData.vrmMToonMaterials=Array.from(this._mToonMaterialSet)})}getMaterialType(t){return this._getMToonExtension(t)?this.materialType:null}extendMaterialParams(t,e){const i=this._getMToonExtension(t);return i?this._extendMaterialParams(i,e):null}loadMesh(t){return mn(this,null,function*(){var e;const i=this.parser,n=(e=i.json.meshes)==null?void 0:e[t];if(n==null)throw new Error(`MToonMaterialLoaderPlugin: Attempt to use meshes[${t}] of glTF but the mesh doesn't exist`);const r=n.primitives,a=yield i.loadMesh(t);if(r.length===1){const l=a,h=r[0].material;h!=null&&this._setupPrimitive(l,h)}else{const l=a;for(let h=0;h<r.length;h++){const u=l.children[h],c=r[h].material;c!=null&&this._setupPrimitive(u,c)}}return a})}_removeUnlitExtensionIfMToonExists(){const i=this.parser.json.materials;i?.map((s,n)=>{var r;this._getMToonExtension(n)&&((r=s.extensions)!=null&&r.KHR_materials_unlit)&&delete s.extensions.KHR_materials_unlit})}_getMToonExtension(t){var e,i;const r=(e=this.parser.json.materials)==null?void 0:e[t];if(r==null){console.warn(`MToonMaterialLoaderPlugin: Attempt to use materials[${t}] of glTF but the material doesn't exist`);return}const a=(i=r.extensions)==null?void 0:i[Hl.EXTENSION_NAME];if(a==null)return;const l=a.specVersion;if(!sw.has(l)){console.warn(`MToonMaterialLoaderPlugin: Unknown ${Hl.EXTENSION_NAME} specVersion "${l}"`);return}return a}_extendMaterialParams(t,e){return mn(this,null,function*(){var i;delete e.metalness,delete e.roughness;const s=new QS(this.parser,e);s.assignPrimitive("transparentWithZWrite",t.transparentWithZWrite),s.assignColor("shadeColorFactor",t.shadeColorFactor),s.assignTexture("shadeMultiplyTexture",t.shadeMultiplyTexture,!0),s.assignPrimitive("shadingShiftFactor",t.shadingShiftFactor),s.assignTexture("shadingShiftTexture",t.shadingShiftTexture,!0),s.assignPrimitive("shadingShiftTextureScale",(i=t.shadingShiftTexture)==null?void 0:i.scale),s.assignPrimitive("shadingToonyFactor",t.shadingToonyFactor),s.assignPrimitive("giEqualizationFactor",t.giEqualizationFactor),s.assignColor("matcapFactor",t.matcapFactor),s.assignTexture("matcapTexture",t.matcapTexture,!0),s.assignColor("parametricRimColorFactor",t.parametricRimColorFactor),s.assignTexture("rimMultiplyTexture",t.rimMultiplyTexture,!0),s.assignPrimitive("rimLightingMixFactor",t.rimLightingMixFactor),s.assignPrimitive("parametricRimFresnelPowerFactor",t.parametricRimFresnelPowerFactor),s.assignPrimitive("parametricRimLiftFactor",t.parametricRimLiftFactor),s.assignPrimitive("outlineWidthMode",t.outlineWidthMode),s.assignPrimitive("outlineWidthFactor",t.outlineWidthFactor),s.assignTexture("outlineWidthMultiplyTexture",t.outlineWidthMultiplyTexture,!1),s.assignColor("outlineColorFactor",t.outlineColorFactor),s.assignPrimitive("outlineLightingMixFactor",t.outlineLightingMixFactor),s.assignTexture("uvAnimationMaskTexture",t.uvAnimationMaskTexture,!1),s.assignPrimitive("uvAnimationScrollXSpeedFactor",t.uvAnimationScrollXSpeedFactor),s.assignPrimitive("uvAnimationScrollYSpeedFactor",t.uvAnimationScrollYSpeedFactor),s.assignPrimitive("uvAnimationRotationSpeedFactor",t.uvAnimationRotationSpeedFactor),s.assignPrimitive("v0CompatShade",this.v0CompatShade),s.assignPrimitive("debugMode",this.debugMode),yield s.pending})}_setupPrimitive(t,e){const i=this._getMToonExtension(e);if(i){const s=this._parseRenderOrder(i);t.renderOrder=s+this.renderOrderOffset,this._generateOutline(t),this._addToMaterialSet(t);return}}_shouldGenerateOutline(t){return typeof t.outlineWidthMode=="string"&&t.outlineWidthMode!=="none"&&typeof t.outlineWidthFactor=="number"&&t.outlineWidthFactor>0}_generateOutline(t){const e=t.material;if(!(e instanceof fs)||!this._shouldGenerateOutline(e))return;t.material=[e];const i=e.clone();i.name+=" (Outline)",i.isOutline=!0,i.side=yp,t.material.push(i);const s=t.geometry,n=s.index?s.index.count:s.attributes.position.count/3;s.addGroup(0,n,0),s.addGroup(0,n,1)}_addToMaterialSet(t){const e=t.material,i=new Set;Array.isArray(e)?e.forEach(s=>i.add(s)):i.add(e);for(const s of i)this._mToonMaterialSet.add(s)}_parseRenderOrder(t){var e;return(t.transparentWithZWrite?0:19)+((e=t.renderQueueOffsetNumber)!=null?e:0)}};a0.EXTENSION_NAME="VRMC_materials_mtoon";var YD=a0;/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const vn="167",nw=0,rw=1,ow=2,aw=1,na=0,ms=1,lh=2,Wr=0,os=1,hh=2,uh=3,ch=4,l0=5,Bs=100,h0=101,u0=102,lw=103,hw=104,c0=200,d0=201,p0=202,f0=203,dh=204,ph=205,m0=206,g0=207,y0=208,x0=209,_0=210,M0=0,v0=1,T0=2,fh=3,b0=4,S0=5,w0=6,A0=7,Hh=0,uw=1,cw=2,Tn=0,dw=1,pw=2,fw=3,mw=4,gw=6,yw=7,N0=300,Hr=301,ra=302,Np=303,Rp=304,xw=306,$r=1e3,br=1001,mh=1002,ce=1003,fd=1004,Lr=1005,Le=1006,md=1007,as=1008,rs=1009,$o=1010,qo=1011,Sr=1012,Ne=1013,re=1014,qe=1015,wi=1016,_w=1017,Mw=1018,ma=1020,R0=35902,vw=1021,Ep=1022,io=1023,Tw=1024,bw=1025,yn=1026,qr=1027,Cp=1028,Pp=1029,Fp=1030,Ip=1031,Sw=1032,Bp=1033,Du=33776,$l=33777,ql=33778,jl=33779,eg=35840,ig=35841,sg=35842,ng=35843,rg=36196,gd=37492,yd=37496,xd=37808,_d=37809,Md=37810,vd=37811,Td=37812,bd=37813,Sd=37814,wd=37815,Ad=37816,Nd=37817,Rd=37818,Ed=37819,Cd=37820,Pd=37821,Ou=36492,ww=36283,og=36284,ag=36285,lg=36286,E0=2200,Aw=2201,C0=2202,gh=2300,Fd=2301,zu=2302,wr=2400,Ar=2401,yh=2402,Lp=2500,Nw=2501,Vs=0,Rw=1,ga="",j="srgb",Qe="srgb-linear",Ew="display-p3",P0="display-p3-linear",Id="linear",hg="srgb",ug="rec709",cg="p3",Cw=0,un=7680,Pw=7681,Fw=7682,Iw=7683,Bw=34055,Lw=34056,Uw=5386,Dw=512,Ow=513,zw=514,Vw=515,kw=516,Gw=517,Ww=518,Bd=519,F0=512,Up=513,I0=514,B0=515,L0=516,U0=517,D0=518,O0=519,xh=35044,Nr=35048,bi=2e3,bn=2001;class Hs{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const s=this._listeners[t];if(s!==void 0){const n=s.indexOf(e);n!==-1&&s.splice(n,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const i=this._listeners[t.type];if(i!==void 0){t.target=this;const s=i.slice(0);for(let n=0,r=s.length;n<r;n++)s[n].call(this,t);t.target=null}}}const ye=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let dg=1234567;const jo=Math.PI/180,oa=180/Math.PI;function Di(){const o=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(ye[o&255]+ye[o>>8&255]+ye[o>>16&255]+ye[o>>24&255]+"-"+ye[t&255]+ye[t>>8&255]+"-"+ye[t>>16&15|64]+ye[t>>24&255]+"-"+ye[e&63|128]+ye[e>>8&255]+"-"+ye[e>>16&255]+ye[e>>24&255]+ye[i&255]+ye[i>>8&255]+ye[i>>16&255]+ye[i>>24&255]).toLowerCase()}function ae(o,t,e){return Math.max(t,Math.min(e,o))}function Dp(o,t){return(o%t+t)%t}function Hw(o,t,e,i,s){return i+(o-t)*(s-i)/(e-t)}function $w(o,t,e){return o!==t?(e-o)/(t-o):0}function Xo(o,t,e){return(1-e)*o+e*t}function qw(o,t,e,i){return Xo(o,t,1-Math.exp(-e*i))}function jw(o,t=1){return t-Math.abs(Dp(o,t*2)-t)}function Xw(o,t,e){return o<=t?0:o>=e?1:(o=(o-t)/(e-t),o*o*(3-2*o))}function Yw(o,t,e){return o<=t?0:o>=e?1:(o=(o-t)/(e-t),o*o*o*(o*(o*6-15)+10))}function Zw(o,t){return o+Math.floor(Math.random()*(t-o+1))}function Qw(o,t){return o+Math.random()*(t-o)}function Jw(o){return o*(.5-Math.random())}function Kw(o){o!==void 0&&(dg=o);let t=dg+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function t1(o){return o*jo}function e1(o){return o*oa}function i1(o){return(o&o-1)===0&&o!==0}function s1(o){return Math.pow(2,Math.ceil(Math.log(o)/Math.LN2))}function n1(o){return Math.pow(2,Math.floor(Math.log(o)/Math.LN2))}function r1(o,t,e,i,s){const n=Math.cos,r=Math.sin,a=n(e/2),l=r(e/2),h=n((t+i)/2),u=r((t+i)/2),c=n((t-i)/2),d=r((t-i)/2),p=n((i-t)/2),f=r((i-t)/2);switch(s){case"XYX":o.set(a*u,l*c,l*d,a*h);break;case"YZY":o.set(l*d,a*u,l*c,a*h);break;case"ZXZ":o.set(l*c,l*d,a*u,a*h);break;case"XZX":o.set(a*u,l*f,l*p,a*h);break;case"YXY":o.set(l*p,a*u,l*f,a*h);break;case"ZYZ":o.set(l*f,l*p,a*u,a*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}function Re(o,t){switch(t.constructor){case Float32Array:return o;case Uint32Array:return o/4294967295;case Uint16Array:return o/65535;case Uint8Array:return o/255;case Int32Array:return Math.max(o/2147483647,-1);case Int16Array:return Math.max(o/32767,-1);case Int8Array:return Math.max(o/127,-1);default:throw new Error("Invalid component type.")}}function et(o,t){switch(t.constructor){case Float32Array:return o;case Uint32Array:return Math.round(o*4294967295);case Uint16Array:return Math.round(o*65535);case Uint8Array:return Math.round(o*255);case Int32Array:return Math.round(o*2147483647);case Int16Array:return Math.round(o*32767);case Int8Array:return Math.round(o*127);default:throw new Error("Invalid component type.")}}const z0={DEG2RAD:jo,RAD2DEG:oa,generateUUID:Di,clamp:ae,euclideanModulo:Dp,mapLinear:Hw,inverseLerp:$w,lerp:Xo,damp:qw,pingpong:jw,smoothstep:Xw,smootherstep:Yw,randInt:Zw,randFloat:Qw,randFloatSpread:Jw,seededRandom:Kw,degToRad:t1,radToDeg:e1,isPowerOfTwo:i1,ceilPowerOfTwo:s1,floorPowerOfTwo:n1,setQuaternionFromProperEuler:r1,normalize:et,denormalize:Re};class q{constructor(t=0,e=0){q.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(ae(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),n=this.x-t.x,r=this.y-t.y;return this.x=n*i-r*s+t.x,this.y=n*s+r*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class hi{constructor(t,e,i,s,n,r,a,l,h){hi.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,i,s,n,r,a,l,h)}set(t,e,i,s,n,r,a,l,h){const u=this.elements;return u[0]=t,u[1]=s,u[2]=a,u[3]=e,u[4]=n,u[5]=l,u[6]=i,u[7]=r,u[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[3],l=i[6],h=i[1],u=i[4],c=i[7],d=i[2],p=i[5],f=i[8],m=s[0],g=s[3],y=s[6],x=s[1],M=s[4],_=s[7],v=s[2],A=s[5],T=s[8];return n[0]=r*m+a*x+l*v,n[3]=r*g+a*M+l*A,n[6]=r*y+a*_+l*T,n[1]=h*m+u*x+c*v,n[4]=h*g+u*M+c*A,n[7]=h*y+u*_+c*T,n[2]=d*m+p*x+f*v,n[5]=d*g+p*M+f*A,n[8]=d*y+p*_+f*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],l=t[6],h=t[7],u=t[8];return e*r*u-e*a*h-i*n*u+i*a*l+s*n*h-s*r*l}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],l=t[6],h=t[7],u=t[8],c=u*r-a*h,d=a*l-u*n,p=h*n-r*l,f=e*c+i*d+s*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return t[0]=c*m,t[1]=(s*h-u*i)*m,t[2]=(a*i-s*r)*m,t[3]=d*m,t[4]=(u*e-s*l)*m,t[5]=(s*n-a*e)*m,t[6]=p*m,t[7]=(i*l-h*e)*m,t[8]=(r*e-i*n)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,n,r,a){const l=Math.cos(n),h=Math.sin(n);return this.set(i*l,i*h,-i*(l*r+h*a)+r+t,-s*h,s*l,-s*(-h*r+l*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(Vu.makeScale(t,e)),this}rotate(t){return this.premultiply(Vu.makeRotation(-t)),this}translate(t,e){return this.premultiply(Vu.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const Vu=new hi;function o1(o){for(let t=o.length-1;t>=0;--t)if(o[t]>=65535)return!0;return!1}function Ld(o){return document.createElementNS("http://www.w3.org/1999/xhtml",o)}function a1(){const o=Ld("canvas");return o.style.display="block",o}const pg={};function Op(o){o in pg||(pg[o]=!0,console.warn(o))}const fg=new hi().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),mg=new hi().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),vo={[Qe]:{transfer:Id,primaries:ug,luminanceCoefficients:[.2126,.7152,.0722],toReference:o=>o,fromReference:o=>o},[j]:{transfer:hg,primaries:ug,luminanceCoefficients:[.2126,.7152,.0722],toReference:o=>o.convertSRGBToLinear(),fromReference:o=>o.convertLinearToSRGB()},[P0]:{transfer:Id,primaries:cg,luminanceCoefficients:[.2289,.6917,.0793],toReference:o=>o.applyMatrix3(mg),fromReference:o=>o.applyMatrix3(fg)},[Ew]:{transfer:hg,primaries:cg,luminanceCoefficients:[.2289,.6917,.0793],toReference:o=>o.convertSRGBToLinear().applyMatrix3(mg),fromReference:o=>o.applyMatrix3(fg).convertLinearToSRGB()}},l1=new Set([Qe,P0]),ni={enabled:!0,_workingColorSpace:Qe,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(o){if(!l1.has(o))throw new Error(`Unsupported working color space, "${o}".`);this._workingColorSpace=o},convert:function(o,t,e){if(this.enabled===!1||t===e||!t||!e)return o;const i=vo[t].toReference,s=vo[e].fromReference;return s(i(o))},fromWorkingColorSpace:function(o,t){return this.convert(o,this._workingColorSpace,t)},toWorkingColorSpace:function(o,t){return this.convert(o,t,this._workingColorSpace)},getPrimaries:function(o){return vo[o].primaries},getTransfer:function(o){return o===ga?Id:vo[o].transfer},getLuminanceCoefficients:function(o,t=this._workingColorSpace){return o.fromArray(vo[t].luminanceCoefficients)}};function Ur(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function ku(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}let Qn;class h1{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Qn===void 0&&(Qn=Ld("canvas")),Qn.width=t.width,Qn.height=t.height;const i=Qn.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=Qn}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Ld("canvas");e.width=t.width,e.height=t.height;const i=e.getContext("2d");i.drawImage(t,0,0,t.width,t.height);const s=i.getImageData(0,0,t.width,t.height),n=s.data;for(let r=0;r<n.length;r++)n[r]=Ur(n[r]/255)*255;return i.putImageData(s,0,0),e}else if(t.data){const e=t.data.slice(0);for(let i=0;i<e.length;i++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[i]=Math.floor(Ur(e[i]/255)*255):e[i]=Ur(e[i]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let u1=0;class V0{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:u1++}),this.uuid=Di(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const i={uuid:this.uuid,url:""},s=this.data;if(s!==null){let n;if(Array.isArray(s)){n=[];for(let r=0,a=s.length;r<a;r++)s[r].isDataTexture?n.push(Gu(s[r].image)):n.push(Gu(s[r]))}else n=Gu(s);i.url=n}return e||(t.images[this.uuid]=i),i}}function Gu(o){return typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&o instanceof ImageBitmap?h1.getDataURL(o):o.data?{data:Array.from(o.data),width:o.width,height:o.height,type:o.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let c1=0;class Pe extends Hs{constructor(t=Pe.DEFAULT_IMAGE,e=Pe.DEFAULT_MAPPING,i=br,s=br,n=Le,r=as,a=io,l=rs,h=Pe.DEFAULT_ANISOTROPY,u=ga){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:c1++}),this.uuid=Di(),this.name="",this.source=new V0(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=i,this.wrapT=s,this.magFilter=n,this.minFilter=r,this.anisotropy=h,this.format=a,this.internalFormat=null,this.type=l,this.offset=new q(0,0),this.repeat=new q(1,1),this.center=new q(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new hi,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==N0)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case $r:t.x=t.x-Math.floor(t.x);break;case br:t.x=t.x<0?0:1;break;case mh:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case $r:t.y=t.y-Math.floor(t.y);break;case br:t.y=t.y<0?0:1;break;case mh:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}Pe.DEFAULT_IMAGE=null;Pe.DEFAULT_MAPPING=N0;Pe.DEFAULT_ANISOTROPY=1;class _t{constructor(t=0,e=0,i=0,s=1){_t.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=this.w,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s+r[12]*n,this.y=r[1]*e+r[5]*i+r[9]*s+r[13]*n,this.z=r[2]*e+r[6]*i+r[10]*s+r[14]*n,this.w=r[3]*e+r[7]*i+r[11]*s+r[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,n;const l=t.elements,h=l[0],u=l[4],c=l[8],d=l[1],p=l[5],f=l[9],m=l[2],g=l[6],y=l[10];if(Math.abs(u-d)<.01&&Math.abs(c-m)<.01&&Math.abs(f-g)<.01){if(Math.abs(u+d)<.1&&Math.abs(c+m)<.1&&Math.abs(f+g)<.1&&Math.abs(h+p+y-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const M=(h+1)/2,_=(p+1)/2,v=(y+1)/2,A=(u+d)/4,T=(c+m)/4,w=(f+g)/4;return M>_&&M>v?M<.01?(i=0,s=.707106781,n=.707106781):(i=Math.sqrt(M),s=A/i,n=T/i):_>v?_<.01?(i=.707106781,s=0,n=.707106781):(s=Math.sqrt(_),i=A/s,n=w/s):v<.01?(i=.707106781,s=.707106781,n=0):(n=Math.sqrt(v),i=T/n,s=w/n),this.set(i,s,n,e),this}let x=Math.sqrt((g-f)*(g-f)+(c-m)*(c-m)+(d-u)*(d-u));return Math.abs(x)<.001&&(x=1),this.x=(g-f)/x,this.y=(c-m)/x,this.z=(d-u)/x,this.w=Math.acos((h+p+y-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class be extends Hs{constructor(t=1,e=1,i={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new _t(0,0,t,e),this.scissorTest=!1,this.viewport=new _t(0,0,t,e);const s={width:t,height:e,depth:1};i=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Le,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},i);const n=new Pe(s,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace);n.flipY=!1,n.generateMipmaps=i.generateMipmaps,n.internalFormat=i.internalFormat,this.textures=[];const r=i.count;for(let a=0;a<r;a++)this.textures[a]=n.clone(),this.textures[a].isRenderTargetTexture=!0;this.depthBuffer=i.depthBuffer,this.stencilBuffer=i.stencilBuffer,this.resolveDepthBuffer=i.resolveDepthBuffer,this.resolveStencilBuffer=i.resolveStencilBuffer,this.depthTexture=i.depthTexture,this.samples=i.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let s=0,n=this.textures.length;s<n;s++)this.textures[s].image.width=t,this.textures[s].image.height=e,this.textures[s].image.depth=i;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let i=0,s=t.textures.length;i<s;i++)this.textures[i]=t.textures[i].clone(),this.textures[i].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new V0(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class d1 extends be{constructor(t=1,e=1,i={}){super(t,e,i),this.isWebGLRenderTarget=!0}}class p1 extends Pe{constructor(t=null,e=1,i=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:i,depth:s},this.magFilter=ce,this.minFilter=ce,this.wrapR=br,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class je{constructor(t=0,e=0,i=0,s=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=s}static slerpFlat(t,e,i,s,n,r,a){let l=i[s+0],h=i[s+1],u=i[s+2],c=i[s+3];const d=n[r+0],p=n[r+1],f=n[r+2],m=n[r+3];if(a===0){t[e+0]=l,t[e+1]=h,t[e+2]=u,t[e+3]=c;return}if(a===1){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(c!==m||l!==d||h!==p||u!==f){let g=1-a;const y=l*d+h*p+u*f+c*m,x=y>=0?1:-1,M=1-y*y;if(M>Number.EPSILON){const v=Math.sqrt(M),A=Math.atan2(v,y*x);g=Math.sin(g*A)/v,a=Math.sin(a*A)/v}const _=a*x;if(l=l*g+d*_,h=h*g+p*_,u=u*g+f*_,c=c*g+m*_,g===1-a){const v=1/Math.sqrt(l*l+h*h+u*u+c*c);l*=v,h*=v,u*=v,c*=v}}t[e]=l,t[e+1]=h,t[e+2]=u,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,s,n,r){const a=i[s],l=i[s+1],h=i[s+2],u=i[s+3],c=n[r],d=n[r+1],p=n[r+2],f=n[r+3];return t[e]=a*f+u*c+l*p-h*d,t[e+1]=l*f+u*d+h*c-a*p,t[e+2]=h*f+u*p+a*d-l*c,t[e+3]=u*f-a*c-l*d-h*p,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,s=t._y,n=t._z,r=t._order,a=Math.cos,l=Math.sin,h=a(i/2),u=a(s/2),c=a(n/2),d=l(i/2),p=l(s/2),f=l(n/2);switch(r){case"XYZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"YXZ":this._x=d*u*c+h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"ZXY":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c-d*p*f;break;case"ZYX":this._x=d*u*c-h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c+d*p*f;break;case"YZX":this._x=d*u*c+h*p*f,this._y=h*p*c+d*u*f,this._z=h*u*f-d*p*c,this._w=h*u*c-d*p*f;break;case"XZY":this._x=d*u*c-h*p*f,this._y=h*p*c-d*u*f,this._z=h*u*f+d*p*c,this._w=h*u*c+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+r)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],n=e[8],r=e[1],a=e[5],l=e[9],h=e[2],u=e[6],c=e[10],d=i+a+c;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(n-h)*p,this._z=(r-s)*p}else if(i>a&&i>c){const p=2*Math.sqrt(1+i-a-c);this._w=(u-l)/p,this._x=.25*p,this._y=(s+r)/p,this._z=(n+h)/p}else if(a>c){const p=2*Math.sqrt(1+a-i-c);this._w=(n-h)/p,this._x=(s+r)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+c-i-a);this._w=(r-s)/p,this._x=(n+h)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(ae(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,n=t._z,r=t._w,a=e._x,l=e._y,h=e._z,u=e._w;return this._x=i*u+r*a+s*h-n*l,this._y=s*u+r*l+n*a-i*h,this._z=n*u+r*h+i*l-s*a,this._w=r*u-i*a-s*l-n*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,s=this._y,n=this._z,r=this._w;let a=r*t._w+i*t._x+s*t._y+n*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=r,this._x=i,this._y=s,this._z=n,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-e;return this._w=p*r+e*this._w,this._x=p*i+e*this._x,this._y=p*s+e*this._y,this._z=p*n+e*this._z,this.normalize(),this}const h=Math.sqrt(l),u=Math.atan2(h,a),c=Math.sin((1-e)*u)/h,d=Math.sin(e*u)/h;return this._w=r*c+this._w*d,this._x=i*c+this._x*d,this._y=s*c+this._y*d,this._z=n*c+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),s=Math.sqrt(1-i),n=Math.sqrt(i);return this.set(s*Math.sin(t),s*Math.cos(t),n*Math.sin(e),n*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class E{constructor(t=0,e=0,i=0){E.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(gg.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(gg.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*s,this.y=n[1]*e+n[4]*i+n[7]*s,this.z=n[2]*e+n[5]*i+n[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,n=t.elements,r=1/(n[3]*e+n[7]*i+n[11]*s+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*s+n[12])*r,this.y=(n[1]*e+n[5]*i+n[9]*s+n[13])*r,this.z=(n[2]*e+n[6]*i+n[10]*s+n[14])*r,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,n=t.x,r=t.y,a=t.z,l=t.w,h=2*(r*s-a*i),u=2*(a*e-n*s),c=2*(n*i-r*e);return this.x=e+l*h+r*c-a*u,this.y=i+l*u+a*h-n*c,this.z=s+l*c+n*u-r*h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*s,this.y=n[1]*e+n[5]*i+n[9]*s,this.z=n[2]*e+n[6]*i+n[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,n=t.z,r=e.x,a=e.y,l=e.z;return this.x=s*l-n*a,this.y=n*r-i*l,this.z=i*a-s*r,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return Wu.copy(this).projectOnVector(t),this.sub(Wu)}reflect(t){return this.sub(Wu.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(ae(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Wu=new E,gg=new je;class ya{constructor(t=new E(1/0,1/0,1/0),e=new E(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e+=3)this.expandByPoint(gi.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,i=t.count;e<i;e++)this.expandByPoint(gi.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=gi.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const i=t.geometry;if(i!==void 0){const n=i.getAttribute("position");if(e===!0&&n!==void 0&&t.isInstancedMesh!==!0)for(let r=0,a=n.count;r<a;r++)t.isMesh===!0?t.getVertexPosition(r,gi):gi.fromBufferAttribute(n,r),gi.applyMatrix4(t.matrixWorld),this.expandByPoint(gi);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),nl.copy(t.boundingBox)):(i.boundingBox===null&&i.computeBoundingBox(),nl.copy(i.boundingBox)),nl.applyMatrix4(t.matrixWorld),this.union(nl)}const s=t.children;for(let n=0,r=s.length;n<r;n++)this.expandByObject(s[n],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,gi),gi.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(To),rl.subVectors(this.max,To),Jn.subVectors(t.a,To),Kn.subVectors(t.b,To),tr.subVectors(t.c,To),Ss.subVectors(Kn,Jn),ws.subVectors(tr,Kn),Js.subVectors(Jn,tr);let e=[0,-Ss.z,Ss.y,0,-ws.z,ws.y,0,-Js.z,Js.y,Ss.z,0,-Ss.x,ws.z,0,-ws.x,Js.z,0,-Js.x,-Ss.y,Ss.x,0,-ws.y,ws.x,0,-Js.y,Js.x,0];return!Hu(e,Jn,Kn,tr,rl)||(e=[1,0,0,0,1,0,0,0,1],!Hu(e,Jn,Kn,tr,rl))?!1:(ol.crossVectors(Ss,ws),e=[ol.x,ol.y,ol.z],Hu(e,Jn,Kn,tr,rl))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,gi).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(gi).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Zi[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Zi[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Zi[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Zi[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Zi[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Zi[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Zi[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Zi[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Zi),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const Zi=[new E,new E,new E,new E,new E,new E,new E,new E],gi=new E,nl=new ya,Jn=new E,Kn=new E,tr=new E,Ss=new E,ws=new E,Js=new E,To=new E,rl=new E,ol=new E,Ks=new E;function Hu(o,t,e,i,s){for(let n=0,r=o.length-3;n<=r;n+=3){Ks.fromArray(o,n);const a=s.x*Math.abs(Ks.x)+s.y*Math.abs(Ks.y)+s.z*Math.abs(Ks.z),l=t.dot(Ks),h=e.dot(Ks),u=i.dot(Ks);if(Math.max(-Math.max(l,h,u),Math.min(l,h,u))>a)return!1}return!0}const f1=new ya,bo=new E,$u=new E;class zp{constructor(t=new E,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):f1.setFromPoints(t).getCenter(i);let s=0;for(let n=0,r=t.length;n<r;n++)s=Math.max(s,i.distanceToSquared(t[n]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;bo.subVectors(t,this.center);const e=bo.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),s=(i-this.radius)*.5;this.center.addScaledVector(bo,s/i),this.radius+=s}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):($u.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(bo.copy(t.center).add($u)),this.expandByPoint(bo.copy(t.center).sub($u))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Qi=new E,qu=new E,al=new E,As=new E,ju=new E,ll=new E,Xu=new E;class k0{constructor(t=new E,e=new E(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Qi)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,i)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Qi.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Qi.copy(this.origin).addScaledVector(this.direction,e),Qi.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){qu.copy(t).add(e).multiplyScalar(.5),al.copy(e).sub(t).normalize(),As.copy(this.origin).sub(qu);const n=t.distanceTo(e)*.5,r=-this.direction.dot(al),a=As.dot(this.direction),l=-As.dot(al),h=As.lengthSq(),u=Math.abs(1-r*r);let c,d,p,f;if(u>0)if(c=r*l-a,d=r*a-l,f=n*u,c>=0)if(d>=-f)if(d<=f){const m=1/u;c*=m,d*=m,p=c*(c+r*d+2*a)+d*(r*c+d+2*l)+h}else d=n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*l)+h;else d=-n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*l)+h;else d<=-f?(c=Math.max(0,-(-r*n+a)),d=c>0?-n:Math.min(Math.max(-n,-l),n),p=-c*c+d*(d+2*l)+h):d<=f?(c=0,d=Math.min(Math.max(-n,-l),n),p=d*(d+2*l)+h):(c=Math.max(0,-(r*n+a)),d=c>0?n:Math.min(Math.max(-n,-l),n),p=-c*c+d*(d+2*l)+h);else d=r>0?-n:n,c=Math.max(0,-(r*d+a)),p=-c*c+d*(d+2*l)+h;return i&&i.copy(this.origin).addScaledVector(this.direction,c),s&&s.copy(qu).addScaledVector(al,d),p}intersectSphere(t,e){Qi.subVectors(t.center,this.origin);const i=Qi.dot(this.direction),s=Qi.dot(Qi)-i*i,n=t.radius*t.radius;if(s>n)return null;const r=Math.sqrt(n-s),a=i-r,l=i+r;return l<0?null:a<0?this.at(l,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,n,r,a,l;const h=1/this.direction.x,u=1/this.direction.y,c=1/this.direction.z,d=this.origin;return h>=0?(i=(t.min.x-d.x)*h,s=(t.max.x-d.x)*h):(i=(t.max.x-d.x)*h,s=(t.min.x-d.x)*h),u>=0?(n=(t.min.y-d.y)*u,r=(t.max.y-d.y)*u):(n=(t.max.y-d.y)*u,r=(t.min.y-d.y)*u),i>r||n>s||((n>i||isNaN(i))&&(i=n),(r<s||isNaN(s))&&(s=r),c>=0?(a=(t.min.z-d.z)*c,l=(t.max.z-d.z)*c):(a=(t.max.z-d.z)*c,l=(t.min.z-d.z)*c),i>l||a>s)||((a>i||i!==i)&&(i=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(i>=0?i:s,e)}intersectsBox(t){return this.intersectBox(t,Qi)!==null}intersectTriangle(t,e,i,s,n){ju.subVectors(e,t),ll.subVectors(i,t),Xu.crossVectors(ju,ll);let r=this.direction.dot(Xu),a;if(r>0){if(s)return null;a=1}else if(r<0)a=-1,r=-r;else return null;As.subVectors(this.origin,t);const l=a*this.direction.dot(ll.crossVectors(As,ll));if(l<0)return null;const h=a*this.direction.dot(ju.cross(As));if(h<0||l+h>r)return null;const u=-a*As.dot(Xu);return u<0?null:this.at(u/r,n)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Bt{constructor(t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g){Bt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g)}set(t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g){const y=this.elements;return y[0]=t,y[4]=e,y[8]=i,y[12]=s,y[1]=n,y[5]=r,y[9]=a,y[13]=l,y[2]=h,y[6]=u,y[10]=c,y[14]=d,y[3]=p,y[7]=f,y[11]=m,y[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Bt().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/er.setFromMatrixColumn(t,0).length(),n=1/er.setFromMatrixColumn(t,1).length(),r=1/er.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*r,e[9]=i[9]*r,e[10]=i[10]*r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,s=t.y,n=t.z,r=Math.cos(i),a=Math.sin(i),l=Math.cos(s),h=Math.sin(s),u=Math.cos(n),c=Math.sin(n);if(t.order==="XYZ"){const d=r*u,p=r*c,f=a*u,m=a*c;e[0]=l*u,e[4]=-l*c,e[8]=h,e[1]=p+f*h,e[5]=d-m*h,e[9]=-a*l,e[2]=m-d*h,e[6]=f+p*h,e[10]=r*l}else if(t.order==="YXZ"){const d=l*u,p=l*c,f=h*u,m=h*c;e[0]=d+m*a,e[4]=f*a-p,e[8]=r*h,e[1]=r*c,e[5]=r*u,e[9]=-a,e[2]=p*a-f,e[6]=m+d*a,e[10]=r*l}else if(t.order==="ZXY"){const d=l*u,p=l*c,f=h*u,m=h*c;e[0]=d-m*a,e[4]=-r*c,e[8]=f+p*a,e[1]=p+f*a,e[5]=r*u,e[9]=m-d*a,e[2]=-r*h,e[6]=a,e[10]=r*l}else if(t.order==="ZYX"){const d=r*u,p=r*c,f=a*u,m=a*c;e[0]=l*u,e[4]=f*h-p,e[8]=d*h+m,e[1]=l*c,e[5]=m*h+d,e[9]=p*h-f,e[2]=-h,e[6]=a*l,e[10]=r*l}else if(t.order==="YZX"){const d=r*l,p=r*h,f=a*l,m=a*h;e[0]=l*u,e[4]=m-d*c,e[8]=f*c+p,e[1]=c,e[5]=r*u,e[9]=-a*u,e[2]=-h*u,e[6]=p*c+f,e[10]=d-m*c}else if(t.order==="XZY"){const d=r*l,p=r*h,f=a*l,m=a*h;e[0]=l*u,e[4]=-c,e[8]=h*u,e[1]=d*c+m,e[5]=r*u,e[9]=p*c-f,e[2]=f*c-p,e[6]=a*u,e[10]=m*c+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(m1,t,g1)}lookAt(t,e,i){const s=this.elements;return Ve.subVectors(t,e),Ve.lengthSq()===0&&(Ve.z=1),Ve.normalize(),Ns.crossVectors(i,Ve),Ns.lengthSq()===0&&(Math.abs(i.z)===1?Ve.x+=1e-4:Ve.z+=1e-4,Ve.normalize(),Ns.crossVectors(i,Ve)),Ns.normalize(),hl.crossVectors(Ve,Ns),s[0]=Ns.x,s[4]=hl.x,s[8]=Ve.x,s[1]=Ns.y,s[5]=hl.y,s[9]=Ve.y,s[2]=Ns.z,s[6]=hl.z,s[10]=Ve.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,n=this.elements,r=i[0],a=i[4],l=i[8],h=i[12],u=i[1],c=i[5],d=i[9],p=i[13],f=i[2],m=i[6],g=i[10],y=i[14],x=i[3],M=i[7],_=i[11],v=i[15],A=s[0],T=s[4],w=s[8],U=s[12],D=s[1],V=s[5],W=s[9],$=s[13],at=s[2],J=s[6],At=s[10],St=s[14],Pt=s[3],dt=s[7],tt=s[11],Rt=s[15];return n[0]=r*A+a*D+l*at+h*Pt,n[4]=r*T+a*V+l*J+h*dt,n[8]=r*w+a*W+l*At+h*tt,n[12]=r*U+a*$+l*St+h*Rt,n[1]=u*A+c*D+d*at+p*Pt,n[5]=u*T+c*V+d*J+p*dt,n[9]=u*w+c*W+d*At+p*tt,n[13]=u*U+c*$+d*St+p*Rt,n[2]=f*A+m*D+g*at+y*Pt,n[6]=f*T+m*V+g*J+y*dt,n[10]=f*w+m*W+g*At+y*tt,n[14]=f*U+m*$+g*St+y*Rt,n[3]=x*A+M*D+_*at+v*Pt,n[7]=x*T+M*V+_*J+v*dt,n[11]=x*w+M*W+_*At+v*tt,n[15]=x*U+M*$+_*St+v*Rt,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],n=t[12],r=t[1],a=t[5],l=t[9],h=t[13],u=t[2],c=t[6],d=t[10],p=t[14],f=t[3],m=t[7],g=t[11],y=t[15];return f*(+n*l*c-s*h*c-n*a*d+i*h*d+s*a*p-i*l*p)+m*(+e*l*p-e*h*d+n*r*d-s*r*p+s*h*u-n*l*u)+g*(+e*h*c-e*a*p-n*r*c+i*r*p+n*a*u-i*h*u)+y*(-s*a*u-e*l*c+e*a*d+s*r*c-i*r*d+i*l*u)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],n=t[3],r=t[4],a=t[5],l=t[6],h=t[7],u=t[8],c=t[9],d=t[10],p=t[11],f=t[12],m=t[13],g=t[14],y=t[15],x=c*g*h-m*d*h+m*l*p-a*g*p-c*l*y+a*d*y,M=f*d*h-u*g*h-f*l*p+r*g*p+u*l*y-r*d*y,_=u*m*h-f*c*h+f*a*p-r*m*p-u*a*y+r*c*y,v=f*c*l-u*m*l-f*a*d+r*m*d+u*a*g-r*c*g,A=e*x+i*M+s*_+n*v;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/A;return t[0]=x*T,t[1]=(m*d*n-c*g*n-m*s*p+i*g*p+c*s*y-i*d*y)*T,t[2]=(a*g*n-m*l*n+m*s*h-i*g*h-a*s*y+i*l*y)*T,t[3]=(c*l*n-a*d*n-c*s*h+i*d*h+a*s*p-i*l*p)*T,t[4]=M*T,t[5]=(u*g*n-f*d*n+f*s*p-e*g*p-u*s*y+e*d*y)*T,t[6]=(f*l*n-r*g*n-f*s*h+e*g*h+r*s*y-e*l*y)*T,t[7]=(r*d*n-u*l*n+u*s*h-e*d*h-r*s*p+e*l*p)*T,t[8]=_*T,t[9]=(f*c*n-u*m*n-f*i*p+e*m*p+u*i*y-e*c*y)*T,t[10]=(r*m*n-f*a*n+f*i*h-e*m*h-r*i*y+e*a*y)*T,t[11]=(u*a*n-r*c*n-u*i*h+e*c*h+r*i*p-e*a*p)*T,t[12]=v*T,t[13]=(u*m*s-f*c*s+f*i*d-e*m*d-u*i*g+e*c*g)*T,t[14]=(f*a*s-r*m*s-f*i*l+e*m*l+r*i*g-e*a*g)*T,t[15]=(r*c*s-u*a*s+u*i*l-e*c*l-r*i*d+e*a*d)*T,this}scale(t){const e=this.elements,i=t.x,s=t.y,n=t.z;return e[0]*=i,e[4]*=s,e[8]*=n,e[1]*=i,e[5]*=s,e[9]*=n,e[2]*=i,e[6]*=s,e[10]*=n,e[3]*=i,e[7]*=s,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),n=1-i,r=t.x,a=t.y,l=t.z,h=n*r,u=n*a;return this.set(h*r+i,h*a-s*l,h*l+s*a,0,h*a+s*l,u*a+i,u*l-s*r,0,h*l-s*a,u*l+s*r,n*l*l+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,n,r){return this.set(1,i,n,0,t,1,r,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,n=e._x,r=e._y,a=e._z,l=e._w,h=n+n,u=r+r,c=a+a,d=n*h,p=n*u,f=n*c,m=r*u,g=r*c,y=a*c,x=l*h,M=l*u,_=l*c,v=i.x,A=i.y,T=i.z;return s[0]=(1-(m+y))*v,s[1]=(p+_)*v,s[2]=(f-M)*v,s[3]=0,s[4]=(p-_)*A,s[5]=(1-(d+y))*A,s[6]=(g+x)*A,s[7]=0,s[8]=(f+M)*T,s[9]=(g-x)*T,s[10]=(1-(d+m))*T,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let n=er.set(s[0],s[1],s[2]).length();const r=er.set(s[4],s[5],s[6]).length(),a=er.set(s[8],s[9],s[10]).length();this.determinant()<0&&(n=-n),t.x=s[12],t.y=s[13],t.z=s[14],yi.copy(this);const h=1/n,u=1/r,c=1/a;return yi.elements[0]*=h,yi.elements[1]*=h,yi.elements[2]*=h,yi.elements[4]*=u,yi.elements[5]*=u,yi.elements[6]*=u,yi.elements[8]*=c,yi.elements[9]*=c,yi.elements[10]*=c,e.setFromRotationMatrix(yi),i.x=n,i.y=r,i.z=a,this}makePerspective(t,e,i,s,n,r,a=bi){const l=this.elements,h=2*n/(e-t),u=2*n/(i-s),c=(e+t)/(e-t),d=(i+s)/(i-s);let p,f;if(a===bi)p=-(r+n)/(r-n),f=-2*r*n/(r-n);else if(a===bn)p=-r/(r-n),f=-r*n/(r-n);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=h,l[4]=0,l[8]=c,l[12]=0,l[1]=0,l[5]=u,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(t,e,i,s,n,r,a=bi){const l=this.elements,h=1/(e-t),u=1/(i-s),c=1/(r-n),d=(e+t)*h,p=(i+s)*u;let f,m;if(a===bi)f=(r+n)*c,m=-2*c;else if(a===bn)f=n*c,m=-1*c;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*h,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*u,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=m,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const er=new E,yi=new Bt,m1=new E(0,0,0),g1=new E(1,1,1),Ns=new E,hl=new E,Ve=new E,yg=new Bt,xg=new je;class Ye{constructor(t=0,e=0,i=0,s=Ye.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,n=s[0],r=s[4],a=s[8],l=s[1],h=s[5],u=s[9],c=s[2],d=s[6],p=s[10];switch(e){case"XYZ":this._y=Math.asin(ae(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-r,n)):(this._x=Math.atan2(d,h),this._z=0);break;case"YXZ":this._x=Math.asin(-ae(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-c,n),this._z=0);break;case"ZXY":this._x=Math.asin(ae(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-c,p),this._z=Math.atan2(-r,h)):(this._y=0,this._z=Math.atan2(l,n));break;case"ZYX":this._y=Math.asin(-ae(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,n)):(this._x=0,this._z=Math.atan2(-r,h));break;case"YZX":this._z=Math.asin(ae(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,h),this._y=Math.atan2(-c,n)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-ae(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(d,h),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return yg.makeRotationFromQuaternion(t),this.setFromRotationMatrix(yg,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return xg.setFromEuler(this),this.setFromQuaternion(xg,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Ye.DEFAULT_ORDER="XYZ";class G0{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let y1=0;const _g=new E,ir=new je,Ji=new Bt,ul=new E,So=new E,x1=new E,_1=new je,Mg=new E(1,0,0),vg=new E(0,1,0),Tg=new E(0,0,1),bg={type:"added"},M1={type:"removed"},sr={type:"childadded",child:null},Yu={type:"childremoved",child:null};class te extends Hs{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:y1++}),this.uuid=Di(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=te.DEFAULT_UP.clone();const t=new E,e=new Ye,i=new je,s=new E(1,1,1);function n(){i.setFromEuler(e,!1)}function r(){e.setFromQuaternion(i,void 0,!1)}e._onChange(n),i._onChange(r),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new Bt},normalMatrix:{value:new hi}}),this.matrix=new Bt,this.matrixWorld=new Bt,this.matrixAutoUpdate=te.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=te.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new G0,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return ir.setFromAxisAngle(t,e),this.quaternion.multiply(ir),this}rotateOnWorldAxis(t,e){return ir.setFromAxisAngle(t,e),this.quaternion.premultiply(ir),this}rotateX(t){return this.rotateOnAxis(Mg,t)}rotateY(t){return this.rotateOnAxis(vg,t)}rotateZ(t){return this.rotateOnAxis(Tg,t)}translateOnAxis(t,e){return _g.copy(t).applyQuaternion(this.quaternion),this.position.add(_g.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Mg,t)}translateY(t){return this.translateOnAxis(vg,t)}translateZ(t){return this.translateOnAxis(Tg,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(Ji.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?ul.copy(t):ul.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),So.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ji.lookAt(So,ul,this.up):Ji.lookAt(ul,So,this.up),this.quaternion.setFromRotationMatrix(Ji),s&&(Ji.extractRotation(s.matrixWorld),ir.setFromRotationMatrix(Ji),this.quaternion.premultiply(ir.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(bg),sr.child=t,this.dispatchEvent(sr),sr.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(M1),Yu.child=t,this.dispatchEvent(Yu),Yu.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),Ji.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Ji.multiply(t.parent.matrixWorld)),t.applyMatrix4(Ji),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(bg),sr.child=t,this.dispatchEvent(sr),sr.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const r=this.children[i].getObjectByProperty(t,e);if(r!==void 0)return r}}getObjectsByProperty(t,e,i=[]){this[t]===e&&i.push(this);const s=this.children;for(let n=0,r=s.length;n<r;n++)s[n].getObjectsByProperty(t,e,i);return i}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(So,t,x1),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(So,_1,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const s=this.children;for(let n=0,r=s.length;n<r;n++)s[n].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),s.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(s.type="BatchedMesh",s.perObjectFrustumCulled=this.perObjectFrustumCulled,s.sortObjects=this.sortObjects,s.drawRanges=this._drawRanges,s.reservedRanges=this._reservedRanges,s.visibility=this._visibility,s.active=this._active,s.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),s.maxInstanceCount=this._maxInstanceCount,s.maxVertexCount=this._maxVertexCount,s.maxIndexCount=this._maxIndexCount,s.geometryInitialized=this._geometryInitialized,s.geometryCount=this._geometryCount,s.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(s.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(s.boundingSphere={center:s.boundingSphere.center.toArray(),radius:s.boundingSphere.radius}),this.boundingBox!==null&&(s.boundingBox={min:s.boundingBox.min.toArray(),max:s.boundingBox.max.toArray()}));function n(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=n(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let h=0,u=l.length;h<u;h++){const c=l[h];n(t.shapes,c)}else n(t.shapes,l)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(n(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,h=this.material.length;l<h;l++)a.push(n(t.materials,this.material[l]));s.material=a}else s.material=n(t.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];s.animations.push(n(t.animations,l))}}if(e){const a=r(t.geometries),l=r(t.materials),h=r(t.textures),u=r(t.images),c=r(t.shapes),d=r(t.skeletons),p=r(t.animations),f=r(t.nodes);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),h.length>0&&(i.textures=h),u.length>0&&(i.images=u),c.length>0&&(i.shapes=c),d.length>0&&(i.skeletons=d),p.length>0&&(i.animations=p),f.length>0&&(i.nodes=f)}return i.object=s,i;function r(a){const l=[];for(const h in a){const u=a[h];delete u.metadata,l.push(u)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const s=t.children[i];this.add(s.clone())}return this}}te.DEFAULT_UP=new E(0,1,0);te.DEFAULT_MATRIX_AUTO_UPDATE=!0;te.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const xi=new E,Ki=new E,Zu=new E,ts=new E,nr=new E,rr=new E,Sg=new E,Qu=new E,Ju=new E,Ku=new E;class Li{constructor(t=new E,e=new E,i=new E){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),xi.subVectors(t,e),s.cross(xi);const n=s.lengthSq();return n>0?s.multiplyScalar(1/Math.sqrt(n)):s.set(0,0,0)}static getBarycoord(t,e,i,s,n){xi.subVectors(s,e),Ki.subVectors(i,e),Zu.subVectors(t,e);const r=xi.dot(xi),a=xi.dot(Ki),l=xi.dot(Zu),h=Ki.dot(Ki),u=Ki.dot(Zu),c=r*h-a*a;if(c===0)return n.set(0,0,0),null;const d=1/c,p=(h*l-a*u)*d,f=(r*u-a*l)*d;return n.set(1-p-f,f,p)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,ts)===null?!1:ts.x>=0&&ts.y>=0&&ts.x+ts.y<=1}static getInterpolation(t,e,i,s,n,r,a,l){return this.getBarycoord(t,e,i,s,ts)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(n,ts.x),l.addScaledVector(r,ts.y),l.addScaledVector(a,ts.z),l)}static isFrontFacing(t,e,i,s){return xi.subVectors(i,e),Ki.subVectors(t,e),xi.cross(Ki).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return xi.subVectors(this.c,this.b),Ki.subVectors(this.a,this.b),xi.cross(Ki).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Li.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Li.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,i,s,n){return Li.getInterpolation(t,this.a,this.b,this.c,e,i,s,n)}containsPoint(t){return Li.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Li.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,n=this.c;let r,a;nr.subVectors(s,i),rr.subVectors(n,i),Qu.subVectors(t,i);const l=nr.dot(Qu),h=rr.dot(Qu);if(l<=0&&h<=0)return e.copy(i);Ju.subVectors(t,s);const u=nr.dot(Ju),c=rr.dot(Ju);if(u>=0&&c<=u)return e.copy(s);const d=l*c-u*h;if(d<=0&&l>=0&&u<=0)return r=l/(l-u),e.copy(i).addScaledVector(nr,r);Ku.subVectors(t,n);const p=nr.dot(Ku),f=rr.dot(Ku);if(f>=0&&p<=f)return e.copy(n);const m=p*h-l*f;if(m<=0&&h>=0&&f<=0)return a=h/(h-f),e.copy(i).addScaledVector(rr,a);const g=u*f-p*c;if(g<=0&&c-u>=0&&p-f>=0)return Sg.subVectors(n,s),a=(c-u)/(c-u+(p-f)),e.copy(s).addScaledVector(Sg,a);const y=1/(g+m+d);return r=m*y,a=d*y,e.copy(i).addScaledVector(nr,r).addScaledVector(rr,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const W0={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Rs={h:0,s:0,l:0},cl={h:0,s:0,l:0};function tc(o,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?o+(t-o)*6*e:e<1/2?t:e<2/3?o+(t-o)*6*(2/3-e):o}class nt{constructor(t,e,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,i)}set(t,e,i){if(e===void 0&&i===void 0){const s=t;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(t,e,i);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=j){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,ni.toWorkingColorSpace(this,e),this}setRGB(t,e,i,s=ni.workingColorSpace){return this.r=t,this.g=e,this.b=i,ni.toWorkingColorSpace(this,s),this}setHSL(t,e,i,s=ni.workingColorSpace){if(t=Dp(t,1),e=ae(e,0,1),i=ae(i,0,1),e===0)this.r=this.g=this.b=i;else{const n=i<=.5?i*(1+e):i+e-i*e,r=2*i-n;this.r=tc(r,n,t+1/3),this.g=tc(r,n,t),this.b=tc(r,n,t-1/3)}return ni.toWorkingColorSpace(this,s),this}setStyle(t,e=j){function i(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let s;if(s=/^(\w+)\(([^\)]*)\)/.exec(t)){let n;const r=s[1],a=s[2];switch(r){case"rgb":case"rgba":if(n=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(n[4]),this.setRGB(Math.min(255,parseInt(n[1],10))/255,Math.min(255,parseInt(n[2],10))/255,Math.min(255,parseInt(n[3],10))/255,e);if(n=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(n[4]),this.setRGB(Math.min(100,parseInt(n[1],10))/100,Math.min(100,parseInt(n[2],10))/100,Math.min(100,parseInt(n[3],10))/100,e);break;case"hsl":case"hsla":if(n=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return i(n[4]),this.setHSL(parseFloat(n[1])/360,parseFloat(n[2])/100,parseFloat(n[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(t)){const n=s[1],r=n.length;if(r===3)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,e);if(r===6)return this.setHex(parseInt(n,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=j){const i=W0[t.toLowerCase()];return i!==void 0?this.setHex(i,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Ur(t.r),this.g=Ur(t.g),this.b=Ur(t.b),this}copyLinearToSRGB(t){return this.r=ku(t.r),this.g=ku(t.g),this.b=ku(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=j){return ni.fromWorkingColorSpace(xe.copy(this),t),Math.round(ae(xe.r*255,0,255))*65536+Math.round(ae(xe.g*255,0,255))*256+Math.round(ae(xe.b*255,0,255))}getHexString(t=j){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=ni.workingColorSpace){ni.fromWorkingColorSpace(xe.copy(this),e);const i=xe.r,s=xe.g,n=xe.b,r=Math.max(i,s,n),a=Math.min(i,s,n);let l,h;const u=(a+r)/2;if(a===r)l=0,h=0;else{const c=r-a;switch(h=u<=.5?c/(r+a):c/(2-r-a),r){case i:l=(s-n)/c+(s<n?6:0);break;case s:l=(n-i)/c+2;break;case n:l=(i-s)/c+4;break}l/=6}return t.h=l,t.s=h,t.l=u,t}getRGB(t,e=ni.workingColorSpace){return ni.fromWorkingColorSpace(xe.copy(this),e),t.r=xe.r,t.g=xe.g,t.b=xe.b,t}getStyle(t=j){ni.fromWorkingColorSpace(xe.copy(this),t);const e=xe.r,i=xe.g,s=xe.b;return t!==j?`color(${t} ${e.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(i*255)},${Math.round(s*255)})`}offsetHSL(t,e,i){return this.getHSL(Rs),this.setHSL(Rs.h+t,Rs.s+e,Rs.l+i)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(Rs),t.getHSL(cl);const i=Xo(Rs.h,cl.h,e),s=Xo(Rs.s,cl.s,e),n=Xo(Rs.l,cl.l,e);return this.setHSL(i,s,n),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,i=this.g,s=this.b,n=t.elements;return this.r=n[0]*e+n[3]*i+n[6]*s,this.g=n[1]*e+n[4]*i+n[7]*s,this.b=n[2]*e+n[5]*i+n[8]*s,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const xe=new nt;nt.NAMES=W0;let v1=0;class Ue extends Hs{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:v1++}),this.uuid=Di(),this.name="",this.type="Material",this.blending=os,this.side=na,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=dh,this.blendDst=ph,this.blendEquation=Bs,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new nt(0,0,0),this.blendAlpha=0,this.depthFunc=fh,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Bd,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=un,this.stencilZFail=un,this.stencilZPass=un,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const s=this[e];if(s===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(i.dispersion=this.dispersion),this.iridescence!==void 0&&(i.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(i.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(i.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(i.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(i.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapRotation!==void 0&&(i.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==os&&(i.blending=this.blending),this.side!==na&&(i.side=this.side),this.vertexColors===!0&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.transparent===!0&&(i.transparent=!0),this.blendSrc!==dh&&(i.blendSrc=this.blendSrc),this.blendDst!==ph&&(i.blendDst=this.blendDst),this.blendEquation!==Bs&&(i.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(i.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(i.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(i.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(i.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(i.blendAlpha=this.blendAlpha),this.depthFunc!==fh&&(i.depthFunc=this.depthFunc),this.depthTest===!1&&(i.depthTest=this.depthTest),this.depthWrite===!1&&(i.depthWrite=this.depthWrite),this.colorWrite===!1&&(i.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(i.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Bd&&(i.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(i.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(i.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==un&&(i.stencilFail=this.stencilFail),this.stencilZFail!==un&&(i.stencilZFail=this.stencilZFail),this.stencilZPass!==un&&(i.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(i.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaHash===!0&&(i.alphaHash=!0),this.alphaToCoverage===!0&&(i.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=!0),this.forceSinglePass===!0&&(i.forceSinglePass=!0),this.wireframe===!0&&(i.wireframe=!0),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=!0),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),this.fog===!1&&(i.fog=!1),Object.keys(this.userData).length>0&&(i.userData=this.userData);function s(n){const r=[];for(const a in n){const l=n[a];delete l.metadata,r.push(l)}return r}if(e){const n=s(t.textures),r=s(t.images);n.length>0&&(i.textures=n),r.length>0&&(i.images=r)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const s=e.length;i=new Array(s);for(let n=0;n!==s;++n)i[n]=e[n].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}onBeforeRender(){console.warn("Material: onBeforeRender() has been removed.")}}class Vp extends Ue{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ye,this.combine=Hh,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const ss=T1();function T1(){const o=new ArrayBuffer(4),t=new Float32Array(o),e=new Uint32Array(o),i=new Uint32Array(512),s=new Uint32Array(512);for(let l=0;l<256;++l){const h=l-127;h<-27?(i[l]=0,i[l|256]=32768,s[l]=24,s[l|256]=24):h<-14?(i[l]=1024>>-h-14,i[l|256]=1024>>-h-14|32768,s[l]=-h-1,s[l|256]=-h-1):h<=15?(i[l]=h+15<<10,i[l|256]=h+15<<10|32768,s[l]=13,s[l|256]=13):h<128?(i[l]=31744,i[l|256]=64512,s[l]=24,s[l|256]=24):(i[l]=31744,i[l|256]=64512,s[l]=13,s[l|256]=13)}const n=new Uint32Array(2048),r=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let h=l<<13,u=0;for(;(h&8388608)===0;)h<<=1,u-=8388608;h&=-8388609,u+=947912704,n[l]=h|u}for(let l=1024;l<2048;++l)n[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)r[l]=l<<23;r[31]=1199570944,r[32]=2147483648;for(let l=33;l<63;++l)r[l]=2147483648+(l-32<<23);r[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:t,uint32View:e,baseTable:i,shiftTable:s,mantissaTable:n,exponentTable:r,offsetTable:a}}function ke(o){Math.abs(o)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),o=ae(o,-65504,65504),ss.floatView[0]=o;const t=ss.uint32View[0],e=t>>23&511;return ss.baseTable[e]+((t&8388607)>>ss.shiftTable[e])}function dl(o){const t=o>>10;return ss.uint32View[0]=ss.mantissaTable[ss.offsetTable[t]+(o&1023)]+ss.exponentTable[t],ss.floatView[0]}const kt=new E,pl=new q;class ai{constructor(t,e,i=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i,this.usage=xh,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=qe,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return Op("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,n=this.itemSize;s<n;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)pl.fromBufferAttribute(this,e),pl.applyMatrix3(t),this.setXY(e,pl.x,pl.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)kt.fromBufferAttribute(this,e),kt.applyMatrix3(t),this.setXYZ(e,kt.x,kt.y,kt.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)kt.fromBufferAttribute(this,e),kt.applyMatrix4(t),this.setXYZ(e,kt.x,kt.y,kt.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)kt.fromBufferAttribute(this,e),kt.applyNormalMatrix(t),this.setXYZ(e,kt.x,kt.y,kt.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)kt.fromBufferAttribute(this,e),kt.transformDirection(t),this.setXYZ(e,kt.x,kt.y,kt.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let i=this.array[t*this.itemSize+e];return this.normalized&&(i=Re(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=et(i,this.array)),this.array[t*this.itemSize+e]=i,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=Re(e,this.array)),e}setX(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=Re(e,this.array)),e}setY(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=Re(e,this.array)),e}setZ(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=Re(e,this.array)),e}setW(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=et(e,this.array),i=et(i,this.array)),this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.normalized&&(e=et(e,this.array),i=et(i,this.array),s=et(s,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t*=this.itemSize,this.normalized&&(e=et(e,this.array),i=et(i,this.array),s=et(s,this.array),n=et(n,this.array)),this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=n,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==xh&&(t.usage=this.usage),t}}class H0 extends ai{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class $0 extends ai{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class q0 extends ai{constructor(t,e,i){super(new Uint16Array(t),e,i),this.isFloat16BufferAttribute=!0}getX(t){let e=dl(this.array[t*this.itemSize]);return this.normalized&&(e=Re(e,this.array)),e}setX(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize]=ke(e),this}getY(t){let e=dl(this.array[t*this.itemSize+1]);return this.normalized&&(e=Re(e,this.array)),e}setY(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize+1]=ke(e),this}getZ(t){let e=dl(this.array[t*this.itemSize+2]);return this.normalized&&(e=Re(e,this.array)),e}setZ(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize+2]=ke(e),this}getW(t){let e=dl(this.array[t*this.itemSize+3]);return this.normalized&&(e=Re(e,this.array)),e}setW(t,e){return this.normalized&&(e=et(e,this.array)),this.array[t*this.itemSize+3]=ke(e),this}setXY(t,e,i){return t*=this.itemSize,this.normalized&&(e=et(e,this.array),i=et(i,this.array)),this.array[t+0]=ke(e),this.array[t+1]=ke(i),this}setXYZ(t,e,i,s){return t*=this.itemSize,this.normalized&&(e=et(e,this.array),i=et(i,this.array),s=et(s,this.array)),this.array[t+0]=ke(e),this.array[t+1]=ke(i),this.array[t+2]=ke(s),this}setXYZW(t,e,i,s,n){return t*=this.itemSize,this.normalized&&(e=et(e,this.array),i=et(i,this.array),s=et(s,this.array),n=et(n,this.array)),this.array[t+0]=ke(e),this.array[t+1]=ke(i),this.array[t+2]=ke(s),this.array[t+3]=ke(n),this}}class ls extends ai{constructor(t,e,i){super(new Float32Array(t),e,i)}}let b1=0;const ii=new Bt,ec=new te,or=new E,Ge=new ya,wo=new ya,Qt=new E;class An extends Hs{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:b1++}),this.uuid=Di(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(o1(t)?$0:H0)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const n=new hi().getNormalMatrix(t);i.applyNormalMatrix(n),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ii.makeRotationFromQuaternion(t),this.applyMatrix4(ii),this}rotateX(t){return ii.makeRotationX(t),this.applyMatrix4(ii),this}rotateY(t){return ii.makeRotationY(t),this.applyMatrix4(ii),this}rotateZ(t){return ii.makeRotationZ(t),this.applyMatrix4(ii),this}translate(t,e,i){return ii.makeTranslation(t,e,i),this.applyMatrix4(ii),this}scale(t,e,i){return ii.makeScale(t,e,i),this.applyMatrix4(ii),this}lookAt(t){return ec.lookAt(t),ec.updateMatrix(),this.applyMatrix4(ec.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(or).negate(),this.translate(or.x,or.y,or.z),this}setFromPoints(t){const e=[];for(let i=0,s=t.length;i<s;i++){const n=t[i];e.push(n.x,n.y,n.z||0)}return this.setAttribute("position",new ls(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ya);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new E(-1/0,-1/0,-1/0),new E(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,s=e.length;i<s;i++){const n=e[i];Ge.setFromBufferAttribute(n),this.morphTargetsRelative?(Qt.addVectors(this.boundingBox.min,Ge.min),this.boundingBox.expandByPoint(Qt),Qt.addVectors(this.boundingBox.max,Ge.max),this.boundingBox.expandByPoint(Qt)):(this.boundingBox.expandByPoint(Ge.min),this.boundingBox.expandByPoint(Ge.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new zp);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new E,1/0);return}if(t){const i=this.boundingSphere.center;if(Ge.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const a=e[n];wo.setFromBufferAttribute(a),this.morphTargetsRelative?(Qt.addVectors(Ge.min,wo.min),Ge.expandByPoint(Qt),Qt.addVectors(Ge.max,wo.max),Ge.expandByPoint(Qt)):(Ge.expandByPoint(wo.min),Ge.expandByPoint(wo.max))}Ge.getCenter(i);let s=0;for(let n=0,r=t.count;n<r;n++)Qt.fromBufferAttribute(t,n),s=Math.max(s,i.distanceToSquared(Qt));if(e)for(let n=0,r=e.length;n<r;n++){const a=e[n],l=this.morphTargetsRelative;for(let h=0,u=a.count;h<u;h++)Qt.fromBufferAttribute(a,h),l&&(or.fromBufferAttribute(t,h),Qt.add(or)),s=Math.max(s,i.distanceToSquared(Qt))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=e.position,s=e.normal,n=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new ai(new Float32Array(4*i.count),4));const r=this.getAttribute("tangent"),a=[],l=[];for(let w=0;w<i.count;w++)a[w]=new E,l[w]=new E;const h=new E,u=new E,c=new E,d=new q,p=new q,f=new q,m=new E,g=new E;function y(w,U,D){h.fromBufferAttribute(i,w),u.fromBufferAttribute(i,U),c.fromBufferAttribute(i,D),d.fromBufferAttribute(n,w),p.fromBufferAttribute(n,U),f.fromBufferAttribute(n,D),u.sub(h),c.sub(h),p.sub(d),f.sub(d);const V=1/(p.x*f.y-f.x*p.y);isFinite(V)&&(m.copy(u).multiplyScalar(f.y).addScaledVector(c,-p.y).multiplyScalar(V),g.copy(c).multiplyScalar(p.x).addScaledVector(u,-f.x).multiplyScalar(V),a[w].add(m),a[U].add(m),a[D].add(m),l[w].add(g),l[U].add(g),l[D].add(g))}let x=this.groups;x.length===0&&(x=[{start:0,count:t.count}]);for(let w=0,U=x.length;w<U;++w){const D=x[w],V=D.start,W=D.count;for(let $=V,at=V+W;$<at;$+=3)y(t.getX($+0),t.getX($+1),t.getX($+2))}const M=new E,_=new E,v=new E,A=new E;function T(w){v.fromBufferAttribute(s,w),A.copy(v);const U=a[w];M.copy(U),M.sub(v.multiplyScalar(v.dot(U))).normalize(),_.crossVectors(A,U);const V=_.dot(l[w])<0?-1:1;r.setXYZW(w,M.x,M.y,M.z,V)}for(let w=0,U=x.length;w<U;++w){const D=x[w],V=D.start,W=D.count;for(let $=V,at=V+W;$<at;$+=3)T(t.getX($+0)),T(t.getX($+1)),T(t.getX($+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new ai(new Float32Array(e.count*3),3),this.setAttribute("normal",i);else for(let d=0,p=i.count;d<p;d++)i.setXYZ(d,0,0,0);const s=new E,n=new E,r=new E,a=new E,l=new E,h=new E,u=new E,c=new E;if(t)for(let d=0,p=t.count;d<p;d+=3){const f=t.getX(d+0),m=t.getX(d+1),g=t.getX(d+2);s.fromBufferAttribute(e,f),n.fromBufferAttribute(e,m),r.fromBufferAttribute(e,g),u.subVectors(r,n),c.subVectors(s,n),u.cross(c),a.fromBufferAttribute(i,f),l.fromBufferAttribute(i,m),h.fromBufferAttribute(i,g),a.add(u),l.add(u),h.add(u),i.setXYZ(f,a.x,a.y,a.z),i.setXYZ(m,l.x,l.y,l.z),i.setXYZ(g,h.x,h.y,h.z)}else for(let d=0,p=e.count;d<p;d+=3)s.fromBufferAttribute(e,d+0),n.fromBufferAttribute(e,d+1),r.fromBufferAttribute(e,d+2),u.subVectors(r,n),c.subVectors(s,n),u.cross(c),i.setXYZ(d+0,u.x,u.y,u.z),i.setXYZ(d+1,u.x,u.y,u.z),i.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),i.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Qt.fromBufferAttribute(t,e),Qt.normalize(),t.setXYZ(e,Qt.x,Qt.y,Qt.z)}toNonIndexed(){function t(a,l){const h=a.array,u=a.itemSize,c=a.normalized,d=new h.constructor(l.length*u);let p=0,f=0;for(let m=0,g=l.length;m<g;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*u;for(let y=0;y<u;y++)d[f++]=h[p++]}return new ai(d,u,c)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new An,i=this.index.array,s=this.attributes;for(const a in s){const l=s[a],h=t(l,i);e.setAttribute(a,h)}const n=this.morphAttributes;for(const a in n){const l=[],h=n[a];for(let u=0,c=h.length;u<c;u++){const d=h[u],p=t(d,i);l.push(p)}e.morphAttributes[a]=l}e.morphTargetsRelative=this.morphTargetsRelative;const r=this.groups;for(let a=0,l=r.length;a<l;a++){const h=r[a];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const h in l)l[h]!==void 0&&(t[h]=l[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const l in i){const h=i[l];t.data.attributes[l]=h.toJSON(t.data)}const s={};let n=!1;for(const l in this.morphAttributes){const h=this.morphAttributes[l],u=[];for(let c=0,d=h.length;c<d;c++){const p=h[c];u.push(p.toJSON(t.data))}u.length>0&&(s[l]=u,n=!0)}n&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const r=this.groups;r.length>0&&(t.data.groups=JSON.parse(JSON.stringify(r)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const s=t.attributes;for(const h in s){const u=s[h];this.setAttribute(h,u.clone(e))}const n=t.morphAttributes;for(const h in n){const u=[],c=n[h];for(let d=0,p=c.length;d<p;d++)u.push(c[d].clone(e));this.morphAttributes[h]=u}this.morphTargetsRelative=t.morphTargetsRelative;const r=t.groups;for(let h=0,u=r.length;h<u;h++){const c=r[h];this.addGroup(c.start,c.count,c.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const wg=new Bt,tn=new k0,fl=new zp,Ag=new E,ar=new E,lr=new E,hr=new E,ic=new E,ml=new E,gl=new q,yl=new q,xl=new q,Ng=new E,Rg=new E,Eg=new E,_l=new E,Ml=new E;class so extends te{constructor(t=new An,e=new Vp){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let n=0,r=s.length;n<r;n++){const a=s[n].name||String(n);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=n}}}}getVertexPosition(t,e){const i=this.geometry,s=i.attributes.position,n=i.morphAttributes.position,r=i.morphTargetsRelative;e.fromBufferAttribute(s,t);const a=this.morphTargetInfluences;if(n&&a){ml.set(0,0,0);for(let l=0,h=n.length;l<h;l++){const u=a[l],c=n[l];u!==0&&(ic.fromBufferAttribute(c,t),r?ml.addScaledVector(ic,u):ml.addScaledVector(ic.sub(e),u))}e.add(ml)}return e}raycast(t,e){const i=this.geometry,s=this.material,n=this.matrixWorld;s!==void 0&&(i.boundingSphere===null&&i.computeBoundingSphere(),fl.copy(i.boundingSphere),fl.applyMatrix4(n),tn.copy(t.ray).recast(t.near),!(fl.containsPoint(tn.origin)===!1&&(tn.intersectSphere(fl,Ag)===null||tn.origin.distanceToSquared(Ag)>(t.far-t.near)**2))&&(wg.copy(n).invert(),tn.copy(t.ray).applyMatrix4(wg),!(i.boundingBox!==null&&tn.intersectsBox(i.boundingBox)===!1)&&this._computeIntersections(t,e,tn)))}_computeIntersections(t,e,i){let s;const n=this.geometry,r=this.material,a=n.index,l=n.attributes.position,h=n.attributes.uv,u=n.attributes.uv1,c=n.attributes.normal,d=n.groups,p=n.drawRange;if(a!==null)if(Array.isArray(r))for(let f=0,m=d.length;f<m;f++){const g=d[f],y=r[g.materialIndex],x=Math.max(g.start,p.start),M=Math.min(a.count,Math.min(g.start+g.count,p.start+p.count));for(let _=x,v=M;_<v;_+=3){const A=a.getX(_),T=a.getX(_+1),w=a.getX(_+2);s=vl(this,y,t,i,h,u,c,A,T,w),s&&(s.faceIndex=Math.floor(_/3),s.face.materialIndex=g.materialIndex,e.push(s))}}else{const f=Math.max(0,p.start),m=Math.min(a.count,p.start+p.count);for(let g=f,y=m;g<y;g+=3){const x=a.getX(g),M=a.getX(g+1),_=a.getX(g+2);s=vl(this,r,t,i,h,u,c,x,M,_),s&&(s.faceIndex=Math.floor(g/3),e.push(s))}}else if(l!==void 0)if(Array.isArray(r))for(let f=0,m=d.length;f<m;f++){const g=d[f],y=r[g.materialIndex],x=Math.max(g.start,p.start),M=Math.min(l.count,Math.min(g.start+g.count,p.start+p.count));for(let _=x,v=M;_<v;_+=3){const A=_,T=_+1,w=_+2;s=vl(this,y,t,i,h,u,c,A,T,w),s&&(s.faceIndex=Math.floor(_/3),s.face.materialIndex=g.materialIndex,e.push(s))}}else{const f=Math.max(0,p.start),m=Math.min(l.count,p.start+p.count);for(let g=f,y=m;g<y;g+=3){const x=g,M=g+1,_=g+2;s=vl(this,r,t,i,h,u,c,x,M,_),s&&(s.faceIndex=Math.floor(g/3),e.push(s))}}}}function S1(o,t,e,i,s,n,r,a){let l;if(t.side===ms?l=i.intersectTriangle(r,n,s,!0,a):l=i.intersectTriangle(s,n,r,t.side===na,a),l===null)return null;Ml.copy(a),Ml.applyMatrix4(o.matrixWorld);const h=e.ray.origin.distanceTo(Ml);return h<e.near||h>e.far?null:{distance:h,point:Ml.clone(),object:o}}function vl(o,t,e,i,s,n,r,a,l,h){o.getVertexPosition(a,ar),o.getVertexPosition(l,lr),o.getVertexPosition(h,hr);const u=S1(o,t,e,i,ar,lr,hr,_l);if(u){s&&(gl.fromBufferAttribute(s,a),yl.fromBufferAttribute(s,l),xl.fromBufferAttribute(s,h),u.uv=Li.getInterpolation(_l,ar,lr,hr,gl,yl,xl,new q)),n&&(gl.fromBufferAttribute(n,a),yl.fromBufferAttribute(n,l),xl.fromBufferAttribute(n,h),u.uv1=Li.getInterpolation(_l,ar,lr,hr,gl,yl,xl,new q)),r&&(Ng.fromBufferAttribute(r,a),Rg.fromBufferAttribute(r,l),Eg.fromBufferAttribute(r,h),u.normal=Li.getInterpolation(_l,ar,lr,hr,Ng,Rg,Eg,new E),u.normal.dot(i.direction)>0&&u.normal.multiplyScalar(-1));const c={a,b:l,c:h,normal:new E,materialIndex:0};Li.getNormal(ar,lr,hr,c.normal),u.face=c}return u}class xa extends An{constructor(t=1,e=1,i=1,s=1,n=1,r=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:s,heightSegments:n,depthSegments:r};const a=this;s=Math.floor(s),n=Math.floor(n),r=Math.floor(r);const l=[],h=[],u=[],c=[];let d=0,p=0;f("z","y","x",-1,-1,i,e,t,r,n,0),f("z","y","x",1,-1,i,e,-t,r,n,1),f("x","z","y",1,1,t,i,e,s,r,2),f("x","z","y",1,-1,t,i,-e,s,r,3),f("x","y","z",1,-1,t,e,i,s,n,4),f("x","y","z",-1,-1,t,e,-i,s,n,5),this.setIndex(l),this.setAttribute("position",new ls(h,3)),this.setAttribute("normal",new ls(u,3)),this.setAttribute("uv",new ls(c,2));function f(m,g,y,x,M,_,v,A,T,w,U){const D=_/T,V=v/w,W=_/2,$=v/2,at=A/2,J=T+1,At=w+1;let St=0,Pt=0;const dt=new E;for(let tt=0;tt<At;tt++){const Rt=tt*V-$;for(let qt=0;qt<J;qt++){const fe=qt*D-W;dt[m]=fe*x,dt[g]=Rt*M,dt[y]=at,h.push(dt.x,dt.y,dt.z),dt[m]=0,dt[g]=0,dt[y]=A>0?1:-1,u.push(dt.x,dt.y,dt.z),c.push(qt/T),c.push(1-tt/w),St+=1}}for(let tt=0;tt<w;tt++)for(let Rt=0;Rt<T;Rt++){const qt=d+Rt+J*tt,fe=d+Rt+J*(tt+1),ti=d+(Rt+1)+J*(tt+1),ie=d+(Rt+1)+J*tt;l.push(qt,fe,ie),l.push(fe,ti,ie),Pt+=6}a.addGroup(p,Pt,U),p+=Pt,d+=St}}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new xa(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function j0(o){const t={};for(const e in o){t[e]={};for(const i in o[e]){const s=o[e][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),t[e][i]=null):t[e][i]=s.clone():Array.isArray(s)?t[e][i]=s.slice():t[e][i]=s}}return t}function w1(o){const t=[];for(let e=0;e<o.length;e++)t.push(o[e].clone());return t}var A1=`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`,N1=`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;class R1 extends Ue{constructor(t){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=A1,this.fragmentShader=N1,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&this.setValues(t)}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=j0(t.uniforms),this.uniformsGroups=w1(t.uniformsGroups),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.fog=t.fog,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const s in this.uniforms){const r=this.uniforms[s].value;r&&r.isTexture?e.uniforms[s]={type:"t",value:r.toJSON(t).uuid}:r&&r.isColor?e.uniforms[s]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[s]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[s]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[s]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[s]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[s]={type:"m4",value:r.toArray()}:e.uniforms[s]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}class X0 extends te{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Bt,this.projectionMatrix=new Bt,this.projectionMatrixInverse=new Bt,this.coordinateSystem=bi}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Es=new E,Cg=new q,Pg=new q;class is extends X0{constructor(t=50,e=1,i=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=oa*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(jo*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return oa*2*Math.atan(Math.tan(jo*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(t,e,i){Es.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set(Es.x,Es.y).multiplyScalar(-t/Es.z),Es.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(Es.x,Es.y).multiplyScalar(-t/Es.z)}getViewSize(t,e){return this.getViewBounds(t,Cg,Pg),e.subVectors(Pg,Cg)}setViewOffset(t,e,i,s,n,r){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(jo*.5*this.fov)/this.zoom,i=2*e,s=this.aspect*i,n=-.5*s;const r=this.view;if(this.view!==null&&this.view.enabled){const l=r.fullWidth,h=r.fullHeight;n+=r.offsetX*s/l,e-=r.offsetY*i/h,s*=r.width/l,i*=r.height/h}const a=this.filmOffset;a!==0&&(n+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+s,e,e-i,t,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const ur=-90,cr=1;class Y0 extends te{constructor(t,e,i){super(),this.type="CubeCamera",this.renderTarget=i,this.coordinateSystem=null,this.activeMipmapLevel=0;const s=new is(ur,cr,t,e);s.layers=this.layers,this.add(s);const n=new is(ur,cr,t,e);n.layers=this.layers,this.add(n);const r=new is(ur,cr,t,e);r.layers=this.layers,this.add(r);const a=new is(ur,cr,t,e);a.layers=this.layers,this.add(a);const l=new is(ur,cr,t,e);l.layers=this.layers,this.add(l);const h=new is(ur,cr,t,e);h.layers=this.layers,this.add(h)}updateCoordinateSystem(){const t=this.coordinateSystem,e=this.children.concat(),[i,s,n,r,a,l]=e;for(const h of e)this.remove(h);if(t===bi)i.up.set(0,1,0),i.lookAt(1,0,0),s.up.set(0,1,0),s.lookAt(-1,0,0),n.up.set(0,0,-1),n.lookAt(0,1,0),r.up.set(0,0,1),r.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(t===bn)i.up.set(0,-1,0),i.lookAt(-1,0,0),s.up.set(0,-1,0),s.lookAt(1,0,0),n.up.set(0,0,1),n.lookAt(0,1,0),r.up.set(0,0,-1),r.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+t);for(const h of e)this.add(h),h.updateMatrixWorld()}update(t,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:i,activeMipmapLevel:s}=this;this.coordinateSystem!==t.coordinateSystem&&(this.coordinateSystem=t.coordinateSystem,this.updateCoordinateSystem());const[n,r,a,l,h,u]=this.children,c=t.getRenderTarget(),d=t.getActiveCubeFace(),p=t.getActiveMipmapLevel(),f=t.xr.enabled;t.xr.enabled=!1;const m=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0,s),t.render(e,n),t.setRenderTarget(i,1,s),t.render(e,r),t.setRenderTarget(i,2,s),t.render(e,a),t.setRenderTarget(i,3,s),t.render(e,l),t.setRenderTarget(i,4,s),t.render(e,h),i.texture.generateMipmaps=m,t.setRenderTarget(i,5,s),t.render(e,u),t.setRenderTarget(c,d,p),t.xr.enabled=f,i.texture.needsPMREMUpdate=!0}}class Z0 extends Pe{constructor(t,e,i,s,n,r,a,l,h,u){t=t!==void 0?t:[],e=e!==void 0?e:Hr,super(t,e,i,s,n,r,a,l,h,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}class E1 extends d1{constructor(t=1,e={}){super(t,t,e),this.isWebGLCubeRenderTarget=!0;const i={width:t,height:t,depth:1},s=[i,i,i,i,i,i];this.texture=new Z0(s,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Le}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new xa(5,5,5),n=new R1({name:"CubemapFromEquirect",uniforms:j0(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:ms,blending:Wr});n.uniforms.tEquirect.value=e;const r=new so(s,n),a=e.minFilter;return e.minFilter===as&&(e.minFilter=Le),new Y0(1,10,this).update(t,r),e.minFilter=a,r.geometry.dispose(),r.material.dispose(),this}clear(t,e,i,s){const n=t.getRenderTarget();for(let r=0;r<6;r++)t.setRenderTarget(this,r),t.clear(e,i,s);t.setRenderTarget(n)}}class Q0 extends te{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Ye,this.environmentIntensity=1,this.environmentRotation=new Ye,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),this.backgroundBlurriness=t.backgroundBlurriness,this.backgroundIntensity=t.backgroundIntensity,this.backgroundRotation.copy(t.backgroundRotation),this.environmentIntensity=t.environmentIntensity,this.environmentRotation.copy(t.environmentRotation),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class J0{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=xh,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=Di()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}get updateRange(){return Op("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,n=this.stride;s<n;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Di()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Di()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const we=new E;class kp{constructor(t,e,i,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)we.fromBufferAttribute(this,e),we.applyMatrix4(t),this.setXYZ(e,we.x,we.y,we.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)we.fromBufferAttribute(this,e),we.applyNormalMatrix(t),this.setXYZ(e,we.x,we.y,we.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)we.fromBufferAttribute(this,e),we.transformDirection(t),this.setXYZ(e,we.x,we.y,we.z);return this}getComponent(t,e){let i=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(i=Re(i,this.array)),i}setComponent(t,e,i){return this.normalized&&(i=et(i,this.array)),this.data.array[t*this.data.stride+this.offset+e]=i,this}setX(t,e){return this.normalized&&(e=et(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=et(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=et(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=et(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=Re(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=Re(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=Re(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=Re(e,this.array)),e}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.normalized&&(e=et(e,this.array),i=et(i,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=et(e,this.array),i=et(i,this.array),s=et(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=et(e,this.array),i=et(i,this.array),s=et(s,this.array),n=et(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=n,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return new ai(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new kp(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let n=0;n<this.itemSize;n++)e.push(this.data.array[s+n])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class C1 extends Ue{constructor(t){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new nt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}class K0 extends Pe{constructor(t=null,e=1,i=1,s,n,r,a,l,h=ce,u=ce,c,d){super(null,r,a,l,h,u,s,n,c,d),this.isDataTexture=!0,this.image={data:t,width:e,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class t_ extends ai{constructor(t,e,i,s=1){super(t,e,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const sc=new E,P1=new E,F1=new hi;class Is{constructor(t=new E(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=sc.subVectors(i,e).cross(P1.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const i=t.delta(sc),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const n=-(t.start.dot(this.normal)+this.constant)/s;return n<0||n>1?null:e.copy(t.start).addScaledVector(i,n)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||F1.getNormalMatrix(t),s=this.coplanarPoint(sc).applyMatrix4(t),n=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(n),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}const en=new zp,Tl=new E;class e_{constructor(t=new Is,e=new Is,i=new Is,s=new Is,n=new Is,r=new Is){this.planes=[t,e,i,s,n,r]}set(t,e,i,s,n,r){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(s),a[4].copy(n),a[5].copy(r),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t,e=bi){const i=this.planes,s=t.elements,n=s[0],r=s[1],a=s[2],l=s[3],h=s[4],u=s[5],c=s[6],d=s[7],p=s[8],f=s[9],m=s[10],g=s[11],y=s[12],x=s[13],M=s[14],_=s[15];if(i[0].setComponents(l-n,d-h,g-p,_-y).normalize(),i[1].setComponents(l+n,d+h,g+p,_+y).normalize(),i[2].setComponents(l+r,d+u,g+f,_+x).normalize(),i[3].setComponents(l-r,d-u,g-f,_-x).normalize(),i[4].setComponents(l-a,d-c,g-m,_-M).normalize(),e===bi)i[5].setComponents(l+a,d+c,g+m,_+M).normalize();else if(e===bn)i[5].setComponents(a,c,m,M).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(t){if(t.boundingSphere!==void 0)t.boundingSphere===null&&t.computeBoundingSphere(),en.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);else{const e=t.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),en.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)}return this.intersectsSphere(en)}intersectsSprite(t){return en.center.set(0,0,0),en.radius=.7071067811865476,en.applyMatrix4(t.matrixWorld),this.intersectsSphere(en)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let n=0;n<6;n++)if(e[n].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(Tl.x=s.normal.x>0?t.max.x:t.min.x,Tl.y=s.normal.y>0?t.max.y:t.min.y,Tl.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(Tl)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class i_ extends Ue{constructor(t){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new nt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this.fog=t.fog,this}}class s_ extends Ue{constructor(t){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new nt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}class n_ extends Pe{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=ce,this.minFilter=ce,this.generateMipmaps=!1,this.needsUpdate=!0}}class _a extends Pe{constructor(t,e,i,s,n,r,a,l,h,u=yn){if(u!==yn&&u!==qr)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&u===yn&&(i=re),i===void 0&&u===qr&&(i=ma),super(null,s,n,r,a,l,u,i,h),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=a!==void 0?a:ce,this.minFilter=l!==void 0?l:ce,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}class Gp extends An{constructor(t=1,e=32,i=16,s=0,n=Math.PI*2,r=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:i,phiStart:s,phiLength:n,thetaStart:r,thetaLength:a},e=Math.max(3,Math.floor(e)),i=Math.max(2,Math.floor(i));const l=Math.min(r+a,Math.PI);let h=0;const u=[],c=new E,d=new E,p=[],f=[],m=[],g=[];for(let y=0;y<=i;y++){const x=[],M=y/i;let _=0;y===0&&r===0?_=.5/e:y===i&&l===Math.PI&&(_=-.5/e);for(let v=0;v<=e;v++){const A=v/e;c.x=-t*Math.cos(s+A*n)*Math.sin(r+M*a),c.y=t*Math.cos(r+M*a),c.z=t*Math.sin(s+A*n)*Math.sin(r+M*a),f.push(c.x,c.y,c.z),d.copy(c).normalize(),m.push(d.x,d.y,d.z),g.push(A+_,1-M),x.push(h++)}u.push(x)}for(let y=0;y<i;y++)for(let x=0;x<e;x++){const M=u[y][x+1],_=u[y][x],v=u[y+1][x],A=u[y+1][x+1];(y!==0||r>0)&&p.push(M,_,A),(y!==i-1||l<Math.PI)&&p.push(_,v,A)}this.setIndex(p),this.setAttribute("position",new ls(f,3)),this.setAttribute("normal",new ls(m,3)),this.setAttribute("uv",new ls(g,2))}copy(t){return super.copy(t),this.parameters=Object.assign({},t.parameters),this}static fromJSON(t){return new Gp(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength)}}class I1 extends Ue{constructor(t){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new nt(0),this.transparent=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.fog=t.fog,this}}class r_ extends Ue{constructor(t){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new nt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Vs,this.normalScale=new q(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ye,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class B1 extends r_{constructor(t){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new q(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ae(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new nt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new nt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new nt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(t)}get anisotropy(){return this._anisotropy}set anisotropy(t){this._anisotropy>0!=t>0&&this.version++,this._anisotropy=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get iridescence(){return this._iridescence}set iridescence(t){this._iridescence>0!=t>0&&this.version++,this._iridescence=t}get dispersion(){return this._dispersion}set dispersion(t){this._dispersion>0!=t>0&&this.version++,this._dispersion=t}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=t.anisotropy,this.anisotropyRotation=t.anisotropyRotation,this.anisotropyMap=t.anisotropyMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.dispersion=t.dispersion,this.ior=t.ior,this.iridescence=t.iridescence,this.iridescenceMap=t.iridescenceMap,this.iridescenceIOR=t.iridescenceIOR,this.iridescenceThicknessRange=[...t.iridescenceThicknessRange],this.iridescenceThicknessMap=t.iridescenceThicknessMap,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}class L1 extends Ue{constructor(t){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new nt(16777215),this.specular=new nt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Vs,this.normalScale=new q(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ye,this.combine=Hh,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class U1 extends Ue{constructor(t){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new nt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Vs,this.normalScale=new q(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}class D1 extends Ue{constructor(t){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Vs,this.normalScale=new q(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}class O1 extends Ue{constructor(t){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Vs,this.normalScale=new q(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Ye,this.combine=Hh,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class z1 extends Ue{constructor(t){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new nt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Vs,this.normalScale=new q(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this.fog=t.fog,this}}class o_ extends i_{constructor(t){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}function bl(o,t,e){return!o||!e&&o.constructor===t?o:typeof t.BYTES_PER_ELEMENT=="number"?new t(o):Array.prototype.slice.call(o)}function V1(o){return ArrayBuffer.isView(o)&&!(o instanceof DataView)}function k1(o){function t(s,n){return o[s]-o[n]}const e=o.length,i=new Array(e);for(let s=0;s!==e;++s)i[s]=s;return i.sort(t),i}function Fg(o,t,e){const i=o.length,s=new o.constructor(i);for(let n=0,r=0;r!==i;++n){const a=e[n]*t;for(let l=0;l!==t;++l)s[r++]=o[a+l]}return s}function a_(o,t,e,i){let s=1,n=o[0];for(;n!==void 0&&n[i]===void 0;)n=o[s++];if(n===void 0)return;let r=n[i];if(r!==void 0)if(Array.isArray(r))do r=n[i],r!==void 0&&(t.push(n.time),e.push.apply(e,r)),n=o[s++];while(n!==void 0);else if(r.toArray!==void 0)do r=n[i],r!==void 0&&(t.push(n.time),r.toArray(e,e.length)),n=o[s++];while(n!==void 0);else do r=n[i],r!==void 0&&(t.push(n.time),e.push(r)),n=o[s++];while(n!==void 0)}class $h{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],n=e[i-1];i:{t:{let r;e:{s:if(!(t<s)){for(let a=i+2;;){if(s===void 0){if(t<n)break s;return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===a)break;if(n=s,s=e[++i],t<s)break t}r=e.length;break e}if(!(t>=n)){const a=e[1];t<a&&(i=2,n=a);for(let l=i-2;;){if(n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===l)break;if(s=n,n=e[--i-1],t>=n)break t}r=i,i=0;break e}break i}for(;i<r;){const a=i+r>>>1;t<e[a]?r=a:i=a+1}if(s=e[i],n=e[i-1],n===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return i=e.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,n,s)}return this.interpolate_(i,n,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,n=t*s;for(let r=0;r!==s;++r)e[r]=i[n+r];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class G1 extends $h{constructor(t,e,i,s){super(t,e,i,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:wr,endingEnd:wr}}intervalChanged_(t,e,i){const s=this.parameterPositions;let n=t-2,r=t+1,a=s[n],l=s[r];if(a===void 0)switch(this.getSettings_().endingStart){case Ar:n=t,a=2*e-i;break;case yh:n=s.length-2,a=e+s[n]-s[n+1];break;default:n=t,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case Ar:r=t,l=2*i-e;break;case yh:r=1,l=i+s[1]-s[0];break;default:r=t-1,l=e}const h=(i-e)*.5,u=this.valueSize;this._weightPrev=h/(e-a),this._weightNext=h/(l-i),this._offsetPrev=n*u,this._offsetNext=r*u}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,l=t*a,h=l-a,u=this._offsetPrev,c=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(i-e)/(s-e),m=f*f,g=m*f,y=-d*g+2*d*m-d*f,x=(1+d)*g+(-1.5-2*d)*m+(-.5+d)*f+1,M=(-1-p)*g+(1.5+p)*m+.5*f,_=p*g-p*m;for(let v=0;v!==a;++v)n[v]=y*r[u+v]+x*r[h+v]+M*r[l+v]+_*r[c+v];return n}}class l_ extends $h{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,l=t*a,h=l-a,u=(i-e)/(s-e),c=1-u;for(let d=0;d!==a;++d)n[d]=r[h+d]*c+r[l+d]*u;return n}}class W1 extends $h{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}}class Gi{constructor(t,e,i,s){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=bl(e,this.TimeBufferType),this.values=bl(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:bl(t.times,Array),values:bl(t.values,Array)};const s=t.getInterpolation();s!==t.DefaultInterpolation&&(i.interpolation=s)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new W1(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new l_(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new G1(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case gh:e=this.InterpolantFactoryMethodDiscrete;break;case Fd:e=this.InterpolantFactoryMethodLinear;break;case zu:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return gh;case this.InterpolantFactoryMethodLinear:return Fd;case this.InterpolantFactoryMethodSmooth:return zu}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let n=0,r=s-1;for(;n!==s&&i[n]<t;)++n;for(;r!==-1&&i[r]>e;)--r;if(++r,n!==0||r!==s){n>=r&&(r=Math.max(r,1),n=r-1);const a=this.getValueSize();this.times=i.slice(n,r),this.values=this.values.slice(n*a,r*a)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,n=i.length;n===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let r=null;for(let a=0;a!==n;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),t=!1;break}if(r!==null&&r>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,r),t=!1;break}r=l}if(s!==void 0&&V1(s))for(let a=0,l=s.length;a!==l;++a){const h=s[a];if(isNaN(h)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,h),t=!1;break}}return t}optimize(){const t=this.times.slice(),e=this.values.slice(),i=this.getValueSize(),s=this.getInterpolation()===zu,n=t.length-1;let r=1;for(let a=1;a<n;++a){let l=!1;const h=t[a],u=t[a+1];if(h!==u&&(a!==1||h!==t[0]))if(s)l=!0;else{const c=a*i,d=c-i,p=c+i;for(let f=0;f!==i;++f){const m=e[c+f];if(m!==e[d+f]||m!==e[p+f]){l=!0;break}}}if(l){if(a!==r){t[r]=t[a];const c=a*i,d=r*i;for(let p=0;p!==i;++p)e[d+p]=e[c+p]}++r}}if(n>0){t[r]=t[n];for(let a=n*i,l=r*i,h=0;h!==i;++h)e[l+h]=e[a+h];++r}return r!==t.length?(this.times=t.slice(0,r),this.values=e.slice(0,r*i)):(this.times=t,this.values=e),this}clone(){const t=this.times.slice(),e=this.values.slice(),i=this.constructor,s=new i(this.name,t,e);return s.createInterpolant=this.createInterpolant,s}}Gi.prototype.TimeBufferType=Float32Array;Gi.prototype.ValueBufferType=Float32Array;Gi.prototype.DefaultInterpolation=Fd;class no extends Gi{constructor(t,e,i){super(t,e,i)}}no.prototype.ValueTypeName="bool";no.prototype.ValueBufferType=Array;no.prototype.DefaultInterpolation=gh;no.prototype.InterpolantFactoryMethodLinear=void 0;no.prototype.InterpolantFactoryMethodSmooth=void 0;class h_ extends Gi{}h_.prototype.ValueTypeName="color";class _h extends Gi{}_h.prototype.ValueTypeName="number";class H1 extends $h{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const n=this.resultBuffer,r=this.sampleValues,a=this.valueSize,l=(i-e)/(s-e);let h=t*a;for(let u=h+a;h!==u;h+=4)je.slerpFlat(n,0,r,h-a,r,h,l);return n}}class qh extends Gi{InterpolantFactoryMethodLinear(t){return new H1(this.times,this.values,this.getValueSize(),t)}}qh.prototype.ValueTypeName="quaternion";qh.prototype.InterpolantFactoryMethodSmooth=void 0;class ro extends Gi{constructor(t,e,i){super(t,e,i)}}ro.prototype.ValueTypeName="string";ro.prototype.ValueBufferType=Array;ro.prototype.DefaultInterpolation=gh;ro.prototype.InterpolantFactoryMethodLinear=void 0;ro.prototype.InterpolantFactoryMethodSmooth=void 0;class Mh extends Gi{}Mh.prototype.ValueTypeName="vector";class Ig{constructor(t="",e=-1,i=[],s=Lp){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=Di(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let r=0,a=i.length;r!==a;++r)e.push(q1(i[r]).scale(s));const n=new this(t.name,t.duration,e,t.blendMode);return n.uuid=t.uuid,n}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let n=0,r=i.length;n!==r;++n)e.push(Gi.toJSON(i[n]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const n=e.length,r=[];for(let a=0;a<n;a++){let l=[],h=[];l.push((a+n-1)%n,a,(a+1)%n),h.push(0,1,0);const u=k1(l);l=Fg(l,1,u),h=Fg(h,1,u),!s&&l[0]===0&&(l.push(n),h.push(h[0])),r.push(new _h(".morphTargetInfluences["+e[a].name+"]",l,h).scale(1/i))}return new this(t,-1,r)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const s=t;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===e)return i[s];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},n=/^([\w-]*?)([\d]+)$/;for(let a=0,l=t.length;a<l;a++){const h=t[a],u=h.name.match(n);if(u&&u.length>1){const c=u[1];let d=s[c];d||(s[c]=d=[]),d.push(h)}}const r=[];for(const a in s)r.push(this.CreateFromMorphTargetSequence(a,s[a],e,i));return r}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(c,d,p,f,m){if(p.length!==0){const g=[],y=[];a_(p,g,y,f),g.length!==0&&m.push(new c(d,g,y))}},s=[],n=t.name||"default",r=t.fps||30,a=t.blendMode;let l=t.length||-1;const h=t.hierarchy||[];for(let c=0;c<h.length;c++){const d=h[c].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let m=0;m<d[f].morphTargets.length;m++)p[d[f].morphTargets[m]]=-1;for(const m in p){const g=[],y=[];for(let x=0;x!==d[f].morphTargets.length;++x){const M=d[f];g.push(M.time),y.push(M.morphTarget===m?1:0)}s.push(new _h(".morphTargetInfluence["+m+"]",g,y))}l=p.length*r}else{const p=".bones["+e[c].name+"]";i(Mh,p+".position",d,"pos",s),i(qh,p+".quaternion",d,"rot",s),i(Mh,p+".scale",d,"scl",s)}}return s.length===0?null:new this(n,l,s,a)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,s=t.length;i!==s;++i){const n=this.tracks[i];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function $1(o){switch(o.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return _h;case"vector":case"vector2":case"vector3":case"vector4":return Mh;case"color":return h_;case"quaternion":return qh;case"bool":case"boolean":return no;case"string":return ro}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+o)}function q1(o){if(o.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=$1(o.type);if(o.times===void 0){const e=[],i=[];a_(o.keys,e,i,"value"),o.times=e,o.values=i}return t.parse!==void 0?t.parse(o):new t(o.name,o.times,o.values,o.interpolation)}class oo extends te{constructor(t,e=1){super(),this.isLight=!0,this.type="Light",this.color=new nt(t),this.intensity=e}dispose(){}copy(t,e){return super.copy(t,e),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(e.object.target=this.target.uuid),e}}class j1 extends oo{constructor(t,e,i){super(t,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(te.DEFAULT_UP),this.updateMatrix(),this.groundColor=new nt(e)}copy(t,e){return super.copy(t,e),this.groundColor.copy(t.groundColor),this}}const nc=new Bt,Bg=new E,Lg=new E;class Wp{constructor(t){this.camera=t,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new q(512,512),this.map=null,this.mapPass=null,this.matrix=new Bt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new e_,this._frameExtents=new q(1,1),this._viewportCount=1,this._viewports=[new _t(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;Bg.setFromMatrixPosition(t.matrixWorld),e.position.copy(Bg),Lg.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Lg),e.updateMatrixWorld(),nc.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(nc),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(nc)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.intensity=t.intensity,this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.intensity!==1&&(t.intensity=this.intensity),this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class X1 extends Wp{constructor(){super(new is(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(t){const e=this.camera,i=oa*2*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,n=t.distance||e.far;(i!==e.fov||s!==e.aspect||n!==e.far)&&(e.fov=i,e.aspect=s,e.far=n,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}class u_ extends oo{constructor(t,e,i=0,s=Math.PI/3,n=0,r=2){super(t,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(te.DEFAULT_UP),this.updateMatrix(),this.target=new te,this.distance=i,this.angle=s,this.penumbra=n,this.decay=r,this.map=null,this.shadow=new X1}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}const Ug=new Bt,Ao=new E,rc=new E;class Y1 extends Wp{constructor(){super(new is(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new q(4,2),this._viewportCount=6,this._viewports=[new _t(2,1,1,1),new _t(0,1,1,1),new _t(3,1,1,1),new _t(1,1,1,1),new _t(3,0,1,1),new _t(1,0,1,1)],this._cubeDirections=[new E(1,0,0),new E(-1,0,0),new E(0,0,1),new E(0,0,-1),new E(0,1,0),new E(0,-1,0)],this._cubeUps=[new E(0,1,0),new E(0,1,0),new E(0,1,0),new E(0,1,0),new E(0,0,1),new E(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,n=t.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),Ao.setFromMatrixPosition(t.matrixWorld),i.position.copy(Ao),rc.copy(i.position),rc.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(rc),i.updateMatrixWorld(),s.makeTranslation(-Ao.x,-Ao.y,-Ao.z),Ug.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ug)}}class Z1 extends oo{constructor(t,e,i=0,s=2){super(t,e),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new Y1}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t,e){return super.copy(t,e),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}class Hp extends X0{constructor(t=-1,e=1,i=1,s=-1,n=.1,r=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=n,this.far=r,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,n,r){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=n,this.view.height=r,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let n=i-t,r=i+t,a=s+e,l=s-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=h*this.view.offsetX,r=n+h*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(n,r,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class Q1 extends Wp{constructor(){super(new Hp(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class J1 extends oo{constructor(t,e){super(t,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(te.DEFAULT_UP),this.updateMatrix(),this.target=new te,this.shadow=new Q1}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}class K1 extends oo{constructor(t,e){super(t,e),this.isAmbientLight=!0,this.type="AmbientLight"}}class tA extends oo{constructor(t,e,i=10,s=10){super(t,e),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}class ZD{constructor(t=!0){this.autoStart=t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Dg(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=Dg();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}function Dg(){return(typeof performance>"u"?Date:performance).now()}class eA{constructor(t,e,i){this.binding=t,this.valueSize=i;let s,n,r;switch(e){case"quaternion":s=this._slerp,n=this._slerpAdditive,r=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":s=this._select,n=this._select,r=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:s=this._lerp,n=this._lerpAdditive,r=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=n,this._setIdentity=r,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,s=this.valueSize,n=t*s+s;let r=this.cumulativeWeight;if(r===0){for(let a=0;a!==s;++a)i[n+a]=i[a];r=e}else{r+=e;const a=e/r;this._mixBufferRegion(i,n,0,a,s)}this.cumulativeWeight=r}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,s=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,s,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,s=t*e+e,n=this.cumulativeWeight,r=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,n<1){const l=e*this._origIndex;this._mixBufferRegion(i,s,l,1-n,e)}r>0&&this._mixBufferRegionAdditive(i,s,this._addIndex*e,1,e);for(let l=e,h=e+e;l!==h;++l)if(i[l]!==i[l+e]){a.setValue(i,s);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,s=i*this._origIndex;t.getValue(e,s);for(let n=i,r=s;n!==r;++n)e[n]=e[s+n%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,s,n){if(s>=.5)for(let r=0;r!==n;++r)t[e+r]=t[i+r]}_slerp(t,e,i,s){je.slerpFlat(t,e,t,e,t,i,s)}_slerpAdditive(t,e,i,s,n){const r=this._workIndex*n;je.multiplyQuaternionsFlat(t,r,t,e,t,i),je.slerpFlat(t,e,t,e,t,r,s)}_lerp(t,e,i,s,n){const r=1-s;for(let a=0;a!==n;++a){const l=e+a;t[l]=t[l]*r+t[i+a]*s}}_lerpAdditive(t,e,i,s,n){for(let r=0;r!==n;++r){const a=e+r;t[a]=t[a]+t[i+r]*s}}}const $p="\\[\\]\\.:\\/",iA=new RegExp("["+$p+"]","g"),qp="[^"+$p+"]",sA="[^"+$p.replace("\\.","")+"]",nA=/((?:WC+[\/:])*)/.source.replace("WC",qp),rA=/(WCOD+)?/.source.replace("WCOD",sA),oA=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",qp),aA=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",qp),lA=new RegExp("^"+nA+rA+oA+aA+"$"),hA=["material","materials","bones","map"];class uA{constructor(t,e,i){const s=i||vt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,s)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];s!==void 0&&s.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,n=i.length;s!==n;++s)i[s].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}}class vt{constructor(t,e,i){this.path=e,this.parsedPath=i||vt.parseTrackName(e),this.node=vt.findNode(t,this.parsedPath.nodeName),this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new vt.Composite(t,e,i):new vt(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(iA,"")}static parseTrackName(t){const e=lA.exec(t);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const n=i.nodeName.substring(s+1);hA.indexOf(n)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=n)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(e===void 0||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(n){for(let r=0;r<n.length;r++){const a=n[r];if(a.name===e||a.uuid===e)return a;const l=i(a.children);if(l)return l}return null},s=i(t.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)t[e++]=i[s]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,n=i.length;s!==n;++s)i[s]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,s=e.propertyName;let n=e.propertyIndex;if(t||(t=vt.findNode(this.rootNode,e.nodeName),this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(i){let h=e.objectIndex;switch(i){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let u=0;u<t.length;u++)if(t[u].name===h){h=u;break}break;case"map":if("map"in t){t=t.map;break}if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}t=t.material.map;break;default:if(t[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[i]}if(h!==void 0){if(t[h]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[h]}}const r=t[s];if(r===void 0){const h=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+h+"."+s+" but it wasn't found.",t);return}let a=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(n!==void 0){if(s==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[n]!==void 0&&(n=t.morphTargetDictionary[n])}l=this.BindingType.ArrayElement,this.resolvedProperty=r,this.propertyIndex=n}else r.fromArray!==void 0&&r.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=r):Array.isArray(r)?(l=this.BindingType.EntireArray,this.resolvedProperty=r):this.propertyName=s;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}vt.Composite=uA;vt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};vt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};vt.prototype.GetterByBindingType=[vt.prototype._getValue_direct,vt.prototype._getValue_array,vt.prototype._getValue_arrayElement,vt.prototype._getValue_toArray];vt.prototype.SetterByBindingTypeAndVersioning=[[vt.prototype._setValue_direct,vt.prototype._setValue_direct_setNeedsUpdate,vt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[vt.prototype._setValue_array,vt.prototype._setValue_array_setNeedsUpdate,vt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[vt.prototype._setValue_arrayElement,vt.prototype._setValue_arrayElement_setNeedsUpdate,vt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[vt.prototype._setValue_fromArray,vt.prototype._setValue_fromArray_setNeedsUpdate,vt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class cA{constructor(t,e,i=null,s=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=s;const n=e.tracks,r=n.length,a=new Array(r),l={endingStart:wr,endingEnd:wr};for(let h=0;h!==r;++h){const u=n[h].createInterpolant(null);a[h]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(r),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Aw,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const s=this._clip.duration,n=t._clip.duration,r=n/s,a=s/n;t.warp(1,r,e),this.warp(a,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const s=this._mixer,n=s.time,r=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=s._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,h=a.sampleValues;return l[0]=n,l[1]=n+i,h[0]=t/r,h[1]=e/r,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,s){if(!this.enabled){this._updateWeight(t);return}const n=this._startTime;if(n!==null){const l=(t-n)*i;l<0||i===0?e=0:(this._startTime=null,e=i*l)}e*=this._updateTimeScale(t);const r=this._updateTime(e),a=this._updateWeight(t);if(a>0){const l=this._interpolants,h=this._propertyBindings;switch(this.blendMode){case Nw:for(let u=0,c=l.length;u!==c;++u)l[u].evaluate(r),h[u].accumulateAdditive(a);break;case Lp:default:for(let u=0,c=l.length;u!==c;++u)l[u].evaluate(r),h[u].accumulate(s,a)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(i!==null){const s=i.evaluate(t)[0];e*=s,t>i.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;if(i!==null){const s=i.evaluate(t)[0];e*=s,t>i.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e)}}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let s=this.time+t,n=this._loopCount;const r=i===C0;if(t===0)return n===-1?s:r&&(n&1)===1?e-s:s;if(i===E0){n===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));i:{if(s>=e)s=e;else if(s<0)s=0;else{this.time=s;break i}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(n===-1&&(t>=0?(n=0,this._setEndings(!0,this.repetitions===0,r)):this._setEndings(this.repetitions===0,!0,r)),s>=e||s<0){const a=Math.floor(s/e);s-=e*a,n+=Math.abs(a);const l=this.repetitions-n;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=t>0?e:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const h=t<0;this._setEndings(h,!h,r)}else this._setEndings(!1,!1,r);this._loopCount=n,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=s;if(r&&(n&1)===1)return e-s}return s}_setEndings(t,e,i){const s=this._interpolantSettings;i?(s.endingStart=Ar,s.endingEnd=Ar):(t?s.endingStart=this.zeroSlopeAtStart?Ar:wr:s.endingStart=yh,e?s.endingEnd=this.zeroSlopeAtEnd?Ar:wr:s.endingEnd=yh)}_scheduleFading(t,e,i){const s=this._mixer,n=s.time;let r=this._weightInterpolant;r===null&&(r=s._lendControlInterpolant(),this._weightInterpolant=r);const a=r.parameterPositions,l=r.sampleValues;return a[0]=n,l[0]=e,a[1]=n+t,l[1]=i,this}}const dA=new Float32Array(1);class pA extends Hs{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,s=t._clip.tracks,n=s.length,r=t._propertyBindings,a=t._interpolants,l=i.uuid,h=this._bindingsByRootAndName;let u=h[l];u===void 0&&(u={},h[l]=u);for(let c=0;c!==n;++c){const d=s[c],p=d.name;let f=u[p];if(f!==void 0)++f.referenceCount,r[c]=f;else{if(f=r[c],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const m=e&&e._propertyBindings[c].binding.parsedPath;f=new eA(vt.create(i,p,m),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),r[c]=f}a[c].resultBuffer=f.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const i=(t._localRoot||this._root).uuid,s=t._clip.uuid,n=this._actionsByClip[s];this._bindAction(t,n&&n.knownActions[0]),this._addInactiveAction(t,s,i)}const e=t._propertyBindings;for(let i=0,s=e.length;i!==s;++i){const n=e[i];n.useCount++===0&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let i=0,s=e.length;i!==s;++i){const n=e[i];--n.useCount===0&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,i){const s=this._actions,n=this._actionsByClip;let r=n[e];if(r===void 0)r={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,n[e]=r;else{const a=r.knownActions;t._byClipCacheIndex=a.length,a.push(t)}t._cacheIndex=s.length,s.push(t),r.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],s=t._cacheIndex;i._cacheIndex=s,e[s]=i,e.pop(),t._cacheIndex=null;const n=t._clip.uuid,r=this._actionsByClip,a=r[n],l=a.knownActions,h=l[l.length-1],u=t._byClipCacheIndex;h._byClipCacheIndex=u,l[u]=h,l.pop(),t._byClipCacheIndex=null;const c=a.actionByRoot,d=(t._localRoot||this._root).uuid;delete c[d],l.length===0&&delete r[n],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let i=0,s=e.length;i!==s;++i){const n=e[i];--n.referenceCount===0&&this._removeInactiveBinding(n)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,s=this._nActiveActions++,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,s=--this._nActiveActions,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_addInactiveBinding(t,e,i){const s=this._bindingsByRootAndName,n=this._bindings;let r=s[e];r===void 0&&(r={},s[e]=r),r[i]=t,t._cacheIndex=n.length,n.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,s=i.rootNode.uuid,n=i.path,r=this._bindingsByRootAndName,a=r[s],l=e[e.length-1],h=t._cacheIndex;l._cacheIndex=h,e[h]=l,e.pop(),delete a[n],Object.keys(a).length===0&&delete r[s]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,s=this._nActiveBindings++,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,s=--this._nActiveBindings,n=e[s];t._cacheIndex=s,e[s]=t,n._cacheIndex=i,e[i]=n}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return i===void 0&&(i=new l_(new Float32Array(2),new Float32Array(2),1,dA),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,s=--this._nActiveControlInterpolants,n=e[s];t.__cacheIndex=s,e[s]=t,n.__cacheIndex=i,e[i]=n}clipAction(t,e,i){const s=e||this._root,n=s.uuid;let r=typeof t=="string"?Ig.findByName(s,t):t;const a=r!==null?r.uuid:t,l=this._actionsByClip[a];let h=null;if(i===void 0&&(r!==null?i=r.blendMode:i=Lp),l!==void 0){const c=l.actionByRoot[n];if(c!==void 0&&c.blendMode===i)return c;h=l.knownActions[0],r===null&&(r=h._clip)}if(r===null)return null;const u=new cA(this,r,e,i);return this._bindAction(u,h),this._addInactiveAction(u,a,n),u}existingAction(t,e){const i=e||this._root,s=i.uuid,n=typeof t=="string"?Ig.findByName(i,t):t,r=n?n.uuid:t,a=this._actionsByClip[r];return a!==void 0&&a.actionByRoot[s]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let i=e-1;i>=0;--i)t[i].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,s=this.time+=t,n=Math.sign(t),r=this._accuIndex^=1;for(let h=0;h!==i;++h)e[h]._update(s,t,n,r);const a=this._bindings,l=this._nActiveBindings;for(let h=0;h!==l;++h)a[h].apply(r);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,s=this._actionsByClip,n=s[i];if(n!==void 0){const r=n.knownActions;for(let a=0,l=r.length;a!==l;++a){const h=r[a];this._deactivateAction(h);const u=h._cacheIndex,c=e[e.length-1];h._cacheIndex=null,h._byClipCacheIndex=null,c._cacheIndex=u,e[u]=c,e.pop(),this._removeInactiveBindingsForAction(h)}delete s[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const r in i){const a=i[r].actionByRoot,l=a[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const s=this._bindingsByRootAndName,n=s[e];if(n!==void 0)for(const r in n){const a=n[r];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(t,e){const i=this.existingAction(t,e);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class fA extends J0{constructor(t,e,i=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}const Og=new Bt;class QD{constructor(t,e,i=0,s=1/0){this.ray=new k0(t,e),this.near=i,this.far=s,this.camera=null,this.layers=new G0,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,e){this.ray.set(t,e)}setFromCamera(t,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}setFromXRController(t){return Og.identity().extractRotation(t.matrixWorld),this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(Og),this}intersectObject(t,e=!0,i=[]){return Ud(t,this,i,e),i.sort(zg),i}intersectObjects(t,e=!0,i=[]){for(let s=0,n=t.length;s<n;s++)Ud(t[s],this,i,e);return i.sort(zg),i}}function zg(o,t){return o.distance-t.distance}function Ud(o,t,e,i){let s=!0;if(o.layers.test(t.layers)&&o.raycast(t,e)===!1&&(s=!1),s===!0&&i===!0){const n=o.children;for(let r=0,a=n.length;r<a;r++)Ud(n[r],t,e,!0)}}self.GPUShaderStage===void 0&&(self.GPUShaderStage={VERTEX:1,FRAGMENT:2,COMPUTE:4});let vh=navigator.gpu!==void 0;typeof window<"u"&&vh&&(vh=await navigator.gpu.requestAdapter());class mA{static isAvailable(){return!!vh}static getStaticAdapter(){return vh}static getErrorMessage(){const t='Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a> yet',e=document.createElement("div");return e.id="webgpumessage",e.style.fontFamily="monospace",e.style.fontSize="13px",e.style.fontWeight="normal",e.style.textAlign="center",e.style.background="#fff",e.style.color="#000",e.style.padding="1.5em",e.style.maxWidth="400px",e.style.margin="5em auto 0",e.innerHTML=t,e}}class gA{constructor(t,e){this.nodes=t,this.info=e,this.animationLoop=null,this.requestId=null,this._init()}_init(){const t=(e,i)=>{this.requestId=self.requestAnimationFrame(t),this.info.autoReset===!0&&this.info.reset(),this.nodes.nodeFrame.update(),this.info.frame=this.nodes.nodeFrame.frameId,this.animationLoop!==null&&this.animationLoop(e,i)};t()}dispose(){self.cancelAnimationFrame(this.requestId),this.requestId=null}setAnimationLoop(t){this.animationLoop=t}}class hs{constructor(){this.weakMap=new WeakMap}get(t){let e=this.weakMap;for(let i=0;i<t.length;i++)if(e=e.get(t[i]),e===void 0)return;return e.get(t[t.length-1])}set(t,e){let i=this.weakMap;for(let s=0;s<t.length;s++){const n=t[s];i.has(n)===!1&&i.set(n,new WeakMap),i=i.get(n)}return i.set(t[t.length-1],e)}delete(t){let e=this.weakMap;for(let i=0;i<t.length;i++)if(e=e.get(t[i]),e===void 0)return!1;return e.delete(t[t.length-1])}}const oc=new Is;let ac=0;class Dd{constructor(){this.version=++ac,this.globalClippingCount=0,this.localClippingCount=0,this.localClippingEnabled=!1,this.localClipIntersection=!1,this.planes=[],this.parentVersion=0,this.viewNormalMatrix=new hi}projectPlanes(t,e){const i=t.length,s=this.planes;for(let n=0;n<i;n++){oc.copy(t[n]).applyMatrix4(this.viewMatrix,this.viewNormalMatrix);const r=s[e+n],a=oc.normal;r.x=-a.x,r.y=-a.y,r.z=-a.z,r.w=oc.constant}}updateGlobal(t,e){const i=t.clippingPlanes;this.viewMatrix=e.matrixWorldInverse,this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);let s=!1;if(Array.isArray(i)&&i.length!==0){const n=i.length;if(n!==this.globalClippingCount){const r=[];for(let a=0;a<n;a++)r.push(new _t);this.globalClippingCount=n,this.planes=r,s=!0}this.projectPlanes(i,0)}else this.globalClippingCount!==0&&(this.globalClippingCount=0,this.planes=[],s=!0);t.localClippingEnabled!==this.localClippingEnabled&&(this.localClippingEnabled=t.localClippingEnabled,s=!0),s&&(this.version=ac++)}update(t,e){let i=!1;if(this!==t&&t.version!==this.parentVersion&&(this.globalClippingCount=e.isShadowNodeMaterial?0:t.globalClippingCount,this.localClippingEnabled=t.localClippingEnabled,this.planes=Array.from(t.planes),this.parentVersion=t.version,this.viewMatrix=t.viewMatrix,this.viewNormalMatrix=t.viewNormalMatrix,i=!0),this.localClippingEnabled){const s=e.clippingPlanes;if(Array.isArray(s)&&s.length!==0){const n=s.length,r=this.planes,a=this.globalClippingCount;if(i||n!==this.localClippingCount){r.length=a+n;for(let l=0;l<n;l++)r[a+l]=new _t;this.localClippingCount=n,i=!0}this.projectPlanes(s,a)}else this.localClippingCount!==0&&(this.localClippingCount=0,i=!0);this.localClipIntersection!==e.clipIntersection&&(this.localClipIntersection=e.clipIntersection,i=!0)}i&&(this.version=ac++)}}let yA=0;function xA(o){const t=Object.keys(o);let e=Object.getPrototypeOf(o);for(;e;){const i=Object.getOwnPropertyDescriptors(e);for(const s in i)if(i[s]!==void 0){const n=i[s];n&&typeof n.get=="function"&&t.push(s)}e=Object.getPrototypeOf(e)}return t}class _A{constructor(t,e,i,s,n,r,a,l,h){this._nodes=t,this._geometries=e,this.id=yA++,this.renderer=i,this.object=s,this.material=n,this.scene=r,this.camera=a,this.lightsNode=l,this.context=h,this.geometry=s.geometry,this.version=n.version,this.drawRange=null,this.attributes=null,this.pipeline=null,this.vertexBuffers=null,this.updateClipping(h.clippingContext),this.clippingContextVersion=this.clippingContext.version,this.initialNodesCacheKey=this.getDynamicCacheKey(),this.initialCacheKey=this.getCacheKey(),this._nodeBuilderState=null,this._bindings=null,this.onDispose=null,this.isRenderObject=!0,this.onMaterialDispose=()=>{this.dispose()},this.material.addEventListener("dispose",this.onMaterialDispose)}updateClipping(t){const e=this.material;let i=this.clippingContext;Array.isArray(e.clippingPlanes)?((i===t||!i)&&(i=new Dd,this.clippingContext=i),i.update(t,e)):this.clippingContext!==t&&(this.clippingContext=t)}get clippingNeedsUpdate(){return this.clippingContext.version===this.clippingContextVersion?!1:(this.clippingContextVersion=this.clippingContext.version,!0)}getNodeBuilderState(){return this._nodeBuilderState||(this._nodeBuilderState=this._nodes.getForRender(this))}getBindings(){return this._bindings||(this._bindings=this.getNodeBuilderState().createBindings())}getIndex(){return this._geometries.getIndex(this)}getChainArray(){return[this.object,this.material,this.context,this.lightsNode]}getAttributes(){if(this.attributes!==null)return this.attributes;const t=this.getNodeBuilderState().nodeAttributes,e=this.geometry,i=[],s=new Set;for(const n of t){const r=n.node&&n.node.attribute?n.node.attribute:e.getAttribute(n.name);if(r===void 0)continue;i.push(r);const a=r.isInterleavedBufferAttribute?r.data:r;s.add(a)}return this.attributes=i,this.vertexBuffers=Array.from(s.values()),i}getVertexBuffers(){return this.vertexBuffers===null&&this.getAttributes(),this.vertexBuffers}getMaterialCacheKey(){const{object:t,material:e}=this;let i=e.customProgramCacheKey();for(const s of xA(e)){if(/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(s))continue;const n=e[s];let r;if(n!==null){const a=typeof n;a==="number"?r=n!==0?"1":"0":a==="object"?(r="{",n.isTexture&&(r+=n.mapping),r+="}"):r=String(n)}else r=String(n);i+=r+","}return i+=this.clippingContextVersion+",",t.skeleton&&(i+=t.skeleton.bones.length+","),t.morphTargetInfluences&&(i+=t.morphTargetInfluences.length+","),t.isBatchedMesh&&(i+=t._matricesTexture.uuid+",",t._colorsTexture!==null&&(i+=t._colorsTexture.uuid+",")),t.count>1&&(i+=t.count+","),i}get needsUpdate(){return this.initialNodesCacheKey!==this.getDynamicCacheKey()||this.clippingNeedsUpdate}getDynamicCacheKey(){return this.object.receiveShadow+","+this._nodes.getCacheKey(this.scene,this.lightsNode)}getCacheKey(){return this.getMaterialCacheKey()+","+this.getDynamicCacheKey()}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.onDispose()}}class MA{constructor(t,e,i,s,n,r){this.renderer=t,this.nodes=e,this.geometries=i,this.pipelines=s,this.bindings=n,this.info=r,this.chainMaps={}}get(t,e,i,s,n,r,a){const l=this.getChainMap(a),h=[t,e,r,n];let u=l.get(h);return u===void 0?(u=this.createRenderObject(this.nodes,this.geometries,this.renderer,t,e,i,s,n,r,a),l.set(h,u)):(u.updateClipping(r.clippingContext),(u.version!==e.version||u.needsUpdate)&&(u.initialCacheKey!==u.getCacheKey()?(u.dispose(),u=this.get(t,e,i,s,n,r,a)):u.version=e.version)),u}getChainMap(t="default"){return this.chainMaps[t]||(this.chainMaps[t]=new hs)}dispose(){this.chainMaps={}}createRenderObject(t,e,i,s,n,r,a,l,h,u){const c=this.getChainMap(u),d=new _A(t,e,i,s,n,r,a,l,h);return d.onDispose=()=>{this.pipelines.delete(d),this.bindings.delete(d),this.nodes.delete(d),c.delete(d.getChainArray())},d}}class Nn{constructor(){this.data=new WeakMap}get(t){let e=this.data.get(t);return e===void 0&&(e={},this.data.set(t,e)),e}delete(t){let e;return this.data.has(t)&&(e=this.data.get(t),this.data.delete(t)),e}has(t){return this.data.has(t)}dispose(){this.data=new WeakMap}}const xn={VERTEX:1,INDEX:2,STORAGE:4},Ls=16,vA=211,TA=212;class bA extends Nn{constructor(t){super(),this.backend=t}delete(t){const e=super.delete(t);return e!==void 0&&this.backend.destroyAttribute(t),e}update(t,e){const i=this.get(t);if(i.version===void 0)e===xn.VERTEX?this.backend.createAttribute(t):e===xn.INDEX?this.backend.createIndexAttribute(t):e===xn.STORAGE&&this.backend.createStorageAttribute(t),i.version=this._getBufferAttribute(t).version;else{const s=this._getBufferAttribute(t);(i.version<s.version||s.usage===Nr)&&(this.backend.updateAttribute(t),i.version=s.version)}}_getBufferAttribute(t){return t.isInterleavedBufferAttribute&&(t=t.data),t}}function SA(o){for(let t=o.length-1;t>=0;--t)if(o[t]>=65535)return!0;return!1}function c_(o){return o.index!==null?o.index.version:o.attributes.position.version}function Vg(o){const t=[],e=o.index,i=o.attributes.position;if(e!==null){const n=e.array;for(let r=0,a=n.length;r<a;r+=3){const l=n[r+0],h=n[r+1],u=n[r+2];t.push(l,h,h,u,u,l)}}else{const n=i.array;for(let r=0,a=n.length/3-1;r<a;r+=3){const l=r+0,h=r+1,u=r+2;t.push(l,h,h,u,u,l)}}const s=new(SA(t)?$0:H0)(t,1);return s.version=c_(o),s}class wA extends Nn{constructor(t,e){super(),this.attributes=t,this.info=e,this.wireframes=new WeakMap,this.attributeCall=new WeakMap}has(t){const e=t.geometry;return super.has(e)&&this.get(e).initialized===!0}updateForRender(t){this.has(t)===!1&&this.initGeometry(t),this.updateAttributes(t)}initGeometry(t){const e=t.geometry,i=this.get(e);i.initialized=!0,this.info.memory.geometries++;const s=()=>{this.info.memory.geometries--;const n=e.index,r=t.getAttributes();n!==null&&this.attributes.delete(n);for(const l of r)this.attributes.delete(l);const a=this.wireframes.get(e);a!==void 0&&this.attributes.delete(a),e.removeEventListener("dispose",s)};e.addEventListener("dispose",s)}updateAttributes(t){const e=t.getAttributes();for(const s of e)s.isStorageBufferAttribute||s.isStorageInstancedBufferAttribute?this.updateAttribute(s,xn.STORAGE):this.updateAttribute(s,xn.VERTEX);const i=this.getIndex(t);i!==null&&this.updateAttribute(i,xn.INDEX)}updateAttribute(t,e){const i=this.info.render.calls;t.isInterleavedBufferAttribute?this.attributeCall.get(t)===void 0?(this.attributes.update(t,e),this.attributeCall.set(t,i)):this.attributeCall.get(t.data)!==i&&(this.attributes.update(t,e),this.attributeCall.set(t.data,i),this.attributeCall.set(t,i)):this.attributeCall.get(t)!==i&&(this.attributes.update(t,e),this.attributeCall.set(t,i))}getIndex(t){const{geometry:e,material:i}=t;let s=e.index;if(i.wireframe===!0){const n=this.wireframes;let r=n.get(e);r===void 0?(r=Vg(e),n.set(e,r)):r.version!==c_(e)&&(this.attributes.delete(r),r=Vg(e),n.set(e,r)),s=r}return s}}class AA{constructor(){this.autoReset=!0,this.frame=0,this.calls=0,this.render={calls:0,frameCalls:0,drawCalls:0,triangles:0,points:0,lines:0,timestamp:0,previousFrameCalls:0,timestampCalls:0},this.compute={calls:0,frameCalls:0,timestamp:0,previousFrameCalls:0,timestampCalls:0},this.memory={geometries:0,textures:0}}update(t,e,i){this.render.drawCalls++,t.isMesh||t.isSprite?this.render.triangles+=i*(e/3):t.isPoints?this.render.points+=i*e:t.isLineSegments?this.render.lines+=i*(e/2):t.isLine?this.render.lines+=i*(e-1):console.error("THREE.WebGPUInfo: Unknown object type.")}updateTimestamp(t,e){this[t].timestampCalls===0&&(this[t].timestamp=0),this[t].timestamp+=e,this[t].timestampCalls++,this[t].timestampCalls>=this[t].previousFrameCalls&&(this[t].timestampCalls=0)}reset(){const t=this.render.frameCalls;this.render.previousFrameCalls=t;const e=this.compute.frameCalls;this.compute.previousFrameCalls=e,this.render.drawCalls=0,this.render.frameCalls=0,this.compute.frameCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0}dispose(){this.reset(),this.calls=0,this.render.calls=0,this.compute.calls=0,this.render.timestamp=0,this.compute.timestamp=0,this.memory.geometries=0,this.memory.textures=0}}class d_{constructor(t){this.cacheKey=t,this.usedTimes=0}}class NA extends d_{constructor(t,e,i){super(t),this.vertexProgram=e,this.fragmentProgram=i}}class RA extends d_{constructor(t,e){super(t),this.computeProgram=e,this.isComputePipeline=!0}}let EA=0;class lc{constructor(t,e,i=null,s=null){this.id=EA++,this.code=t,this.stage=e,this.transforms=i,this.attributes=s,this.usedTimes=0}}class CA extends Nn{constructor(t,e){super(),this.backend=t,this.nodes=e,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(t,e){const{backend:i}=this,s=this.get(t);if(this._needsComputeUpdate(t)){const n=s.pipeline;n&&(n.usedTimes--,n.computeProgram.usedTimes--);const r=this.nodes.getForCompute(t);let a=this.programs.compute.get(r.computeShader);a===void 0&&(n&&n.computeProgram.usedTimes===0&&this._releaseProgram(n.computeProgram),a=new lc(r.computeShader,"compute",r.transforms,r.nodeAttributes),this.programs.compute.set(r.computeShader,a),i.createProgram(a));const l=this._getComputeCacheKey(t,a);let h=this.caches.get(l);h===void 0&&(n&&n.usedTimes===0&&this._releasePipeline(n),h=this._getComputePipeline(t,a,l,e)),h.usedTimes++,a.usedTimes++,s.version=t.version,s.pipeline=h}return s.pipeline}getForRender(t,e=null){const{backend:i}=this,s=this.get(t);if(this._needsRenderUpdate(t)){const n=s.pipeline;n&&(n.usedTimes--,n.vertexProgram.usedTimes--,n.fragmentProgram.usedTimes--);const r=t.getNodeBuilderState();let a=this.programs.vertex.get(r.vertexShader);a===void 0&&(n&&n.vertexProgram.usedTimes===0&&this._releaseProgram(n.vertexProgram),a=new lc(r.vertexShader,"vertex"),this.programs.vertex.set(r.vertexShader,a),i.createProgram(a));let l=this.programs.fragment.get(r.fragmentShader);l===void 0&&(n&&n.fragmentProgram.usedTimes===0&&this._releaseProgram(n.fragmentProgram),l=new lc(r.fragmentShader,"fragment"),this.programs.fragment.set(r.fragmentShader,l),i.createProgram(l));const h=this._getRenderCacheKey(t,a,l);let u=this.caches.get(h);u===void 0?(n&&n.usedTimes===0&&this._releasePipeline(n),u=this._getRenderPipeline(t,a,l,h,e)):t.pipeline=u,u.usedTimes++,a.usedTimes++,l.usedTimes++,s.pipeline=u}return s.pipeline}delete(t){const e=this.get(t).pipeline;return e&&(e.usedTimes--,e.usedTimes===0&&this._releasePipeline(e),e.isComputePipeline?(e.computeProgram.usedTimes--,e.computeProgram.usedTimes===0&&this._releaseProgram(e.computeProgram)):(e.fragmentProgram.usedTimes--,e.vertexProgram.usedTimes--,e.vertexProgram.usedTimes===0&&this._releaseProgram(e.vertexProgram),e.fragmentProgram.usedTimes===0&&this._releaseProgram(e.fragmentProgram))),super.delete(t)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(t){this.getForRender(t)}_getComputePipeline(t,e,i,s){i=i||this._getComputeCacheKey(t,e);let n=this.caches.get(i);return n===void 0&&(n=new RA(i,e),this.caches.set(i,n),this.backend.createComputePipeline(n,s)),n}_getRenderPipeline(t,e,i,s,n){s=s||this._getRenderCacheKey(t,e,i);let r=this.caches.get(s);return r===void 0&&(r=new NA(s,e,i),this.caches.set(s,r),t.pipeline=r,this.backend.createRenderPipeline(t,n)),r}_getComputeCacheKey(t,e){return t.id+","+e.id}_getRenderCacheKey(t,e,i){return e.id+","+i.id+","+this.backend.getRenderCacheKey(t)}_releasePipeline(t){this.caches.delete(t.cacheKey)}_releaseProgram(t){const e=t.code,i=t.stage;this.programs[i].delete(e)}_needsComputeUpdate(t){const e=this.get(t);return e.pipeline===void 0||e.version!==t.version}_needsRenderUpdate(t){return this.get(t).pipeline===void 0||this.backend.needsRenderUpdate(t)}}class PA extends Nn{constructor(t,e,i,s,n,r){super(),this.backend=t,this.textures=i,this.pipelines=n,this.attributes=s,this.nodes=e,this.info=r,this.pipelines.bindings=this}getForRender(t){const e=t.getBindings();for(const i of e){const s=this.get(i);s.bindGroup===void 0&&(this._init(i),this.backend.createBindings(i,e),s.bindGroup=i)}return e}getForCompute(t){const e=this.nodes.getForCompute(t).bindings;for(const i of e){const s=this.get(i);s.bindGroup===void 0&&(this._init(i),this.backend.createBindings(i,e),s.bindGroup=i)}return e}updateForCompute(t){this._updateBindings(t,this.getForCompute(t))}updateForRender(t){this._updateBindings(t,this.getForRender(t))}_updateBindings(t,e){for(const i of e)this._update(t,i,e)}_init(t){for(const e of t.bindings)if(e.isSampledTexture)this.textures.updateTexture(e.texture);else if(e.isStorageBuffer){const i=e.attribute;this.attributes.update(i,xn.STORAGE)}}_update(t,e,i){const{backend:s}=this;let n=!1;for(const r of e.bindings)if(!(r.isNodeUniformsGroup&&!this.nodes.updateGroup(r))){if(r.isUniformBuffer)r.update()&&s.updateBinding(r);else if(r.isSampler)r.update();else if(r.isSampledTexture){const a=r.texture;r.needsBindingsUpdate&&(n=!0);const l=r.update();l&&this.textures.updateTexture(r.texture);const h=s.get(r.texture);if(s.isWebGPUBackend===!0&&h.texture===void 0&&h.externalTexture===void 0&&(console.error("Bindings._update: binding should be available:",r,l,r.texture,r.textureNode.value),this.textures.updateTexture(r.texture),n=!0),a.isStorageTexture===!0){const u=this.get(a);r.store===!0?u.needsMipmap=!0:a.generateMipmaps===!0&&this.textures.needsMipmaps(a)&&u.needsMipmap===!0&&(this.backend.generateMipmaps(a),u.needsMipmap=!1)}}}if(n===!0){const r=this.pipelines.getForRender(t);this.backend.updateBindings(e,i,r)}}}const kg={VERTEX:"vertex"},Y={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},FA=["fragment","vertex"],Gg=["setup","analyze","generate"],Wg=[...FA,"compute"],Ma=["x","y","z","w"];function p_(o,t=!1){let e="{";o.isNode===!0&&(e+=o.id);for(const{property:i,childNode:s}of Th(o))e+=","+i.slice(0,-4)+":"+s.getCacheKey(t);return e+="}",e}function*Th(o,t=!1){for(const e in o){if(e.startsWith("_")===!0)continue;const i=o[e];if(Array.isArray(i)===!0)for(let s=0;s<i.length;s++){const n=i[s];n&&(n.isNode===!0||t&&typeof n.toJSON=="function")&&(yield{property:e,index:s,childNode:n})}else if(i&&i.isNode===!0)yield{property:e,childNode:i};else if(typeof i=="object")for(const s in i){const n=i[s];n&&(n.isNode===!0||t&&typeof n.toJSON=="function")&&(yield{property:e,index:s,childNode:n})}}}function Os(o){if(o==null)return null;const t=typeof o;return o.isNode===!0?"node":t==="number"?"float":t==="boolean"?"bool":t==="string"?"string":t==="function"?"shader":o.isVector2===!0?"vec2":o.isVector3===!0?"vec3":o.isVector4===!0?"vec4":o.isMatrix3===!0?"mat3":o.isMatrix4===!0?"mat4":o.isColor===!0?"color":o instanceof ArrayBuffer?"ArrayBuffer":null}function f_(o,...t){const e=o?o.slice(-4):void 0;return t.length===1&&(e==="vec2"?t=[t[0],t[0]]:e==="vec3"?t=[t[0],t[0],t[0]]:e==="vec4"&&(t=[t[0],t[0],t[0],t[0]])),o==="color"?new nt(...t):e==="vec2"?new q(...t):e==="vec3"?new E(...t):e==="vec4"?new _t(...t):e==="mat3"?new hi(...t):e==="mat4"?new Bt(...t):o==="bool"?t[0]||!1:o==="float"||o==="int"||o==="uint"?t[0]||0:o==="string"?t[0]||"":o==="ArrayBuffer"?g_(t[0]):null}function m_(o){let t="";const e=new Uint8Array(o);for(let i=0;i<e.length;i++)t+=String.fromCharCode(e[i]);return btoa(t)}function g_(o){return Uint8Array.from(atob(o),t=>t.charCodeAt(0)).buffer}const Hg=new Map;let IA=0;class X extends Hs{constructor(t=null){super(),this.nodeType=t,this.updateType=Y.NONE,this.updateBeforeType=Y.NONE,this.updateAfterType=Y.NONE,this.uuid=z0.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.global=!1,this.isNode=!0,Object.defineProperty(this,"id",{value:IA++})}set needsUpdate(t){t===!0&&this.version++}get type(){return this.constructor.type}onUpdate(t,e){return this.updateType=e,this.update=t.bind(this.getSelf()),this}onFrameUpdate(t){return this.onUpdate(t,Y.FRAME)}onRenderUpdate(t){return this.onUpdate(t,Y.RENDER)}onObjectUpdate(t){return this.onUpdate(t,Y.OBJECT)}onReference(t){return this.updateReference=t.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:t}of Th(this))yield t}dispose(){this.dispatchEvent({type:"dispose"})}traverse(t){t(this);for(const e of this.getChildren())e.traverse(t)}getCacheKey(t=!1){return t=t||this.version!==this._cacheKeyVersion,(t===!0||this._cacheKey===null)&&(this._cacheKey=p_(this,t),this._cacheKeyVersion=this.version),this._cacheKey}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(t){const e=this.getNodeType(t);return t.getElementType(e)}getNodeType(t){const e=t.getNodeProperties(this);return e.outputNode?e.outputNode.getNodeType(t):this.nodeType}getShared(t){const e=this.getHash(t);return t.getNodeFromHash(e)||this}setup(t){const e=t.getNodeProperties(this);let i=0;for(const s of this.getChildren())e["node"+i++]=s;return null}increaseUsage(t){const e=t.getDataFromNode(this);return e.usageCount=e.usageCount===void 0?1:e.usageCount+1,e.usageCount}analyze(t){if(this.increaseUsage(t)===1){const i=t.getNodeProperties(this);for(const s of Object.values(i))s&&s.isNode===!0&&s.build(t)}}generate(t,e){const{outputNode:i}=t.getNodeProperties(this);if(i&&i.isNode===!0)return i.build(t,e)}updateBefore(){console.warn("Abstract function.")}updateAfter(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(t,e=null){const i=this.getShared(t);if(this!==i)return i.build(t,e);t.addNode(this),t.addChain(this);let s=null;const n=t.getBuildStage();if(n==="setup"){this.updateReference(t);const r=t.getNodeProperties(this);if(r.initialized!==!0){const a=t.stack.nodes.length;r.initialized=!0,r.outputNode=this.setup(t),r.outputNode!==null&&t.stack.nodes.length!==a&&(r.outputNode=t.stack);for(const l of Object.values(r))l&&l.isNode===!0&&l.build(t)}}else if(n==="analyze")this.analyze(t);else if(n==="generate")if(this.generate.length===1){const a=this.getNodeType(t),l=t.getDataFromNode(this);s=l.snippet,s===void 0&&(s=this.generate(t)||"",l.snippet=s),s=t.format(s,a,e)}else s=this.generate(t,e)||"";return t.removeChain(this),s}getSerializeChildren(){return Th(this)}serialize(t){const e=this.getSerializeChildren(),i={};for(const{property:s,index:n,childNode:r}of e)n!==void 0?(i[s]===void 0&&(i[s]=Number.isInteger(n)?[]:{}),i[s][n]=r.toJSON(t.meta).uuid):i[s]=r.toJSON(t.meta).uuid;Object.keys(i).length>0&&(t.inputNodes=i)}deserialize(t){if(t.inputNodes!==void 0){const e=t.meta.nodes;for(const i in t.inputNodes)if(Array.isArray(t.inputNodes[i])){const s=[];for(const n of t.inputNodes[i])s.push(e[n]);this[i]=s}else if(typeof t.inputNodes[i]=="object"){const s={};for(const n in t.inputNodes[i]){const r=t.inputNodes[i][n];s[n]=e[r]}this[i]=s}else{const s=t.inputNodes[i];this[i]=e[s]}}}toJSON(t){const{uuid:e,type:i}=this,s=t===void 0||typeof t=="string";s&&(t={textures:{},images:{},nodes:{}});let n=t.nodes[e];n===void 0&&(n={uuid:e,type:i,meta:t,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},s!==!0&&(t.nodes[n.uuid]=n),this.serialize(n),delete n.meta);function r(a){const l=[];for(const h in a){const u=a[h];delete u.metadata,l.push(u)}return l}if(s){const a=r(t.textures),l=r(t.images),h=r(t.nodes);a.length>0&&(n.textures=a),l.length>0&&(n.images=l),h.length>0&&(n.nodes=h)}return n}}function O(o,t){if(typeof t!="function"||!o)throw new Error(`Node class ${o} is not a class`);if(Hg.has(o)){console.warn(`Redefinition of node class ${o}`);return}Hg.set(o,t),t.type=o}class st extends X{constructor(t){super(t),this.isTempNode=!0}hasDependencies(t){return t.getDataFromNode(this).usageCount>1}build(t,e){if(t.getBuildStage()==="generate"){const s=t.getVectorType(this.getNodeType(t,e)),n=t.getDataFromNode(this);if(n.propertyName!==void 0)return t.format(n.propertyName,s,e);if(s!=="void"&&e!=="void"&&this.hasDependencies(t)){const r=super.build(t,s),a=t.getVarFromNode(this,null,s),l=t.getPropertyName(a);return t.addLineFlowCode(`${l} = ${r}`),n.snippet=r,n.propertyName=l,t.format(n.propertyName,s,e)}}return super.build(t,e)}}O("TempNode",st);class ao extends X{constructor(t,e){super(),this.node=t,this.indexNode=e,this.isArrayElementNode=!0}getNodeType(t){return this.node.getElementType(t)}generate(t){const e=this.node.build(t),i=this.indexNode.build(t,"uint");return`${e}[ ${i} ]`}}O("ArrayElementNode",ao);class jp extends X{constructor(t,e){super(),this.node=t,this.convertTo=e}getNodeType(t){const e=this.node.getNodeType(t);let i=null;for(const s of this.convertTo.split("|"))(i===null||t.getTypeLength(e)===t.getTypeLength(s))&&(i=s);return i}serialize(t){super.serialize(t),t.convertTo=this.convertTo}deserialize(t){super.deserialize(t),this.convertTo=t.convertTo}generate(t,e){const i=this.node,s=this.getNodeType(t),n=i.build(t,s);return t.format(n,s,e)}}O("ConvertNode",jp);class y_ extends st{constructor(t=[],e=null){super(e),this.nodes=t}getNodeType(t){return this.nodeType!==null?t.getVectorType(this.nodeType):t.getTypeFromLength(this.nodes.reduce((e,i)=>e+t.getTypeLength(i.getNodeType(t)),0))}generate(t,e){const i=this.getNodeType(t),s=this.nodes,n=t.getComponentType(i),r=[];for(const l of s){let h=l.build(t);const u=t.getComponentType(l.getNodeType(t));u!==n&&(h=t.format(h,u,n)),r.push(h)}const a=`${t.getType(i)}( ${r.join(", ")} )`;return t.format(a,i,e)}}O("JoinNode",y_);const BA=Ma.join("");class Od extends X{constructor(t,e="x"){super(),this.node=t,this.components=e,this.isSplitNode=!0}getVectorLength(){let t=this.components.length;for(const e of this.components)t=Math.max(Ma.indexOf(e)+1,t);return t}getComponentType(t){return t.getComponentType(this.node.getNodeType(t))}getNodeType(t){return t.getTypeFromLength(this.components.length,this.getComponentType(t))}generate(t,e){const i=this.node,s=t.getTypeLength(i.getNodeType(t));let n=null;if(s>1){let r=null;this.getVectorLength()>=s&&(r=t.getTypeFromLength(this.getVectorLength(),this.getComponentType(t)));const l=i.build(t,r);this.components.length===s&&this.components===BA.slice(0,this.components.length)?n=t.format(l,r,e):n=t.format(`${l}.${this.components}`,this.getNodeType(t),e)}else n=i.build(t,e);return n}serialize(t){super.serialize(t),t.components=this.components}deserialize(t){super.deserialize(t),this.components=t.components}}O("SplitNode",Od);class x_ extends st{constructor(t,e,i){super(),this.sourceNode=t,this.components=e,this.targetNode=i}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{sourceNode:e,components:i,targetNode:s}=this,n=this.getNodeType(t),r=t.getTypeFromLength(i.length),a=s.build(t,r),l=e.build(t,n),h=t.getTypeLength(n),u=[];for(let c=0;c<h;c++){const d=Ma[c];d===i[0]?(u.push(a),c+=i.length-1):u.push(l+"."+d)}return`${t.getType(n)}( ${u.join(", ")} )`}}O("SetNode",x_);class jh extends X{constructor(t,e=null){super(e),this.isInputNode=!0,this.value=t,this.precision=null}getNodeType(){return this.nodeType===null?Os(this.value):this.nodeType}getInputType(t){return this.getNodeType(t)}setPrecision(t){return this.precision=t,this}serialize(t){super.serialize(t),t.value=this.value,this.value&&this.value.toArray&&(t.value=this.value.toArray()),t.valueType=Os(this.value),t.nodeType=this.nodeType,t.valueType==="ArrayBuffer"&&(t.value=m_(t.value)),t.precision=this.precision}deserialize(t){super.deserialize(t),this.nodeType=t.nodeType,this.value=Array.isArray(t.value)?f_(t.valueType,...t.value):t.value,this.precision=t.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(t.value))}generate(){console.warn("Abstract function.")}}O("InputNode",jh);class Wi extends jh{constructor(t,e=null){super(t,e),this.isConstNode=!0}generateConst(t){return t.generateConst(this.getNodeType(t),this.value)}generate(t,e){const i=this.getNodeType(t);return t.format(this.generateConst(t),i,e)}}O("ConstNode",Wi);let jr=null;const Rr=new Map;function N(o,t){if(Rr.has(o)){console.warn(`Redefinition of node element ${o}`);return}if(typeof t!="function")throw new Error(`Node element ${o} is not a function`);Rr.set(o,t)}const $g=o=>o.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),__={setup(o,t){const e=t.shift();return o(Zh(e),...t)},get(o,t,e){if(typeof t=="string"&&o[t]===void 0){if(o.isStackNode!==!0&&t==="assign")return(...i)=>(jr.assign(e,...i),e);if(Rr.has(t)){const i=Rr.get(t);return o.isStackNode?(...s)=>e.add(i(...s)):(...s)=>i(e,...s)}else{if(t==="self")return o;if(t.endsWith("Assign")&&Rr.has(t.slice(0,t.length-6))){const i=Rr.get(t.slice(0,t.length-6));return o.isStackNode?(...s)=>e.assign(s[0],i(...s)):(...s)=>e.assign(i(e,...s))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(t)===!0)return t=$g(t),L(new Od(e,t));if(/^set[XYZWRGBASTPQ]{1,4}$/.test(t)===!0)return t=$g(t.slice(3).toLowerCase()),t=t.split("").sort().join(""),i=>L(new x_(o,t,i));if(t==="width"||t==="height"||t==="depth")return t==="width"?t="x":t==="height"?t="y":t==="depth"&&(t="z"),L(new Od(o,t));if(/^\d+$/.test(t)===!0)return L(new ao(e,new Wi(Number(t),"uint")))}}}return Reflect.get(o,t,e)},set(o,t,e,i){return typeof t=="string"&&o[t]===void 0&&(/^[xyzwrgbastpq]{1,4}$/.test(t)===!0||t==="width"||t==="height"||t==="depth"||/^\d+$/.test(t)===!0)?(i[t].assign(e),!0):Reflect.set(o,t,e,i)}},hc=new WeakMap,qg=new WeakMap,LA=function(o,t=null){const e=Os(o);if(e==="node"){let i=hc.get(o);return i===void 0&&(i=new Proxy(o,__),hc.set(o,i),hc.set(i,i)),i}else{if(t===null&&(e==="float"||e==="boolean")||e&&e!=="shader"&&e!=="string")return L(zd(o,t));if(e==="shader")return z(o)}return o},UA=function(o,t=null){for(const e in o)o[e]=L(o[e],t);return o},DA=function(o,t=null){const e=o.length;for(let i=0;i<e;i++)o[i]=L(o[i],t);return o},OA=function(o,t=null,e=null,i=null){const s=n=>L(i!==null?Object.assign(n,i):n);return t===null?(...n)=>s(new o(...Dr(n))):e!==null?(e=L(e),(...n)=>s(new o(t,...Dr(n),e))):(...n)=>s(new o(t,...Dr(n)))},zA=function(o,...t){return L(new o(...Dr(t)))};class VA extends X{constructor(t,e){super(),this.shaderNode=t,this.inputNodes=e}getNodeType(t){const e=t.getNodeProperties(this);return e.outputNode===null&&(e.outputNode=this.setupOutput(t)),e.outputNode.getNodeType(t)}call(t){const{shaderNode:e,inputNodes:i}=this;if(e.layout){let r=qg.get(t.constructor);r===void 0&&(r=new WeakMap,qg.set(t.constructor,r));let a=r.get(e);return a===void 0&&(a=L(t.buildFunctionNode(e)),r.set(e,a)),t.currentFunctionNode!==null&&t.currentFunctionNode.includes.push(a),L(a.call(i))}const s=e.jsFunc,n=i!==null?s(i,t.stack,t):s(t.stack,t);return L(n)}setup(t){const{outputNode:e}=t.getNodeProperties(this);return e||this.setupOutput(t)}setupOutput(t){return t.addStack(),t.stack.outputNode=this.call(t),t.removeStack()}generate(t,e){const{outputNode:i}=t.getNodeProperties(this);return i===null?this.call(t).build(t,e):super.generate(t,e)}}class kA extends X{constructor(t){super(),this.jsFunc=t,this.layout=null,this.global=!0}get isArrayInput(){return/^\((\s+)?\[/.test(this.jsFunc.toString())}setLayout(t){return this.layout=t,this}call(t=null){return Zh(t),L(new VA(this,t))}setup(){return this.call()}}const GA=[!1,!0],WA=[0,1,2,3],HA=[-1,-2],M_=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],Xp=new Map;for(const o of GA)Xp.set(o,new Wi(o));const Yp=new Map;for(const o of WA)Yp.set(o,new Wi(o,"uint"));const Zp=new Map([...Yp].map(o=>new Wi(o.value,"int")));for(const o of HA)Zp.set(o,new Wi(o,"int"));const Xh=new Map([...Zp].map(o=>new Wi(o.value)));for(const o of M_)Xh.set(o,new Wi(o));for(const o of M_)Xh.set(-o,new Wi(-o));const Yh={bool:Xp,uint:Yp,ints:Zp,float:Xh},jg=new Map([...Xp,...Xh]),zd=(o,t)=>jg.has(o)?jg.get(o):o.isNode===!0?o:new Wi(o,t),$A=o=>{try{return o.getNodeType()}catch{return}},bt=function(o,t=null){return(...e)=>{if((e.length===0||!["bool","float","int","uint"].includes(o)&&e.every(s=>typeof s!="object"))&&(e=[f_(o,...e)]),e.length===1&&t!==null&&t.has(e[0]))return L(t.get(e[0]));if(e.length===1){const s=zd(e[0],o);return $A(s)===o?L(s):L(new jp(s,o))}const i=e.map(s=>zd(s));return L(new y_(i,o))}},Xg=o=>o&&o.value,qA=o=>o!=null?o.nodeType||o.convertTo||(typeof o=="string"?o:null):null;function Yo(o){return new Proxy(new kA(o),__)}const L=(o,t=null)=>LA(o,t),Zh=(o,t=null)=>new UA(o,t),Dr=(o,t=null)=>new DA(o,t),I=(...o)=>new OA(...o),k=(...o)=>new zA(...o),z=o=>{const t=new Yo(o),e=(...i)=>{let s;return Zh(i),i[0]&&i[0].isNode?s=[...i]:s=i[0],t.call(s)};return e.shaderNode=t,e.setLayout=i=>(t.setLayout(i),e),e};O("ShaderNode",Yo);N("toGlobal",o=>(o.global=!0,o));const bh=o=>{jr=o},v_=()=>jr,it=(...o)=>jr.if(...o);function jA(o){return jr&&jr.add(o),o}N("append",jA);const XA=new bt("color"),C=new bt("float",Yh.float),xt=new bt("int",Yh.ints),YA=new bt("uint",Yh.uint),ZA=new bt("bool",Yh.bool),F=new bt("vec2"),Us=new bt("ivec2"),QA=new bt("uvec2"),JA=new bt("bvec2"),P=new bt("vec3"),KA=new bt("ivec3"),tN=new bt("uvec3"),eN=new bt("bvec3"),G=new bt("vec4"),iN=new bt("ivec4"),sN=new bt("uvec4"),nN=new bt("bvec4"),va=new bt("mat2"),rN=new bt("imat2"),oN=new bt("umat2"),aN=new bt("bmat2"),de=new bt("mat3"),lN=new bt("imat3"),hN=new bt("umat3"),uN=new bt("bmat3"),Or=new bt("mat4"),cN=new bt("imat4"),dN=new bt("umat4"),pN=new bt("bmat4");N("toColor",XA);N("toFloat",C);N("toInt",xt);N("toUint",YA);N("toBool",ZA);N("toVec2",F);N("toIvec2",Us);N("toUvec2",QA);N("toBvec2",JA);N("toVec3",P);N("toIvec3",KA);N("toUvec3",tN);N("toBvec3",eN);N("toVec4",G);N("toIvec4",iN);N("toUvec4",sN);N("toBvec4",nN);N("toMat2",va);N("toImat2",rN);N("toUmat2",oN);N("toBmat2",aN);N("toMat3",de);N("toImat3",lN);N("toUmat3",hN);N("toBmat3",uN);N("toMat4",Or);N("toImat4",cN);N("toUmat4",dN);N("toBmat4",pN);const fN=I(ao),mN=(o,t)=>L(new jp(L(o),t));N("element",fN);N("convert",mN);class T_ extends st{constructor(t,e){super(),this.targetNode=t,this.sourceNode=e}hasDependencies(){return!1}getNodeType(t,e){return e!=="void"?this.targetNode.getNodeType(t):"void"}needsSplitAssign(t){const{targetNode:e}=this;if(t.isAvailable("swizzleAssign")===!1&&e.isSplitNode&&e.components.length>1){const i=t.getTypeLength(e.node.getNodeType(t));return Ma.join("").slice(0,i)!==e.components}return!1}generate(t,e){const{targetNode:i,sourceNode:s}=this,n=this.needsSplitAssign(t),r=i.getNodeType(t),a=i.context({assign:!0}).build(t),l=s.build(t,r),h=s.getNodeType(t),u=t.getDataFromNode(this);let c;if(u.initialized===!0)e!=="void"&&(c=a);else if(n){const d=t.getVarFromNode(this,null,r),p=t.getPropertyName(d);t.addLineFlowCode(`${p} = ${l}`);const f=i.node.context({assign:!0}).build(t);for(let m=0;m<i.components.length;m++){const g=i.components[m];t.addLineFlowCode(`${f}.${g} = ${p}[ ${m} ]`)}e!=="void"&&(c=a)}else c=`${a} = ${l}`,(e==="void"||h==="void")&&(t.addLineFlowCode(c),e!=="void"&&(c=a));return u.initialized=!0,t.format(c,r,e)}}const gN=I(T_);O("AssignNode",T_);N("assign",gN);class b_ extends X{constructor(t,e=null){super(),this.node=t,this.name=e,this.isVaryingNode=!0}isGlobal(){return!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}setupVarying(t){const e=t.getNodeProperties(this);let i=e.varying;if(i===void 0){const s=this.name,n=this.getNodeType(t);e.varying=i=t.getVaryingFromNode(this,s,n),e.node=this.node}return i.needsInterpolation||(i.needsInterpolation=t.shaderStage==="fragment"),i}setup(t){this.setupVarying(t)}analyze(t){return this.setupVarying(t),this.node.analyze(t)}generate(t){const e=t.getNodeProperties(this),i=this.setupVarying(t);if(e.propertyName===void 0){const s=this.getNodeType(t),n=t.getPropertyName(i,kg.VERTEX);t.flowNodeFromShaderStage(kg.VERTEX,this.node,s,n),e.propertyName=n}return t.getPropertyName(i)}}const $t=I(b_);N("varying",$t);O("VaryingNode",b_);class Qp extends X{constructor(t,e=null,i=null){super(e),this.defaultNode=i,this.global=!0,this._attributeName=t}getHash(t){return this.getAttributeName(t)}getNodeType(t){let e=super.getNodeType(t);if(e===null){const i=this.getAttributeName(t);if(t.hasGeometryAttribute(i)){const s=t.geometry.getAttribute(i);e=t.getTypeFromAttribute(s)}else e="float"}return e}setAttributeName(t){return this._attributeName=t,this}getAttributeName(){return this._attributeName}generate(t){const e=this.getAttributeName(t),i=this.getNodeType(t);if(t.hasGeometryAttribute(e)===!0){const n=t.geometry.getAttribute(e),r=t.getTypeFromAttribute(n),a=t.getAttribute(e,r);return t.shaderStage==="vertex"?t.format(a.name,r,i):$t(this).build(t,i)}else{console.warn(`AttributeNode: Vertex attribute "${e}" not found on geometry.`);const{defaultNode:n}=this;return n!==null?n.build(t,i):t.generateConst(i)}}serialize(t){super.serialize(t),t.global=this.global,t._attributeName=this._attributeName}deserialize(t){super.deserialize(t),this.global=t.global,this._attributeName=t._attributeName}}const le=(o,t,e)=>L(new Qp(o,t,L(e)));O("AttributeNode",Qp);class S_ extends X{constructor(t,e){super(),this.isBypassNode=!0,this.outputNode=t,this.callNode=e}getNodeType(t){return this.outputNode.getNodeType(t)}generate(t){const e=this.callNode.build(t,"void");return e!==""&&t.addLineFlowCode(e),this.outputNode.build(t)}}const w_=I(S_);N("bypass",w_);O("BypassNode",S_);class A_ extends X{constructor(t,e=!0){super(),this.node=t,this.parent=e,this.isCacheNode=!0}getNodeType(t){return this.node.getNodeType(t)}build(t,...e){const i=t.getCache(),s=t.getCacheFromNode(this,parent);t.setCache(s);const n=this.node.build(t,...e);return t.setCache(i),n}}const Xl=(o,...t)=>L(new A_(L(o),...t));N("cache",Xl);O("CacheNode",A_);class Jp extends X{constructor(t,e={}){super(),this.isContextNode=!0,this.node=t,this.context=e}getNodeType(t){return this.node.getNodeType(t)}analyze(t){this.node.build(t)}setup(t){const e=t.getContext();t.setContext({...t.context,...this.context});const i=this.node.build(t);return t.setContext(e),i}generate(t,e){const i=t.getContext();t.setContext({...t.context,...this.context});const s=this.node.build(t,e);return t.setContext(i),s}}const zr=I(Jp),yN=(o,t)=>zr(o,{label:t});N("context",zr);N("label",yN);O("ContextNode",Jp);class Fe extends X{constructor(t){super("uint"),this.scope=t,this.isInstanceIndexNode=!0}generate(t){const e=this.getNodeType(t),i=this.scope;let s;if(i===Fe.VERTEX)s=t.getVertexIndex();else if(i===Fe.INSTANCE)s=t.getInstanceIndex();else if(i===Fe.DRAW)s=t.getDrawIndex();else throw new Error("THREE.IndexNode: Unknown scope: "+i);let n;return t.shaderStage==="vertex"||t.shaderStage==="compute"?n=s:n=$t(this).build(t,e),n}}Fe.VERTEX="vertex";Fe.INSTANCE="instance";Fe.DRAW="draw";const xN=k(Fe,Fe.VERTEX),Qh=k(Fe,Fe.INSTANCE),_N=k(Fe,Fe.DRAW);O("IndexNode",Fe);class Ta{start(){}finish(){}direct(){}directRectArea(){}indirect(){}ambientOcclusion(){}}class N_ extends X{constructor(t,e=null){super(),this.node=t,this.name=e,this.global=!0,this.isVarNode=!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}generate(t){const{node:e,name:i}=this,s=t.getVarFromNode(this,i,t.getVectorType(this.getNodeType(t))),n=t.getPropertyName(s),r=e.build(t,s.type);return t.addLineFlowCode(`${n} = ${r}`),n}}const Sh=I(N_);N("temp",Sh);N("toVar",(...o)=>Sh(...o).append());O("VarNode",N_);class Yg{constructor(t,e,i=null){this.isNodeAttribute=!0,this.name=t,this.type=e,this.node=i}}class MN{constructor(t,e,i){this.isNodeUniform=!0,this.name=t,this.type=e,this.node=i.getSelf()}get value(){return this.node.value}set value(t){this.node.value=t}get id(){return this.node.id}get groupNode(){return this.node.groupNode}}class R_{constructor(t,e){this.isNodeVar=!0,this.name=t,this.type=e}}class vN extends R_{constructor(t,e){super(t,e),this.needsInterpolation=!1,this.isNodeVarying=!0}}class TN{constructor(t,e,i=""){this.name=t,this.type=e,this.code=i,Object.defineProperty(this,"isNodeCode",{value:!0})}}class bN{constructor(){this.keywords=[],this.nodes={},this.keywordsCallback={}}getNode(t){let e=this.nodes[t];return e===void 0&&this.keywordsCallback[t]!==void 0&&(e=this.keywordsCallback[t](t),this.nodes[t]=e),e}addKeyword(t,e){return this.keywords.push(t),this.keywordsCallback[t]=e,this}parse(t){const e=this.keywords,i=new RegExp(`\\b${e.join("\\b|\\b")}\\b`,"g"),s=t.match(i),n=[];if(s!==null)for(const r of s){const a=this.getNode(r);a!==void 0&&n.indexOf(a)===-1&&n.push(a)}return n}include(t,e){const i=this.parse(e);for(const s of i)s.build(t)}}let SN=0;class uc{constructor(t=null){this.id=SN++,this.nodesData=new WeakMap,this.parent=t}getData(t){let e=this.nodesData.get(t);return e===void 0&&this.parent!==null&&(e=this.parent.getData(t)),e}setData(t,e){this.nodesData.set(t,e)}}class ot extends X{constructor(t,e=null,i=!1){super(t),this.name=e,this.varying=i,this.isPropertyNode=!0}getHash(t){return this.name||super.getHash(t)}isGlobal(){return!0}generate(t){let e;return this.varying===!0?(e=t.getVaryingFromNode(this,this.name),e.needsInterpolation=!0):e=t.getVarFromNode(this,this.name),t.getPropertyName(e)}}const Tt=(o,t)=>L(new ot(o,t)),Pi=(o,t)=>L(new ot(o,t,!0)),pt=k(ot,"vec4","DiffuseColor"),Zg=k(ot,"vec3","EmissiveColor"),ns=k(ot,"float","Roughness"),wh=k(ot,"float","Metalness"),Vd=k(ot,"float","Clearcoat"),Ah=k(ot,"float","ClearcoatRoughness"),Er=k(ot,"vec3","Sheen"),Kp=k(ot,"float","SheenRoughness"),tf=k(ot,"float","Iridescence"),E_=k(ot,"float","IridescenceIOR"),C_=k(ot,"float","IridescenceThickness"),kd=k(ot,"float","AlphaT"),cn=k(ot,"float","Anisotropy"),Yl=k(ot,"vec3","AnisotropyT"),Vr=k(ot,"vec3","AnisotropyB"),He=k(ot,"color","SpecularColor"),Nh=k(ot,"float","SpecularF90"),Gd=k(ot,"float","Shininess"),wN=k(ot,"vec4","Output"),kr=k(ot,"float","dashSize"),Rh=k(ot,"float","gapSize");k(ot,"float","pointWidth");const Zl=k(ot,"float","IOR"),Wd=k(ot,"float","Transmission"),P_=k(ot,"float","Thickness"),F_=k(ot,"float","AttenuationDistance"),I_=k(ot,"color","AttenuationColor"),B_=k(ot,"float","Dispersion");O("PropertyNode",ot);class Hd extends ot{constructor(t,e=null){super(t,e),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}O("ParameterNode",Hd);class _e extends X{constructor(t="",e=[],i=""){super("code"),this.isCodeNode=!0,this.code=t,this.language=i,this.includes=e}isGlobal(){return!0}setIncludes(t){return this.includes=t,this}getIncludes(){return this.includes}generate(t){const e=this.getIncludes(t);for(const s of e)s.build(t);const i=t.getCodeFromNode(this,this.getNodeType(t));return i.code=this.code,i.code}serialize(t){super.serialize(t),t.code=this.code,t.language=this.language}deserialize(t){super.deserialize(t),this.code=t.code,this.language=t.language}}I(_e);O("CodeNode",_e);class L_ extends _e{constructor(t="",e=[],i=""){super(t,e,i),this.keywords={}}getNodeType(t){return this.getNodeFunction(t).type}getInputs(t){return this.getNodeFunction(t).inputs}getNodeFunction(t){const e=t.getDataFromNode(this);let i=e.nodeFunction;return i===void 0&&(i=t.parser.parseFunction(this.code),e.nodeFunction=i),i}generate(t,e){super.generate(t);const i=this.getNodeFunction(t),s=i.name,n=i.type,r=t.getCodeFromNode(this,n);s!==""&&(r.name=s);const a=t.getPropertyName(r);let l=this.getNodeFunction(t).getCode(a);const h=this.keywords,u=Object.keys(h);if(u.length>0)for(const c of u){const d=new RegExp(`\\b${c}\\b`,"g"),p=h[c].build(t,"property");l=l.replace(d,p)}return r.code=l+`
`,e==="property"?a:t.format(`${a}()`,n,e)}}O("FunctionNode",L_);class ef extends X{constructor(t,e=!1){super("string"),this.name=t,this.version=0,this.shared=e,this.isUniformGroup=!0}set needsUpdate(t){t===!0&&this.version++}serialize(t){super.serialize(t),t.name=this.name,t.version=this.version,t.shared=this.shared}deserialize(t){super.deserialize(t),this.name=t.name,this.version=t.version,this.shared=t.shared}}const AN=o=>new ef(o),sf=o=>new ef(o,!0),NN=sf("frame"),RN=sf("render"),U_=AN("object");O("UniformGroupNode",ef);class Rn extends jh{constructor(t,e=null){super(t,e),this.isUniformNode=!0,this.name="",this.groupNode=U_}label(t){return this.name=t,this}setGroup(t){return this.groupNode=t,this}getGroup(){return this.groupNode}getUniformHash(t){return this.getHash(t)}onUpdate(t,e){const i=this.getSelf();return t=t.bind(i),super.onUpdate(s=>{const n=t(s,i);n!==void 0&&(this.value=n)},e)}generate(t,e){const i=this.getNodeType(t),s=this.getUniformHash(t);let n=t.getNodeFromHash(s);n===void 0&&(t.setHashNode(this,s),n=this);const r=n.getInputType(t),a=t.getUniformFromNode(n,r,t.shaderStage,this.name||t.context.label),l=t.getPropertyName(a);return t.context.label!==void 0&&delete t.context.label,t.format(l,i,e)}}const H=(o,t)=>{const e=qA(t||o),i=o&&o.isNode===!0?o.node&&o.node.value||o.value:o;return L(new Rn(i,e))};O("UniformNode",Rn);const Nt=o=>le("uv"+(o>0?o:""),"vec2");class D_ extends X{constructor(t,e=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=t,this.levelNode=e}generate(t,e){const i=this.textureNode.build(t,"property"),s=this.levelNode.build(t,"int");return t.format(`${t.getMethod("textureDimensions")}( ${i}, ${s} )`,this.getNodeType(t),e)}}const Xr=I(D_);N("textureSize",Xr);O("TextureSizeNode",D_);class Lt extends st{constructor(t,e,i,...s){if(super(),s.length>0){let n=new Lt(t,e,i);for(let r=0;r<s.length-1;r++)n=new Lt(t,n,s[r]);e=n,i=s[s.length-1]}this.op=t,this.aNode=e,this.bNode=i}getNodeType(t,e){const i=this.op,s=this.aNode,n=this.bNode,r=s.getNodeType(t),a=typeof n<"u"?n.getNodeType(t):null;if(r==="void"||a==="void")return"void";if(i==="%")return r;if(i==="~"||i==="&"||i==="|"||i==="^"||i===">>"||i==="<<")return t.getIntegerType(r);if(i==="!"||i==="=="||i==="&&"||i==="||"||i==="^^")return"bool";if(i==="<"||i===">"||i==="<="||i===">="){const l=e?t.getTypeLength(e):Math.max(t.getTypeLength(r),t.getTypeLength(a));return l>1?`bvec${l}`:"bool"}else return r==="float"&&t.isMatrix(a)?a:t.isMatrix(r)&&t.isVector(a)?t.getVectorFromMatrix(r):t.isVector(r)&&t.isMatrix(a)?t.getVectorFromMatrix(a):t.getTypeLength(a)>t.getTypeLength(r)?a:r}generate(t,e){const i=this.op,s=this.aNode,n=this.bNode,r=this.getNodeType(t,e);let a=null,l=null;r!=="void"?(a=s.getNodeType(t),l=typeof n<"u"?n.getNodeType(t):null,i==="<"||i===">"||i==="<="||i===">="||i==="=="?t.isVector(a)?l=a:a=l="float":i===">>"||i==="<<"?(a=r,l=t.changeComponentType(l,"uint")):t.isMatrix(a)&&t.isVector(l)?l=t.getVectorFromMatrix(a):t.isVector(a)&&t.isMatrix(l)?a=t.getVectorFromMatrix(l):a=l=r):a=l=r;const h=s.build(t,a),u=typeof n<"u"?n.build(t,l):null,c=t.getTypeLength(e),d=t.getFunctionOperator(i);if(e!=="void")return i==="<"&&c>1?t.format(`${t.getMethod("lessThan")}( ${h}, ${u} )`,r,e):i==="<="&&c>1?t.format(`${t.getMethod("lessThanEqual")}( ${h}, ${u} )`,r,e):i===">"&&c>1?t.format(`${t.getMethod("greaterThan")}( ${h}, ${u} )`,r,e):i===">="&&c>1?t.format(`${t.getMethod("greaterThanEqual")}( ${h}, ${u} )`,r,e):i==="!"||i==="~"?t.format(`(${i}${h})`,a,e):d?t.format(`${d}( ${h}, ${u} )`,r,e):t.format(`( ${h} ${i} ${u} )`,r,e);if(a!=="void")return d?t.format(`${d}( ${h}, ${u} )`,r,e):t.format(`${h} ${i} ${u}`,r,e)}serialize(t){super.serialize(t),t.op=this.op}deserialize(t){super.deserialize(t),this.op=t.op}}const Yt=I(Lt,"+"),Ie=I(Lt,"-"),ut=I(Lt,"*"),Oi=I(Lt,"/"),EN=I(Lt,"%"),CN=I(Lt,"=="),PN=I(Lt,"!="),FN=I(Lt,"<"),IN=I(Lt,">"),BN=I(Lt,"<="),LN=I(Lt,">="),UN=I(Lt,"&&"),DN=I(Lt,"||"),ON=I(Lt,"!"),zN=I(Lt,"^^"),VN=I(Lt,"&"),kN=I(Lt,"~"),GN=I(Lt,"|"),WN=I(Lt,"^"),HN=I(Lt,"<<"),$N=I(Lt,">>");N("add",Yt);N("sub",Ie);N("mul",ut);N("div",Oi);N("remainder",EN);N("equal",CN);N("notEqual",PN);N("lessThan",FN);N("greaterThan",IN);N("lessThanEqual",BN);N("greaterThanEqual",LN);N("and",UN);N("or",DN);N("not",ON);N("xor",zN);N("bitAnd",VN);N("bitNot",kN);N("bitOr",GN);N("bitXor",WN);N("shiftLeft",HN);N("shiftRight",$N);O("OperatorNode",Lt);class R extends st{constructor(t,e,i=null,s=null){super(),this.method=t,this.aNode=e,this.bNode=i,this.cNode=s}getInputType(t){const e=this.aNode.getNodeType(t),i=this.bNode?this.bNode.getNodeType(t):null,s=this.cNode?this.cNode.getNodeType(t):null,n=t.isMatrix(e)?0:t.getTypeLength(e),r=t.isMatrix(i)?0:t.getTypeLength(i),a=t.isMatrix(s)?0:t.getTypeLength(s);return n>r&&n>a?e:r>a?i:a>n?s:e}getNodeType(t){const e=this.method;return e===R.LENGTH||e===R.DISTANCE||e===R.DOT?"float":e===R.CROSS?"vec3":e===R.ALL?"bool":e===R.EQUALS?t.changeComponentType(this.aNode.getNodeType(t),"bool"):e===R.MOD?this.aNode.getNodeType(t):this.getInputType(t)}generate(t,e){const i=this.method,s=this.getNodeType(t),n=this.getInputType(t),r=this.aNode,a=this.bNode,l=this.cNode,h=t.renderer.isWebGLRenderer===!0;if(i===R.TRANSFORM_DIRECTION){let u=r,c=a;t.isMatrix(u.getNodeType(t))?c=G(P(c),0):u=G(P(u),0);const d=ut(u,c).xyz;return Mi(d).build(t,e)}else{if(i===R.NEGATE)return t.format("( - "+r.build(t,n)+" )",s,e);if(i===R.ONE_MINUS)return Ie(1,r).build(t,e);if(i===R.RECIPROCAL)return Oi(1,r).build(t,e);if(i===R.DIFFERENCE)return ue(Ie(r,a)).build(t,e);{const u=[];return i===R.CROSS||i===R.MOD?u.push(r.build(t,s),a.build(t,s)):i===R.STEP?u.push(r.build(t,t.getTypeLength(r.getNodeType(t))===1?"float":n),a.build(t,n)):h&&(i===R.MIN||i===R.MAX)||i===R.MOD?u.push(r.build(t,n),a.build(t,t.getTypeLength(a.getNodeType(t))===1?"float":n)):i===R.REFRACT?u.push(r.build(t,n),a.build(t,n),l.build(t,"float")):i===R.MIX?u.push(r.build(t,n),a.build(t,n),l.build(t,t.getTypeLength(l.getNodeType(t))===1?"float":n)):(u.push(r.build(t,n)),a!==null&&u.push(a.build(t,n)),l!==null&&u.push(l.build(t,n))),t.format(`${t.getMethod(i,s)}( ${u.join(", ")} )`,s,e)}}}serialize(t){super.serialize(t),t.method=this.method}deserialize(t){super.deserialize(t),this.method=t.method}}R.ALL="all";R.ANY="any";R.EQUALS="equals";R.RADIANS="radians";R.DEGREES="degrees";R.EXP="exp";R.EXP2="exp2";R.LOG="log";R.LOG2="log2";R.SQRT="sqrt";R.INVERSE_SQRT="inversesqrt";R.FLOOR="floor";R.CEIL="ceil";R.NORMALIZE="normalize";R.FRACT="fract";R.SIN="sin";R.COS="cos";R.TAN="tan";R.ASIN="asin";R.ACOS="acos";R.ATAN="atan";R.ABS="abs";R.SIGN="sign";R.LENGTH="length";R.NEGATE="negate";R.ONE_MINUS="oneMinus";R.DFDX="dFdx";R.DFDY="dFdy";R.ROUND="round";R.RECIPROCAL="reciprocal";R.TRUNC="trunc";R.FWIDTH="fwidth";R.BITCAST="bitcast";R.TRANSPOSE="transpose";R.ATAN2="atan2";R.MIN="min";R.MAX="max";R.MOD="mod";R.STEP="step";R.REFLECT="reflect";R.DISTANCE="distance";R.DIFFERENCE="difference";R.DOT="dot";R.CROSS="cross";R.POW="pow";R.TRANSFORM_DIRECTION="transformDirection";R.MIX="mix";R.CLAMP="clamp";R.REFRACT="refract";R.SMOOTHSTEP="smoothstep";R.FACEFORWARD="faceforward";const O_=C(1e-6);C(1e6);const Yr=C(Math.PI);C(Math.PI*2);const z_=I(R,R.ALL),qN=I(R,R.ANY),jN=I(R,R.EQUALS),XN=I(R,R.RADIANS),YN=I(R,R.DEGREES),V_=I(R,R.EXP),$d=I(R,R.EXP2),k_=I(R,R.LOG),Jh=I(R,R.LOG2),G_=I(R,R.SQRT),ZN=I(R,R.INVERSE_SQRT),ba=I(R,R.FLOOR),W_=I(R,R.CEIL),Mi=I(R,R.NORMALIZE),En=I(R,R.FRACT),he=I(R,R.SIN),$e=I(R,R.COS),QN=I(R,R.TAN),JN=I(R,R.ASIN),qd=I(R,R.ACOS),KN=I(R,R.ATAN),ue=I(R,R.ABS),Kh=I(R,R.SIGN),_n=I(R,R.LENGTH),tR=I(R,R.NEGATE),eR=I(R,R.ONE_MINUS),iR=I(R,R.DFDX),sR=I(R,R.DFDY),nR=I(R,R.ROUND),rR=I(R,R.RECIPROCAL),oR=I(R,R.TRUNC),aR=I(R,R.FWIDTH);I(R,R.BITCAST);const lR=I(R,R.TRANSPOSE),hR=I(R,R.ATAN2),Ui=I(R,R.MIN),Et=I(R,R.MAX),H_=I(R,R.MOD),$_=I(R,R.STEP),uR=I(R,R.REFLECT),cR=I(R,R.DISTANCE),dR=I(R,R.DIFFERENCE),oe=I(R,R.DOT),Zo=I(R,R.CROSS),Xe=I(R,R.POW),q_=I(R,R.POW,2),pR=I(R,R.POW,3),fR=I(R,R.POW,4),mR=I(R,R.TRANSFORM_DIRECTION),gR=o=>ut(Kh(o),Xe(ue(o),1/3)),yR=o=>oe(o,o),K=I(R,R.MIX),Me=(o,t=0,e=1)=>L(new R(R.CLAMP,L(o),L(t),L(e))),xR=o=>Me(o),j_=I(R,R.REFRACT),Je=I(R,R.SMOOTHSTEP),_R=I(R,R.FACEFORWARD),X_=z(([o])=>{const i=43758.5453,s=oe(o.xy,F(12.9898,78.233)),n=H_(s,Yr);return En(he(n).mul(i))}),MR=(o,t,e)=>K(t,e,o),vR=(o,t,e)=>Je(t,e,o);N("all",z_);N("any",qN);N("equals",jN);N("radians",XN);N("degrees",YN);N("exp",V_);N("exp2",$d);N("log",k_);N("log2",Jh);N("sqrt",G_);N("inverseSqrt",ZN);N("floor",ba);N("ceil",W_);N("normalize",Mi);N("fract",En);N("sin",he);N("cos",$e);N("tan",QN);N("asin",JN);N("acos",qd);N("atan",KN);N("abs",ue);N("sign",Kh);N("length",_n);N("lengthSq",yR);N("negate",tR);N("oneMinus",eR);N("dFdx",iR);N("dFdy",sR);N("round",nR);N("reciprocal",rR);N("trunc",oR);N("fwidth",aR);N("atan2",hR);N("min",Ui);N("max",Et);N("mod",H_);N("step",$_);N("reflect",uR);N("distance",cR);N("dot",oe);N("cross",Zo);N("pow",Xe);N("pow2",q_);N("pow3",pR);N("pow4",fR);N("transformDirection",mR);N("mix",MR);N("clamp",Me);N("refract",j_);N("smoothstep",vR);N("faceForward",_R);N("difference",dR);N("saturate",xR);N("cbrt",gR);N("transpose",lR);N("rand",X_);O("MathNode",R);const TR=z(o=>{const{value:t}=o,{rgb:e}=t,i=e.mul(.9478672986).add(.0521327014).pow(2.4),s=e.mul(.0773993808),n=e.lessThanEqual(.04045),r=K(i,s,n);return G(r,t.a)}),bR=z(o=>{const{value:t}=o,{rgb:e}=t,i=e.pow(.41666).mul(1.055).sub(.055),s=e.mul(12.92),n=e.lessThanEqual(.0031308),r=K(i,s,n);return G(r,t.a)}),Qg=o=>{let t=null;return o===Qe?t="Linear":o===j&&(t="sRGB"),t},Y_=(o,t)=>Qg(o)+"To"+Qg(t);class De extends st{constructor(t,e){super("vec4"),this.method=t,this.node=e}setup(){const{method:t,node:e}=this;return t===De.LINEAR_TO_LINEAR?e:SR[t]({value:e})}}De.LINEAR_TO_LINEAR="LinearToLinear";De.LINEAR_TO_sRGB="LinearTosRGB";De.sRGB_TO_LINEAR="sRGBToLinear";const SR={[De.LINEAR_TO_sRGB]:bR,[De.sRGB_TO_LINEAR]:TR},wR=(o,t)=>L(new De(Y_(Qe,t),L(o))),Z_=(o,t)=>L(new De(Y_(t,Qe),L(o))),AR=I(De,De.LINEAR_TO_sRGB),NR=I(De,De.sRGB_TO_LINEAR);N("linearTosRGB",AR);N("sRGBToLinear",NR);N("linearToColorSpace",wR);N("colorSpaceToLinear",Z_);O("ColorSpaceNode",De);class Q_ extends X{constructor(t="",e="void"){super(e),this.snippet=t}generate(t,e){const i=this.getNodeType(t),s=this.snippet;if(i==="void")t.addLineFlowCode(s);else return t.format(`( ${s} )`,i,e)}}const tu=I(Q_);O("ExpressionNode",Q_);class J_ extends Rn{constructor(t){super(0),this._textureNode=t,this.updateType=Y.FRAME}get textureNode(){return this._textureNode}get texture(){return this._textureNode.value}update(){const t=this.texture,e=t.images,i=e&&e.length>0?e[0]&&e[0].image||e[0]:t.image;if(i&&i.width!==void 0){const{width:s,height:n}=i;this.value=Math.log2(Math.max(s,n))}}}const RR=I(J_);O("MaxMipLevelNode",J_);class zi extends Rn{constructor(t,e=null,i=null,s=null){super(t),this.isTextureNode=!0,this.uvNode=e,this.levelNode=i,this.biasNode=s,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=Y.NONE,this.referenceNode=null,this._value=t,this._matrixUniform=null,this.setUpdateMatrix(e===null)}set value(t){this.referenceNode?this.referenceNode.value=t:this._value=t}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":this.value.type===re?"uvec4":this.value.type===Ne?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return Nt(this.value.channel)}updateReference(){return this.value}getTransformedUV(t){return this._matrixUniform===null&&(this._matrixUniform=H(this.value.matrix)),this._matrixUniform.mul(P(t,1)).xy}setUpdateMatrix(t){return this.updateMatrix=t,this.updateType=t?Y.FRAME:Y.NONE,this}setupUV(t,e){const i=this.value;return t.isFlipY()&&(i.isRenderTargetTexture===!0||i.isFramebufferTexture===!0||i.isDepthTexture===!0)&&(e=e.setY(e.y.oneMinus())),e}setup(t){const e=t.getNodeProperties(this);e.referenceNode=this.referenceNode;let i=this.uvNode;(i===null||t.context.forceUVContext===!0)&&t.context.getUV&&(i=t.context.getUV(this)),i||(i=this.getDefaultUV()),this.updateMatrix===!0&&(i=this.getTransformedUV(i)),i=this.setupUV(t,i);let s=this.levelNode;s===null&&t.context.getTextureLevel&&(s=t.context.getTextureLevel(this)),e.uvNode=i,e.levelNode=s,e.biasNode=this.biasNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e.depthNode=this.depthNode}generateUV(t,e){return e.build(t,this.sampler===!0?"vec2":"ivec2")}generateSnippet(t,e,i,s,n,r,a,l){const h=this.value;let u;return s?u=t.generateTextureLevel(h,e,i,s,r):n?u=t.generateTextureBias(h,e,i,n,r):l?u=t.generateTextureGrad(h,e,i,l,r):a?u=t.generateTextureCompare(h,e,i,a,r):this.sampler===!1?u=t.generateTextureLoad(h,e,i,r):u=t.generateTexture(h,e,i,r),u}generate(t,e){const i=t.getNodeProperties(this),s=this.value;if(!s||s.isTexture!==!0)throw new Error("TextureNode: Need a three.js texture.");const n=super.generate(t,"property");if(e==="sampler")return n+"_sampler";if(t.isReference(e))return n;{const r=t.getDataFromNode(this);let a=r.propertyName;if(a===void 0){const{uvNode:u,levelNode:c,biasNode:d,compareNode:p,depthNode:f,gradNode:m}=i,g=this.generateUV(t,u),y=c?c.build(t,"float"):null,x=d?d.build(t,"float"):null,M=f?f.build(t,"int"):null,_=p?p.build(t,"float"):null,v=m?[m[0].build(t,"vec2"),m[1].build(t,"vec2")]:null,A=t.getVarFromNode(this);a=t.getPropertyName(A);const T=this.generateSnippet(t,n,g,y,x,M,_,v);t.addLineFlowCode(`${a} = ${T}`),r.snippet=T,r.propertyName=a}let l=a;const h=this.getNodeType(t);return t.needsColorSpaceToLinear(s)&&(l=Z_(tu(l,h),s.colorSpace).setup(t).build(t,h)),t.format(l,h,e)}}setSampler(t){return this.sampler=t,this}getSampler(){return this.sampler}uv(t){const e=this.clone();return e.uvNode=L(t),e.referenceNode=this,L(e)}blur(t){const e=this.clone();return e.biasNode=L(t).mul(RR(e)),e.referenceNode=this,L(e)}level(t){const e=this.clone();return e.levelNode=L(t),e.referenceNode=this,L(e)}size(t){return Xr(this,t)}bias(t){const e=this.clone();return e.biasNode=L(t),e.referenceNode=this,L(e)}compare(t){const e=this.clone();return e.compareNode=L(t),e.referenceNode=this,L(e)}grad(t,e){const i=this.clone();return i.gradNode=[L(t),L(e)],i.referenceNode=this,L(i)}depth(t){const e=this.clone();return e.depthNode=L(t),e.referenceNode=this,L(e)}serialize(t){super.serialize(t),t.value=this.value.toJSON(t.meta).uuid,t.sampler=this.sampler,t.updateMatrix=this.updateMatrix,t.updateType=this.updateType}deserialize(t){super.deserialize(t),this.value=t.meta.textures[t.value],this.sampler=t.sampler,this.updateMatrix=t.updateMatrix,this.updateType=t.updateType}update(){const t=this.value,e=this._matrixUniform;e!==null&&(e.value=t.matrix),t.matrixAutoUpdate===!0&&t.updateMatrix()}clone(){const t=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return t.sampler=this.sampler,t}}const gt=I(zi),es=(...o)=>gt(...o).setSampler(!1);N("texture",gt);O("TextureNode",zi);class eu extends Rn{constructor(t,e,i=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferCount=i}getElementType(t){return this.getNodeType(t)}getInputType(){return"buffer"}}const iu=(o,t,e)=>L(new eu(o,t,e));O("BufferNode",eu);class ER extends ao{constructor(t,e){super(t,e),this.isArrayBufferElementNode=!0}getNodeType(t){return this.node.getElementType(t)}generate(t){const e=super.generate(t),i=this.getNodeType();return t.format(e,"vec4",i)}}class K_ extends eu{constructor(t,e=null){super(null,"vec4"),this.array=t,this.elementType=e,this._elementType=null,this._elementLength=0,this.updateType=Y.RENDER,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:t,value:e}=this,i=this.getElementLength(),s=this.getElementType();if(i===1)for(let n=0;n<t.length;n++){const r=n*4;e[r]=t[n]}else if(s==="color")for(let n=0;n<t.length;n++){const r=n*4,a=t[n];e[r]=a.r,e[r+1]=a.g,e[r+2]=a.b||0}else for(let n=0;n<t.length;n++){const r=n*4,a=t[n];e[r]=a.x,e[r+1]=a.y,e[r+2]=a.z||0,e[r+3]=a.w||0}}setup(t){const e=this.array.length;this._elementType=this.elementType===null?Os(this.array[0]):this.elementType,this._elementLength=t.getTypeLength(this._elementType);let i=Float32Array;return this._elementType.charAt(0)==="i"?i=Int32Array:this._elementType.charAt(0)==="u"&&(i=Uint32Array),this.value=new i(e*4),this.bufferCount=e,this.bufferType=t.changeComponentType("vec4",t.getComponentType(this._elementType)),super.setup(t)}element(t){return L(new ER(this,L(t)))}}const zs=(o,t)=>L(new K_(o,t));O("UniformsNode",K_);class CR extends ao{constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),i=this.referenceNode.getNodeType(),s=this.getNodeType();return t.format(e,i,s)}}class lo extends X{constructor(t,e,i=null,s=null){super(),this.property=t,this.uniformType=e,this.object=i,this.count=s,this.properties=t.split("."),this.reference=i,this.node=null,this.updateType=Y.OBJECT}element(t){return L(new CR(this,L(t)))}setNodeType(t){let e=null;this.count!==null?e=iu(null,t,this.count):Array.isArray(this.getValueFromReference())?e=zs(null,t):t==="texture"?e=gt(null):e=H(null,t),this.node=e}getNodeType(t){return this.node===null&&this.updateValue(),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let i=t[e[0]];for(let s=1;s<e.length;s++)i=i[e[s]];return i}updateReference(t){return this.reference=this.object!==null?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}const Wt=(o,t,e)=>L(new lo(o,t,e)),PR=(o,t,e,i)=>L(new lo(o,t,i,e));O("ReferenceNode",lo);class tM extends lo{constructor(t,e,i=null){super(t,e,i),this.material=i}updateReference(t){return this.reference=this.material!==null?this.material:t.material,this.reference}}const ct=(o,t,e)=>L(new tM(o,t,e));O("MaterialReferenceNode",tM);const Cn=sf("camera").onRenderUpdate(()=>{Cn.needsUpdate=!0}),No=H("float").label("cameraNear").setGroup(Cn).onRenderUpdate(({camera:o})=>o.near),Ro=H("float").label("cameraFar").setGroup(Cn).onRenderUpdate(({camera:o})=>o.far),FR=H("float").label("cameraLogDepth").setGroup(Cn).onRenderUpdate(({camera:o})=>2/(Math.log(o.far+1)/Math.LN2)),vi=H("mat4").label("cameraProjectionMatrix").setGroup(Cn).onRenderUpdate(({camera:o})=>o.projectionMatrix),Pn=H("mat4").label("cameraViewMatrix").setGroup(Cn).onRenderUpdate(({camera:o})=>o.matrixWorldInverse),eM=H(new E).label("cameraPosition").setGroup(Cn).onRenderUpdate(({camera:o},t)=>t.value.setFromMatrixPosition(o.matrixWorld));class Z extends X{constructor(t=Z.VIEW_MATRIX,e=null){super(),this.scope=t,this.object3d=e,this.updateType=Y.OBJECT,this._uniformNode=new Rn(null)}getNodeType(){const t=this.scope;if(t===Z.WORLD_MATRIX||t===Z.VIEW_MATRIX)return"mat4";if(t===Z.NORMAL_MATRIX)return"mat3";if(t===Z.POSITION||t===Z.VIEW_POSITION||t===Z.DIRECTION||t===Z.SCALE)return"vec3"}update(t){const e=this.object3d,i=this._uniformNode,s=this.scope;if(s===Z.VIEW_MATRIX)i.value=e.modelViewMatrix;else if(s===Z.NORMAL_MATRIX)i.value=e.normalMatrix;else if(s===Z.WORLD_MATRIX)i.value=e.matrixWorld;else if(s===Z.POSITION)i.value=i.value||new E,i.value.setFromMatrixPosition(e.matrixWorld);else if(s===Z.SCALE)i.value=i.value||new E,i.value.setFromMatrixScale(e.matrixWorld);else if(s===Z.DIRECTION)i.value=i.value||new E,e.getWorldDirection(i.value);else if(s===Z.VIEW_POSITION){const n=t.camera;i.value=i.value||new E,i.value.setFromMatrixPosition(e.matrixWorld),i.value.applyMatrix4(n.matrixWorldInverse)}}generate(t){const e=this.scope;return e===Z.WORLD_MATRIX||e===Z.VIEW_MATRIX?this._uniformNode.nodeType="mat4":e===Z.NORMAL_MATRIX?this._uniformNode.nodeType="mat3":(e===Z.POSITION||e===Z.VIEW_POSITION||e===Z.DIRECTION||e===Z.SCALE)&&(this._uniformNode.nodeType="vec3"),this._uniformNode.build(t)}serialize(t){super.serialize(t),t.scope=this.scope}deserialize(t){super.deserialize(t),this.scope=t.scope}}Z.VIEW_MATRIX="viewMatrix";Z.NORMAL_MATRIX="normalMatrix";Z.WORLD_MATRIX="worldMatrix";Z.POSITION="position";Z.SCALE="scale";Z.VIEW_POSITION="viewPosition";Z.DIRECTION="direction";I(Z,Z.DIRECTION);I(Z,Z.VIEW_MATRIX);I(Z,Z.NORMAL_MATRIX);I(Z,Z.WORLD_MATRIX);const jd=I(Z,Z.POSITION);I(Z,Z.SCALE);const nf=I(Z,Z.VIEW_POSITION);O("Object3DNode",Z);class pe extends Z{constructor(t=pe.VIEW_MATRIX){super(t)}update(t){this.object3d=t.object,super.update(t)}}k(pe,pe.DIRECTION);const ks=k(pe,pe.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix"),rf=k(pe,pe.NORMAL_MATRIX),aa=k(pe,pe.WORLD_MATRIX);k(pe,pe.POSITION);k(pe,pe.SCALE);const IR=k(pe,pe.VIEW_POSITION),BR=H(new Bt).onObjectUpdate(({object:o},t)=>t.value.copy(o.matrixWorld).invert());O("ModelNode",pe);const Eh=le("normal","vec3",P(0,1,0)),li=Eh.toVar("normalLocal"),us=$t(rf.mul(li),"v_normalView").normalize().toVar("normalView"),of=$t(us.transformDirection(Pn),"v_normalWorld").normalize().toVar("normalWorld"),Ct=Tt("vec3","transformedNormalView"),iM=Ct.transformDirection(Pn).normalize().toVar("transformedNormalWorld"),Cr=Tt("vec3","transformedClearcoatNormalView"),Jg=new Map;class B extends X{constructor(t){super(),this.scope=t}getCache(t,e){let i=Jg.get(t);return i===void 0&&(i=ct(t,e),Jg.set(t,i)),i}getFloat(t){return this.getCache(t,"float")}getColor(t){return this.getCache(t,"color")}getTexture(t){return this.getCache(t==="map"?"map":t+"Map","texture")}setup(t){const e=t.context.material,i=this.scope;let s=null;if(i===B.COLOR){const n=this.getColor(i);e.map&&e.map.isTexture===!0?s=n.mul(this.getTexture("map")):s=n}else if(i===B.OPACITY){const n=this.getFloat(i);e.alphaMap&&e.alphaMap.isTexture===!0?s=n.mul(this.getTexture("alpha")):s=n}else if(i===B.SPECULAR_STRENGTH)e.specularMap&&e.specularMap.isTexture===!0?s=this.getTexture("specular").r:s=C(1);else if(i===B.SPECULAR_INTENSITY){const n=this.getFloat(i);e.specularMap?s=n.mul(this.getTexture(i).a):s=n}else if(i===B.SPECULAR_COLOR){const n=this.getColor(i);e.specularColorMap&&e.specularColorMap.isTexture===!0?s=n.mul(this.getTexture(i).rgb):s=n}else if(i===B.ROUGHNESS){const n=this.getFloat(i);e.roughnessMap&&e.roughnessMap.isTexture===!0?s=n.mul(this.getTexture(i).g):s=n}else if(i===B.METALNESS){const n=this.getFloat(i);e.metalnessMap&&e.metalnessMap.isTexture===!0?s=n.mul(this.getTexture(i).b):s=n}else if(i===B.EMISSIVE){const n=this.getFloat("emissiveIntensity"),r=this.getColor(i).mul(n);e.emissiveMap&&e.emissiveMap.isTexture===!0?s=r.mul(this.getTexture(i)):s=r}else if(i===B.NORMAL)e.normalMap?s=this.getTexture("normal").normalMap(this.getCache("normalScale","vec2")):e.bumpMap?s=this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")):s=us;else if(i===B.CLEARCOAT){const n=this.getFloat(i);e.clearcoatMap&&e.clearcoatMap.isTexture===!0?s=n.mul(this.getTexture(i).r):s=n}else if(i===B.CLEARCOAT_ROUGHNESS){const n=this.getFloat(i);e.clearcoatRoughnessMap&&e.clearcoatRoughnessMap.isTexture===!0?s=n.mul(this.getTexture(i).r):s=n}else if(i===B.CLEARCOAT_NORMAL)e.clearcoatNormalMap?s=this.getTexture(i).normalMap(this.getCache(i+"Scale","vec2")):s=us;else if(i===B.SHEEN){const n=this.getColor("sheenColor").mul(this.getFloat("sheen"));e.sheenColorMap&&e.sheenColorMap.isTexture===!0?s=n.mul(this.getTexture("sheenColor").rgb):s=n}else if(i===B.SHEEN_ROUGHNESS){const n=this.getFloat(i);e.sheenRoughnessMap&&e.sheenRoughnessMap.isTexture===!0?s=n.mul(this.getTexture(i).a):s=n,s=s.clamp(.07,1)}else if(i===B.ANISOTROPY)if(e.anisotropyMap&&e.anisotropyMap.isTexture===!0){const n=this.getTexture(i);s=va(Eo.x,Eo.y,Eo.y.negate(),Eo.x).mul(n.rg.mul(2).sub(F(1)).normalize().mul(n.b))}else s=Eo;else if(i===B.IRIDESCENCE_THICKNESS){const n=Wt("1","float",e.iridescenceThicknessRange);if(e.iridescenceThicknessMap){const r=Wt("0","float",e.iridescenceThicknessRange);s=n.sub(r).mul(this.getTexture(i).g).add(r)}else s=n}else if(i===B.TRANSMISSION){const n=this.getFloat(i);e.transmissionMap?s=n.mul(this.getTexture(i).r):s=n}else if(i===B.THICKNESS){const n=this.getFloat(i);e.thicknessMap?s=n.mul(this.getTexture(i).g):s=n}else if(i===B.IOR)s=this.getFloat(i);else if(i===B.REFRACTION_RATIO)s=this.getFloat(i);else if(i===B.LIGHT_MAP)s=this.getTexture(i).rgb.mul(this.getFloat("lightMapIntensity"));else if(i===B.AO_MAP)s=this.getTexture(i).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else{const n=this.getNodeType(t);s=this.getCache(i,n)}return s}}B.ALPHA_TEST="alphaTest";B.COLOR="color";B.OPACITY="opacity";B.SHININESS="shininess";B.SPECULAR="specular";B.SPECULAR_STRENGTH="specularStrength";B.SPECULAR_INTENSITY="specularIntensity";B.SPECULAR_COLOR="specularColor";B.REFLECTIVITY="reflectivity";B.ROUGHNESS="roughness";B.METALNESS="metalness";B.NORMAL="normal";B.CLEARCOAT="clearcoat";B.CLEARCOAT_ROUGHNESS="clearcoatRoughness";B.CLEARCOAT_NORMAL="clearcoatNormal";B.EMISSIVE="emissive";B.ROTATION="rotation";B.SHEEN="sheen";B.SHEEN_ROUGHNESS="sheenRoughness";B.ANISOTROPY="anisotropy";B.IRIDESCENCE="iridescence";B.IRIDESCENCE_IOR="iridescenceIOR";B.IRIDESCENCE_THICKNESS="iridescenceThickness";B.IOR="ior";B.TRANSMISSION="transmission";B.THICKNESS="thickness";B.ATTENUATION_DISTANCE="attenuationDistance";B.ATTENUATION_COLOR="attenuationColor";B.LINE_SCALE="scale";B.LINE_DASH_SIZE="dashSize";B.LINE_GAP_SIZE="gapSize";B.LINE_WIDTH="linewidth";B.LINE_DASH_OFFSET="dashOffset";B.POINT_WIDTH="pointWidth";B.DISPERSION="dispersion";B.LIGHT_MAP="light";B.AO_MAP="ao";B.REFRACTION_RATIO="refractionRatio";const LR=k(B,B.ALPHA_TEST),la=k(B,B.COLOR),UR=k(B,B.SHININESS),DR=k(B,B.EMISSIVE),sM=k(B,B.OPACITY),OR=k(B,B.SPECULAR),Kg=k(B,B.SPECULAR_INTENSITY),zR=k(B,B.SPECULAR_COLOR),Ql=k(B,B.SPECULAR_STRENGTH),cc=k(B,B.REFLECTIVITY),VR=k(B,B.ROUGHNESS),kR=k(B,B.METALNESS),nM=k(B,B.NORMAL),GR=k(B,B.CLEARCOAT),WR=k(B,B.CLEARCOAT_ROUGHNESS),HR=k(B,B.CLEARCOAT_NORMAL),$R=k(B,B.ROTATION),qR=k(B,B.SHEEN),jR=k(B,B.SHEEN_ROUGHNESS),XR=k(B,B.ANISOTROPY),YR=k(B,B.IRIDESCENCE),ZR=k(B,B.IRIDESCENCE_IOR),QR=k(B,B.IRIDESCENCE_THICKNESS),JR=k(B,B.TRANSMISSION),KR=k(B,B.THICKNESS),tE=k(B,B.IOR),eE=k(B,B.ATTENUATION_DISTANCE),iE=k(B,B.ATTENUATION_COLOR),Xd=k(B,B.LINE_SCALE),rM=k(B,B.LINE_DASH_SIZE),oM=k(B,B.LINE_GAP_SIZE),dc=k(B,B.LINE_WIDTH),ty=k(B,B.LINE_DASH_OFFSET),sE=k(B,B.POINT_WIDTH),nE=k(B,B.DISPERSION),aM=k(B,B.LIGHT_MAP),rE=k(B,B.AO_MAP),oE=k(B,B.REFRACTION_RATIO),Eo=H(new q).onReference(function(o){return o.material}).onRenderUpdate(function({material:o}){this.value.set(o.anisotropy*Math.cos(o.anisotropyRotation),o.anisotropy*Math.sin(o.anisotropyRotation))});O("MaterialNode",B);const Ae=le("position","vec3"),Ht=Ae.toVar("positionLocal"),Yd=$t(aa.mul(Ht).xyz,"v_positionWorld"),lM=$t(Ht.transformDirection(aa),"v_positionWorldDirection").normalize().toVar("positionWorldDirection"),ve=$t(ks.mul(Ht).xyz,"v_positionView"),Ft=$t(ve.negate(),"v_positionViewDirection").normalize().toVar("positionViewDirection");class hM extends st{constructor(t=null){super("vec4"),this.positionNode=t}setup(t){if(t.shaderStage==="fragment")return $t(t.context.mvp);const e=this.positionNode||Ht;return vi.mul(ks).mul(e)}}const Zd=I(hM);O("ModelViewProjectionNode",hM);class uM extends jh{constructor(t,e=null,i=0,s=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferStride=i,this.bufferOffset=s,this.usage=xh,this.instanced=!1,this.attribute=null,this.global=!0,t&&t.isBufferAttribute===!0&&(this.attribute=t,this.usage=t.usage,this.instanced=t.isInstancedBufferAttribute)}getHash(t){if(this.bufferStride===0&&this.bufferOffset===0){let e=t.globalCache.getData(this.value);return e===void 0&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getNodeType(t){return this.bufferType===null&&(this.bufferType=t.getTypeFromAttribute(this.attribute)),this.bufferType}setup(t){if(this.attribute!==null)return;const e=this.getNodeType(t),i=this.value,s=t.getTypeLength(e),n=this.bufferStride||s,r=this.bufferOffset,a=i.isInterleavedBuffer===!0?i:new J0(i,n),l=new kp(a,s,r);a.setUsage(this.usage),this.attribute=l,this.attribute.isInstancedBufferAttribute=this.instanced}generate(t){const e=this.getNodeType(t),i=t.getBufferAttributeFromNode(this,e),s=t.getPropertyName(i);let n=null;return t.shaderStage==="vertex"||t.shaderStage==="compute"?(this.name=s,n=s):n=$t(this).build(t,e),n}getInputType(){return"bufferAttribute"}setUsage(t){return this.usage=t,this.attribute&&this.attribute.isBufferAttribute===!0&&(this.attribute.usage=t),this}setInstanced(t){return this.instanced=t,this}}const su=(o,t,e,i)=>L(new uM(o,t,e,i)),aE=(o,t,e,i)=>su(o,t,e,i).setUsage(Nr),Qd=(o,t,e,i)=>su(o,t,e,i).setInstanced(!0),ey=(o,t,e,i)=>aE(o,t,e,i).setInstanced(!0);N("toAttribute",o=>su(o.value));O("BufferAttributeNode",uM);class cM extends X{constructor(t){super("void"),this.instanceMesh=t,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=Y.FRAME,this.buffer=null,this.bufferColor=null}setup(){let t=this.instanceMatrixNode,e=this.instanceColorNode;const i=this.instanceMesh;if(t===null){const h=i.instanceMatrix;if(i.count<=1e3)t=iu(h.array,"mat4",i.count).element(Qh);else{const u=new fA(h.array,16,1);this.buffer=u;const c=h.usage===Nr?ey:Qd,d=[c(u,"vec4",16,0),c(u,"vec4",16,4),c(u,"vec4",16,8),c(u,"vec4",16,12)];t=Or(...d)}this.instanceMatrixNode=t}const s=i.instanceColor;if(s&&e===null){const h=new t_(s.array,3),u=s.usage===Nr?ey:Qd;this.bufferColor=h,e=P(u(h,"vec3",3,0)),this.instanceColorNode=e}const n=t.mul(Ht).xyz,r=de(t),a=li.div(P(r[0].dot(r[0]),r[1].dot(r[1]),r[2].dot(r[2]))),l=r.mul(a).xyz;Ht.assign(n),li.assign(l),this.instanceColorNode!==null&&Pi("vec3","vInstanceColor").assign(this.instanceColorNode)}update(){this.instanceMesh.instanceMatrix.usage!==Nr&&this.buffer!=null&&this.instanceMesh.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMesh.instanceMatrix.version),this.instanceMesh.instanceColor&&this.instanceMesh.instanceColor.usage!==Nr&&this.bufferColor!=null&&this.instanceMesh.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceMesh.instanceColor.version)}}const lE=I(cM);O("InstanceNode",cM);const dM=z((o,t)=>(t.geometry.hasAttribute("tangent")===!1&&t.geometry.computeTangents(),le("tangent","vec4")))(),af=dM.xyz.toVar("tangentLocal"),pM=$t(ks.mul(G(af,0)).xyz,"v_tangentView").normalize().toVar("tangentView");class fM extends X{constructor(t){super("void"),this.batchMesh=t,this.instanceColorNode=null,this.batchingIdNode=null}setup(t){this.batchingIdNode===null&&(t.getDrawIndex()===null?this.batchingIdNode=Qh:this.batchingIdNode=_N);const e=z(([d])=>{const p=Xr(es(this.batchMesh._indirectTexture),0),f=xt(d).remainder(xt(p)),m=xt(d).div(xt(p));return es(this.batchMesh._indirectTexture,Us(f,m)).x}).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]}),i=this.batchMesh._matricesTexture,s=Xr(es(i),0),n=C(e(xt(this.batchingIdNode))).mul(4).toVar(),r=xt(n.mod(s)),a=xt(n).div(xt(s)),l=Or(es(i,Us(r,a)),es(i,Us(r.add(1),a)),es(i,Us(r.add(2),a)),es(i,Us(r.add(3),a))),h=de(l);Ht.assign(l.mul(Ht));const u=li.div(P(h[0].dot(h[0]),h[1].dot(h[1]),h[2].dot(h[2]))),c=h.mul(u).xyz;li.assign(c),t.hasGeometryAttribute("tangent")&&af.mulAssign(h)}}const hE=I(fM);O("batch",fM);class mM extends X{constructor(t,e=!1){super("void"),this.skinnedMesh=t,this.useReference=e,this.updateType=Y.OBJECT,this.skinIndexNode=le("skinIndex","uvec4"),this.skinWeightNode=le("skinWeight","vec4");let i,s,n;e?(i=Wt("bindMatrix","mat4"),s=Wt("bindMatrixInverse","mat4"),n=PR("skeleton.boneMatrices","mat4",t.skeleton.bones.length)):(i=H(t.bindMatrix,"mat4"),s=H(t.bindMatrixInverse,"mat4"),n=iu(t.skeleton.boneMatrices,"mat4",t.skeleton.bones.length)),this.bindMatrixNode=i,this.bindMatrixInverseNode=s,this.boneMatricesNode=n}setup(t){const{skinIndexNode:e,skinWeightNode:i,bindMatrixNode:s,bindMatrixInverseNode:n,boneMatricesNode:r}=this,a=r.element(e.x),l=r.element(e.y),h=r.element(e.z),u=r.element(e.w),c=s.mul(Ht),d=Yt(a.mul(i.x).mul(c),l.mul(i.y).mul(c),h.mul(i.z).mul(c),u.mul(i.w).mul(c)),p=n.mul(d).xyz;let f=Yt(i.x.mul(a),i.y.mul(l),i.z.mul(h),i.w.mul(u));f=n.mul(f).mul(s);const m=f.transformDirection(li).xyz;Ht.assign(p),li.assign(m),t.hasGeometryAttribute("tangent")&&af.assign(m)}generate(t,e){if(e!=="void")return Ht.build(t,e)}update(t){(this.useReference?t.object:this.skinnedMesh).skeleton.update()}}const uE=o=>L(new mM(o,!0));O("SkinningNode",mM);class gM extends X{constructor(t=[]){super(),this.params=t}getVarName(t){return String.fromCharCode(105+t)}getProperties(t){const e=t.getNodeProperties(this);if(e.stackNode!==void 0)return e;const i={};for(let n=0,r=this.params.length-1;n<r;n++){const a=this.params[n],l=a.isNode!==!0&&a.name||this.getVarName(n),h=a.isNode!==!0&&a.type||"int";i[l]=tu(l,h)}const s=t.addStack();return e.returnsNode=this.params[this.params.length-1](i,s,t),e.stackNode=s,t.removeStack(),e}getNodeType(t){const{returnsNode:e}=this.getProperties(t);return e?e.getNodeType(t):"void"}setup(t){this.getProperties(t)}generate(t){const e=this.getProperties(t),i=this.params,s=e.stackNode;for(let a=0,l=i.length-1;a<l;a++){const h=i[a];let u=null,c=null,d=null,p=null,f=null,m=null;h.isNode?(p="int",d=this.getVarName(a),u="0",c=h.build(t,p),f="<"):(p=h.type||"int",d=h.name||this.getVarName(a),u=h.start,c=h.end,f=h.condition,m=h.update,typeof u=="number"?u=u.toString():u&&u.isNode&&(u=u.build(t,p)),typeof c=="number"?c=c.toString():c&&c.isNode&&(c=c.build(t,p)),u!==void 0&&c===void 0?(u=u+" - 1",c="0",f=">="):c!==void 0&&u===void 0&&(u="0",f="<"),f===void 0&&(Number(u)>Number(c)?f=">=":f="<"));const g={start:u,end:c},y=g.start,x=g.end;let M="",_="",v="";m||(p==="int"||p==="uint"?f.includes("<")?m="++":m="--":f.includes("<")?m="+= 1.":m="-= 1."),M+=t.getVar(p,d)+" = "+y,_+=d+" "+f+" "+x,v+=d+" "+m;const A=`for ( ${M}; ${_}; ${v} )`;t.addFlowCode((a===0?`
`:"")+t.tab+A+` {

`).addFlowTab()}const n=s.build(t,"void"),r=e.returnsNode?e.returnsNode.build(t):"";t.removeFlowTab().addFlowCode(`
`+t.tab+n);for(let a=0,l=this.params.length-1;a<l;a++)t.addFlowCode((a===0?"":t.tab)+`}

`).removeFlowTab();return t.addFlowTab(),r}}const Te=(...o)=>L(new gM(Dr(o,"int"))).append(),lf=()=>tu("break").append();N("loop",(o,...t)=>w_(o,Te(...t)));O("LoopNode",gM);const pc=new WeakMap,We=new _t,iy=z(({bufferMap:o,influence:t,stride:e,width:i,depth:s,offset:n})=>{const r=xt(xN).mul(e).add(n),a=r.div(i),l=r.sub(a.mul(i));return es(o,Us(l,a)).depth(s).mul(t)});function cE(o){const t=o.morphAttributes.position!==void 0,e=o.morphAttributes.normal!==void 0,i=o.morphAttributes.color!==void 0,s=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,n=s!==void 0?s.length:0;let r=pc.get(o);if(r===void 0||r.count!==n){let y=function(){m.dispose(),pc.delete(o),o.removeEventListener("dispose",y)};r!==void 0&&r.texture.dispose();const a=o.morphAttributes.position||[],l=o.morphAttributes.normal||[],h=o.morphAttributes.color||[];let u=0;t===!0&&(u=1),e===!0&&(u=2),i===!0&&(u=3);let c=o.attributes.position.count*u,d=1;const p=4096;c>p&&(d=Math.ceil(c/p),c=p);const f=new Float32Array(c*d*4*n),m=new p1(f,c,d,n);m.type=qe,m.needsUpdate=!0;const g=u*4;for(let x=0;x<n;x++){const M=a[x],_=l[x],v=h[x],A=c*d*4*x;for(let T=0;T<M.count;T++){const w=T*g;t===!0&&(We.fromBufferAttribute(M,T),f[A+w+0]=We.x,f[A+w+1]=We.y,f[A+w+2]=We.z,f[A+w+3]=0),e===!0&&(We.fromBufferAttribute(_,T),f[A+w+4]=We.x,f[A+w+5]=We.y,f[A+w+6]=We.z,f[A+w+7]=0),i===!0&&(We.fromBufferAttribute(v,T),f[A+w+8]=We.x,f[A+w+9]=We.y,f[A+w+10]=We.z,f[A+w+11]=v.itemSize===4?We.w:1)}}r={count:n,texture:m,stride:u,size:new q(c,d)},pc.set(o,r),o.addEventListener("dispose",y)}return r}class yM extends X{constructor(t){super("void"),this.mesh=t,this.morphBaseInfluence=H(1),this.updateType=Y.OBJECT}setup(t){const{geometry:e}=t,i=e.morphAttributes.position!==void 0,s=e.morphAttributes.normal!==void 0,n=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,r=n!==void 0?n.length:0,{texture:a,stride:l,size:h}=cE(e);i===!0&&Ht.mulAssign(this.morphBaseInfluence),s===!0&&li.mulAssign(this.morphBaseInfluence);const u=xt(h.width);Te(r,({i:c})=>{const d=C(0).toVar();this.mesh.count>1&&this.mesh.morphTexture!==null&&this.mesh.morphTexture!==void 0?d.assign(es(this.mesh.morphTexture,Us(xt(c).add(1),xt(Qh))).r):d.assign(Wt("morphTargetInfluences","float").element(c).toVar()),i===!0&&Ht.addAssign(iy({bufferMap:a,influence:d,stride:l,width:u,depth:c,offset:xt(0)})),s===!0&&li.addAssign(iy({bufferMap:a,influence:d,stride:l,width:u,depth:c,offset:xt(1)}))})}update(){const t=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?t.value=1:t.value=1-this.mesh.morphTargetInfluences.reduce((e,i)=>e+i,0)}}const dE=I(yM);O("MorphNode",yM);const pE=Ft.negate().reflect(Ct),fE=Ft.negate().refract(Ct,oE),mE=pE.transformDirection(Pn).toVar("reflectVector"),gE=fE.transformDirection(Pn).toVar("reflectVector");class xM extends zi{constructor(t,e=null,i=null,s=null){super(t,e,i,s),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){const t=this.value;return t.mapping===Hr?mE:t.mapping===ra?gE:(console.error('THREE.CubeTextureNode: Mapping "%s" not supported.',t.mapping),P(0,0,0))}setUpdateMatrix(){}setupUV(t,e){const i=this.value;return t.renderer.coordinateSystem===bn||!i.isRenderTargetTexture?P(e.x.negate(),e.yz):e}generateUV(t,e){return e.build(t,"vec3")}}const nu=I(xM);N("cubeTexture",nu);O("CubeTextureNode",xM);class Fn extends X{constructor(){super("vec3"),this.isLightingNode=!0}generate(){console.warn("Abstract function.")}}O("LightingNode",Fn);const yE=z(({depthTexture:o,shadowCoord:t})=>gt(o,t.xy).compare(t.z)),xE=z(({depthTexture:o,shadowCoord:t,shadow:e})=>{const i=(m,g)=>gt(o,m).compare(g),s=Wt("mapSize","vec2",e),n=Wt("radius","float",e),r=F(1).div(s),a=r.x.negate().mul(n),l=r.y.negate().mul(n),h=r.x.mul(n),u=r.y.mul(n),c=a.div(2),d=l.div(2),p=h.div(2),f=u.div(2);return Yt(i(t.xy.add(F(a,l)),t.z),i(t.xy.add(F(0,l)),t.z),i(t.xy.add(F(h,l)),t.z),i(t.xy.add(F(c,d)),t.z),i(t.xy.add(F(0,d)),t.z),i(t.xy.add(F(p,d)),t.z),i(t.xy.add(F(a,0)),t.z),i(t.xy.add(F(c,0)),t.z),i(t.xy,t.z),i(t.xy.add(F(p,0)),t.z),i(t.xy.add(F(h,0)),t.z),i(t.xy.add(F(c,f)),t.z),i(t.xy.add(F(0,f)),t.z),i(t.xy.add(F(p,f)),t.z),i(t.xy.add(F(a,u)),t.z),i(t.xy.add(F(0,u)),t.z),i(t.xy.add(F(h,u)),t.z)).mul(1/17)}),_E=z(({depthTexture:o,shadowCoord:t,shadow:e})=>{const i=(u,c)=>gt(o,u).compare(c),s=Wt("mapSize","vec2",e),n=F(1).div(s),r=n.x,a=n.y,l=t.xy,h=En(l.mul(s).add(.5));return l.subAssign(h.mul(n)),Yt(i(l,t.z),i(l.add(F(r,0)),t.z),i(l.add(F(0,a)),t.z),i(l.add(n),t.z),K(i(l.add(F(r.negate(),0)),t.z),i(l.add(F(r.mul(2),0)),t.z),h.x),K(i(l.add(F(r.negate(),a)),t.z),i(l.add(F(r.mul(2),a)),t.z),h.x),K(i(l.add(F(0,a.negate())),t.z),i(l.add(F(0,a.mul(2))),t.z),h.y),K(i(l.add(F(r,a.negate())),t.z),i(l.add(F(r,a.mul(2))),t.z),h.y),K(K(i(l.add(F(r.negate(),a.negate())),t.z),i(l.add(F(r.mul(2),a.negate())),t.z),h.x),K(i(l.add(F(r.negate(),a.mul(2))),t.z),i(l.add(F(r.mul(2),a.mul(2))),t.z),h.x),h.y)).mul(1/9)}),ME=[yE,xE,_E];let Co=null;class $s extends Fn{constructor(t=null){super(),this.updateType=Y.FRAME,this.light=t,this.color=new nt,this.colorNode=H(this.color),this.baseColorNode=null,this.shadowMap=null,this.shadowNode=null,this.shadowColorNode=null,this.isAnalyticLightNode=!0}getCacheKey(){return super.getCacheKey()+"-"+(this.light.id+"-"+(this.light.castShadow?"1":"0"))}getHash(){return this.light.uuid}setupShadow(t){const{object:e,renderer:i}=t;let s=this.shadowColorNode;if(s===null){Co===null&&(Co=t.createNodeMaterial(),Co.fragmentNode=G(0,0,0,1),Co.isShadowNodeMaterial=!0);const n=new _a;n.compareFunction=Up;const r=this.light.shadow,a=t.createRenderTarget(r.mapSize.width,r.mapSize.height);a.depthTexture=n,r.camera.updateProjectionMatrix();const l=Wt("intensity","float",r),h=Wt("bias","float",r),u=Wt("normalBias","float",r),c=e.material.shadowPositionNode||Yd;let d=H(r.matrix).mul(c.add(of.mul(u)));d=d.xyz.div(d.w);let p=d.z.add(h);i.coordinateSystem===bn&&(p=p.mul(2).sub(1)),d=P(d.x,d.y.oneMinus(),p);const f=d.x.greaterThanEqual(0).and(d.x.lessThanEqual(1)).and(d.y.greaterThanEqual(0)).and(d.y.lessThanEqual(1)).and(d.z.lessThanEqual(1)),m=r.filterNode||ME[i.shadowMap.type]||null;if(m===null)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const g=f.cond(m({depthTexture:n,shadowCoord:d,shadow:r}),C(1));this.shadowMap=a,this.shadowNode=g,this.shadowColorNode=s=this.colorNode.mul(K(1,g,l)),this.baseColorNode=this.colorNode}this.colorNode=s,this.updateBeforeType=Y.RENDER}setup(t){this.colorNode=this.baseColorNode||this.colorNode,this.light.castShadow?t.object.receiveShadow&&this.setupShadow(t):this.shadowNode!==null&&this.disposeShadow()}updateShadow(t){const{shadowMap:e,light:i}=this,{renderer:s,scene:n,camera:r}=t,a=n.overrideMaterial;n.overrideMaterial=Co,e.setSize(i.shadow.mapSize.width,i.shadow.mapSize.height),i.shadow.updateMatrices(i),i.shadow.camera.layers.mask=r.layers.mask;const l=s.getRenderTarget(),h=s.getRenderObjectFunction();s.setRenderObjectFunction((u,...c)=>{u.castShadow===!0&&s.renderObject(u,...c)}),s.setRenderTarget(e),s.render(n,i.shadow.camera),s.setRenderTarget(l),s.setRenderObjectFunction(h),n.overrideMaterial=a}disposeShadow(){this.shadowMap.dispose(),this.shadowMap=null,this.shadowNode=null,this.shadowColorNode=null,this.baseColorNode=null,this.updateBeforeType=Y.NONE}updateBefore(t){this.updateShadow(t)}update(){const{light:t}=this;this.color.copy(t.color).multiplyScalar(t.intensity)}}O("AnalyticLightNode",$s);const Ch=new WeakMap,vE=o=>o.sort((t,e)=>t.id-e.id);class _M extends X{constructor(t=[]){super("vec3"),this.totalDiffuseNode=P().temp("totalDiffuse"),this.totalSpecularNode=P().temp("totalSpecular"),this.outgoingLightNode=P().temp("outgoingLight"),this.lightNodes=t,this._hash=null}get hasLight(){return this.lightNodes.length>0}getHash(){if(this._hash===null){const t=[];for(const e of this.lightNodes)t.push(e.getHash());this._hash="lights-"+t.join(",")}return this._hash}analyze(t){const e=t.getDataFromNode(this);for(const i of e.nodes)i.build(t)}setup(t){const e=t.context,i=e.lightingModel;let s=this.outgoingLightNode;if(i){const{lightNodes:n,totalDiffuseNode:r,totalSpecularNode:a}=this;e.outgoingLight=s;const l=t.addStack(),h=t.getDataFromNode(this);h.nodes=l.nodes,i.start(e,l,t);for(const y of n)y.build(t);i.indirect(e,l,t);const{backdrop:u,backdropAlpha:c}=e,{directDiffuse:d,directSpecular:p,indirectDiffuse:f,indirectSpecular:m}=e.reflectedLight;let g=d.add(f);u!==null&&(c!==null?g=P(c.mix(g,u)):g=P(u),e.material.transparent=!0),r.assign(g),a.assign(p.add(m)),s.assign(r.add(a)),i.finish(e,l,t),s=s.bypass(t.removeStack())}return s}_getLightNodeById(t){for(const e of this.lightNodes)if(e.isAnalyticLightNode&&e.light.id===t)return e;return null}fromLights(t=[]){const e=[];t=vE(t);for(const i of t){let s=this._getLightNodeById(i.id);if(s===null){const n=i.constructor,r=Ch.has(n)?Ch.get(n):$s;s=L(new r(i))}e.push(s)}return this.lightNodes=e,this._hash=null,this}}const TE=I(_M);function In(o,t){if(Ch.has(o)){console.warn(`Redefinition of light node ${t.type}`);return}if(typeof o!="function")throw new Error(`Light ${o.name} is not a class`);if(typeof t!="function"||!t.type)throw new Error(`Light node ${t.type} is not a class`);Ch.set(o,t)}class MM extends Fn{constructor(t=null){super(),this.aoNode=t}setup(t){t.context.ambientOcclusion.mulAssign(this.aoNode)}}O("AONode",MM);class vM extends Jp{constructor(t,e=null,i=null,s=null){super(t),this.lightingModel=e,this.backdropNode=i,this.backdropAlphaNode=s,this._context=null}getContext(){const{backdropNode:t,backdropAlphaNode:e}=this,i=P().temp("directDiffuse"),s=P().temp("directSpecular"),n=P().temp("indirectDiffuse"),r=P().temp("indirectSpecular"),a={directDiffuse:i,directSpecular:s,indirectDiffuse:n,indirectSpecular:r};return{radiance:P().temp("radiance"),irradiance:P().temp("irradiance"),iblIrradiance:P().temp("iblIrradiance"),ambientOcclusion:C(1).temp("ambientOcclusion"),reflectedLight:a,backdrop:t,backdropAlpha:e}}setup(t){return this.context=this._context||(this._context=this.getContext()),this.context.lightingModel=this.lightingModel||t.context.lightingModel,super.setup(t)}}const TM=I(vM);N("lightingContext",TM);O("LightingContextNode",vM);class bM extends Fn{constructor(t){super(),this.node=t}setup(t){t.context.irradiance.addAssign(this.node)}}O("IrradianceNode",bM);let fc,mc;class mt extends X{constructor(t){super(),this.scope=t,this.isViewportNode=!0}getNodeType(){return this.scope===mt.VIEWPORT?"vec4":this.scope===mt.COORDINATE?"vec3":"vec2"}getUpdateType(){let t=Y.NONE;return(this.scope===mt.RESOLUTION||this.scope===mt.VIEWPORT)&&(t=Y.RENDER),this.updateType=t,t}update({renderer:t}){this.scope===mt.VIEWPORT?t.getViewport(mc):t.getDrawingBufferSize(fc)}setup(){const t=this.scope;let e=null;if(t===mt.RESOLUTION)e=H(fc||(fc=new q));else if(t===mt.VIEWPORT)e=H(mc||(mc=new _t));else{e=bE.div(Jd);let i=e.x,s=e.y;/bottom/i.test(t)&&(s=s.oneMinus()),/right/i.test(t)&&(i=i.oneMinus()),e=F(i,s)}return e}generate(t){if(this.scope===mt.COORDINATE){let e=t.getFragCoord();if(t.isFlipY()){const i=t.getNodeProperties(Jd).outputNode.build(t);e=`${t.getType("vec3")}( ${e}.x, ${i}.y - ${e}.y, ${e}.z )`}return e}return super.generate(t)}}mt.COORDINATE="coordinate";mt.RESOLUTION="resolution";mt.VIEWPORT="viewport";mt.TOP_LEFT="topLeft";mt.BOTTOM_LEFT="bottomLeft";mt.TOP_RIGHT="topRight";mt.BOTTOM_RIGHT="bottomRight";const bE=k(mt,mt.COORDINATE),Jd=k(mt,mt.RESOLUTION),Gr=k(mt,mt.VIEWPORT),Zr=k(mt,mt.TOP_LEFT),SE=k(mt,mt.BOTTOM_LEFT);k(mt,mt.TOP_RIGHT);k(mt,mt.BOTTOM_RIGHT);O("ViewportNode",mt);const Po=new q;class Sa extends zi{constructor(t=Zr,e=null,i=null){i===null&&(i=new n_,i.minFilter=as),super(i,t,e),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=Y.FRAME}updateBefore(t){const e=t.renderer;e.getDrawingBufferSize(Po);const i=this.value;(i.image.width!==Po.width||i.image.height!==Po.height)&&(i.image.width=Po.width,i.image.height=Po.height,i.needsUpdate=!0);const s=i.generateMipmaps;i.generateMipmaps=this.generateMipmaps,e.copyFramebufferToTexture(i),i.generateMipmaps=s}clone(){const t=new this.constructor(this.uvNode,this.levelNode,this.value);return t.generateMipmaps=this.generateMipmaps,t}}const wE=I(Sa),SM=I(Sa,null,null,{generateMipmaps:!0});N("viewportTexture",wE);N("viewportMipTexture",SM);O("ViewportTextureNode",Sa);let gc=null;class wM extends Sa{constructor(t=Zr,e=null){gc===null&&(gc=new _a),super(t,e,gc)}}const AM=I(wM);N("viewportDepthTexture",AM);O("ViewportDepthTextureNode",wM);class Ze extends X{constructor(t,e=null){super("float"),this.scope=t,this.valueNode=e,this.isViewportDepthNode=!0}generate(t){const{scope:e}=this;return e===Ze.DEPTH?t.getFragDepth():super.generate(t)}setup({camera:t}){const{scope:e}=this,i=this.valueNode;let s=null;if(e===Ze.DEPTH)i!==null?s=RM().assign(i):t.isPerspectiveCamera?s=AE(ve.z,No,Ro):s=Jl(ve.z,No,Ro);else if(e===Ze.LINEAR_DEPTH)if(i!==null)if(t.isPerspectiveCamera){const n=NM(i,No,Ro);s=Jl(n,No,Ro)}else s=i;else s=Jl(ve.z,No,Ro);return s}}const Jl=(o,t,e)=>o.add(t).div(t.sub(e)),AE=(o,t,e)=>t.add(o).mul(e).div(e.sub(t).mul(o)),NM=(o,t,e)=>t.mul(e).div(e.sub(t).mul(o).sub(e));Ze.DEPTH="depth";Ze.LINEAR_DEPTH="linearDepth";const RM=I(Ze,Ze.DEPTH),EM=k(Ze,Ze.DEPTH),NE=I(Ze,Ze.LINEAR_DEPTH);NE(AM());EM.assign=o=>RM(o);O("ViewportDepthNode",Ze);class Gs extends X{constructor(t=Gs.DEFAULT){super(),this.scope=t}setup(t){super.setup(t);const e=t.clippingContext,{localClipIntersection:i,localClippingCount:s,globalClippingCount:n}=e,r=n+s,a=i?r-s:r;return this.scope===Gs.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(e.planes,r,a):this.setupDefault(e.planes,r,a)}setupAlphaToCoverage(t,e,i){return z(()=>{const s=zs(t),n=Tt("float","distanceToPlane"),r=Tt("float","distanceToGradient"),a=Tt("float","clipOpacity");a.assign(1);let l;if(Te(i,({i:h})=>{l=s.element(h),n.assign(ve.dot(l.xyz).negate().add(l.w)),r.assign(n.fwidth().div(2)),a.mulAssign(Je(r.negate(),r,n)),a.equal(0).discard()}),i<e){const h=Tt("float","unionclipOpacity");h.assign(1),Te({start:i,end:e},({i:u})=>{l=s.element(u),n.assign(ve.dot(l.xyz).negate().add(l.w)),r.assign(n.fwidth().div(2)),h.mulAssign(Je(r.negate(),r,n).oneMinus())}),a.mulAssign(h.oneMinus())}pt.a.mulAssign(a),pt.a.equal(0).discard()})()}setupDefault(t,e,i){return z(()=>{const s=zs(t);let n;if(Te(i,({i:r})=>{n=s.element(r),ve.dot(n.xyz).greaterThan(n.w).discard()}),i<e){const r=Tt("bool","clipped");r.assign(!0),Te({start:i,end:e},({i:a})=>{n=s.element(a),r.assign(ve.dot(n.xyz).greaterThan(n.w).and(r))}),r.discard()}})()}}Gs.ALPHA_TO_COVERAGE="alphaToCoverage";Gs.DEFAULT="default";const RE=()=>L(new Gs),EE=()=>L(new Gs(Gs.ALPHA_TO_COVERAGE));class CM extends X{constructor(){super("bool"),this.isFrontFacingNode=!0}generate(t){const{renderer:e,material:i}=t;return e.coordinateSystem===bi&&i.side===ms?"false":t.getFrontFacing()}}const CE=k(CM),Ph=C(CE).mul(2).sub(1);O("FrontFacingNode",CM);const Kd=new Map;class Dt extends Ue{constructor(){super(),this.isNodeMaterial=!0,this.type=this.constructor.type,this.forceSinglePass=!1,this.fog=!0,this.lights=!1,this.normals=!0,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.depthNode=null,this.shadowNode=null,this.shadowPositionNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+p_(this)}build(t){this.setup(t)}setup(t){t.addStack(),t.stack.outputNode=this.vertexNode||this.setupPosition(t),t.addFlow("vertex",t.removeStack()),t.addStack();let e;const i=this.setupClipping(t);if(this.depthWrite===!0&&this.setupDepth(t),this.fragmentNode===null){this.normals===!0&&this.setupNormal(t),this.setupDiffuseColor(t),this.setupVariants(t);const s=this.setupLighting(t);i!==null&&t.stack.add(i);const n=G(s,pt.a).max(0);if(e=this.setupOutput(t,n),wN.assign(e),this.outputNode!==null&&(e=this.outputNode),t.renderer.getRenderTarget()!==null){const a=t.renderer.getMRT(),l=this.mrtNode;a!==null?(e=a,l!==null&&(e=a.merge(l))):l!==null&&(e=l)}}else{let s=this.fragmentNode;s.isOutputStructNode!==!0&&(s=G(s)),e=this.setupOutput(t,s)}t.stack.outputNode=e,t.addFlow("fragment",t.removeStack())}setupClipping(t){if(t.clippingContext===null)return null;const{globalClippingCount:e,localClippingCount:i}=t.clippingContext;let s=null;return(e||i)&&(this.alphaToCoverage?s=EE():t.stack.add(RE())),s}setupDepth(t){const{renderer:e}=t;let i=this.depthNode;i===null&&e.logarithmicDepthBuffer===!0&&(i=Zd().w.add(1).log2().mul(FR).mul(.5)),i!==null&&EM.assign(i).append()}setupPosition(t){const{object:e}=t,i=e.geometry;if(t.addStack(),(i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color)&&dE(e).append(),e.isSkinnedMesh===!0&&uE(e).append(),this.displacementMap){const n=ct("displacementMap","texture"),r=ct("displacementScale","float"),a=ct("displacementBias","float");Ht.addAssign(li.normalize().mul(n.x.mul(r).add(a)))}e.isBatchedMesh&&hE(e).append(),e.instanceMatrix&&e.instanceMatrix.isInstancedBufferAttribute===!0&&lE(e).append(),this.positionNode!==null&&Ht.assign(this.positionNode);const s=Zd();return t.context.vertex=t.removeStack(),t.context.mvp=s,s}setupDiffuseColor({object:t,geometry:e}){let i=this.colorNode?G(this.colorNode):la;this.vertexColors===!0&&e.hasAttribute("color")&&(i=G(i.xyz.mul(le("color","vec3")),i.a)),t.instanceColor&&(i=Pi("vec3","vInstanceColor").mul(i)),pt.assign(i);const s=this.opacityNode?C(this.opacityNode):sM;if(pt.a.assign(pt.a.mul(s)),this.alphaTestNode!==null||this.alphaTest>0){const n=this.alphaTestNode!==null?C(this.alphaTestNode):LR;pt.a.lessThanEqual(n).discard()}this.transparent===!1&&this.blending===os&&this.alphaToCoverage===!1&&pt.a.assign(1)}setupVariants(){}setupOutgoingLight(){return this.lights===!0?P(0):pt.rgb}setupNormal(){if(this.flatShading===!0){const t=ve.dFdx().cross(ve.dFdy()).normalize();Ct.assign(t.mul(Ph))}else{const t=this.normalNode?P(this.normalNode):nM;Ct.assign(t.mul(Ph))}}setupEnvironment(t){let e=null;return this.envNode?e=this.envNode:this.envMap?e=this.envMap.isCubeTexture?nu(this.envMap):gt(this.envMap):t.environmentNode&&(e=t.environmentNode),e}setupLightMap(t){let e=null;return t.material.lightMap&&(e=new bM(aM)),e}setupLights(t){const e=[],i=this.setupEnvironment(t);i&&i.isLightingNode&&e.push(i);const s=this.setupLightMap(t);if(s&&s.isLightingNode&&e.push(s),this.aoNode!==null||t.material.aoMap){const r=this.aoNode!==null?this.aoNode:rE;e.push(new MM(r))}let n=this.lightsNode||t.lightsNode;return e.length>0&&(n=TE([...n.lightNodes,...e])),n}setupLightingModel(){}setupLighting(t){const{material:e}=t,{backdropNode:i,backdropAlphaNode:s,emissiveNode:n}=this,a=this.lights===!0||this.lightsNode!==null?this.setupLights(t):null;let l=this.setupOutgoingLight(t);if(a&&a.hasLight!==!1){const h=this.setupLightingModel(t);l=TM(a,h,i,s)}else i!==null&&(l=P(s!==null?K(l,i,s):i));return(n&&n.isNode===!0||e.emissive&&e.emissive.isColor===!0)&&(Zg.assign(P(n||DR)),l=l.add(Zg)),l}setupOutput(t,e){if(this.fog===!0){const i=t.fogNode;i&&(e=G(i.mix(e.rgb,i.colorNode),e.a))}return e}setDefaultValues(t){for(const i in t){const s=t[i];this[i]===void 0&&(this[i]=s,s&&s.clone&&(this[i]=s.clone()))}const e=Object.getOwnPropertyDescriptors(t.constructor.prototype);for(const i in e)Object.getOwnPropertyDescriptor(this.constructor.prototype,i)===void 0&&e[i].get!==void 0&&Object.defineProperty(this.constructor.prototype,i,e[i])}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{},nodes:{}});const i=Ue.prototype.toJSON.call(this,t),s=Th(this);i.inputNodes={};for(const{property:r,childNode:a}of s)i.inputNodes[r]=a.toJSON(t).uuid;function n(r){const a=[];for(const l in r){const h=r[l];delete h.metadata,a.push(h)}return a}if(e){const r=n(t.textures),a=n(t.images),l=n(t.nodes);r.length>0&&(i.textures=r),a.length>0&&(i.images=a),l.length>0&&(i.nodes=l)}return i}copy(t){return this.lightsNode=t.lightsNode,this.envNode=t.envNode,this.colorNode=t.colorNode,this.normalNode=t.normalNode,this.opacityNode=t.opacityNode,this.backdropNode=t.backdropNode,this.backdropAlphaNode=t.backdropAlphaNode,this.alphaTestNode=t.alphaTestNode,this.positionNode=t.positionNode,this.depthNode=t.depthNode,this.shadowNode=t.shadowNode,this.shadowPositionNode=t.shadowPositionNode,this.outputNode=t.outputNode,this.mrtNode=t.mrtNode,this.fragmentNode=t.fragmentNode,this.vertexNode=t.vertexNode,super.copy(t)}static fromMaterial(t){if(t.isNodeMaterial===!0)return t;const e=t.type.replace("Material","NodeMaterial"),i=hf(e);if(i===void 0)throw new Error(`NodeMaterial: Material "${t.type}" is not compatible.`);for(const s in t)i[s]=t[s];return i}}function ee(o,t){if(typeof t!="function"||!o)throw new Error(`Node material ${o} is not a class`);if(Kd.has(o)){console.warn(`Redefinition of node material ${o}`);return}Kd.set(o,t),t.type=o}function hf(o){const t=Kd.get(o);if(t!==void 0)return new t}ee("NodeMaterial",Dt);class Bn{constructor(t,e){this.name=t,this.value=e,this.boundary=0,this.itemSize=0,this.offset=0}setValue(t){this.value=t}getValue(){return this.value}}class PE extends Bn{constructor(t,e=0){super(t,e),this.isNumberUniform=!0,this.boundary=4,this.itemSize=1}}class FE extends Bn{constructor(t,e=new q){super(t,e),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class IE extends Bn{constructor(t,e=new E){super(t,e),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class BE extends Bn{constructor(t,e=new _t){super(t,e),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class LE extends Bn{constructor(t,e=new nt){super(t,e),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class UE extends Bn{constructor(t,e=new hi){super(t,e),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class DE extends Bn{constructor(t,e=new Bt){super(t,e),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class OE extends PE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class zE extends FE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class VE extends IE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class kE extends BE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class GE extends LE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class WE extends UE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class HE extends DE{constructor(t){super(t.name,t.value),this.nodeUniform=t}getValue(){return this.nodeUniform.value}}class uf extends X{constructor(t,e,i=null){super(),this.condNode=t,this.ifNode=e,this.elseNode=i}getNodeType(t){const e=this.ifNode.getNodeType(t);if(this.elseNode!==null){const i=this.elseNode.getNodeType(t);if(t.getTypeLength(i)>t.getTypeLength(e))return i}return e}setup(t){const e=t.getNodeProperties(this);e.condNode=this.condNode.cache(),e.ifNode=this.ifNode.cache(),e.elseNode=this.elseNode?this.elseNode.cache():null}generate(t,e){const i=this.getNodeType(t),s=t.getDataFromNode(this);if(s.nodeProperty!==void 0)return s.nodeProperty;const{condNode:n,ifNode:r,elseNode:a}=t.getNodeProperties(this),l=e!=="void",h=l?Tt(i).build(t):"";s.nodeProperty=h;const u=n.build(t,"bool");t.addFlowCode(`
${t.tab}if ( ${u} ) {

`).addFlowTab();let c=r.build(t,i);if(c&&(l?c=h+" = "+c+";":c="return "+c+";"),t.removeFlowTab().addFlowCode(t.tab+"	"+c+`

`+t.tab+"}"),a!==null){t.addFlowCode(` else {

`).addFlowTab();let d=a.build(t,i);d&&(l?d=h+" = "+d+";":d="return "+d+";"),t.removeFlowTab().addFlowCode(t.tab+"	"+d+`

`+t.tab+`}

`)}else t.addFlowCode(`

`);return t.format(h,i,e)}}const oi=I(uf);N("cond",oi);O("CondNode",uf);class PM extends X{constructor(t=null){super(),this.nodes=[],this.outputNode=null,this.parent=t,this._currentCond=null,this.isStackNode=!0}getNodeType(t){return this.outputNode?this.outputNode.getNodeType(t):"void"}add(t){return this.nodes.push(t),this}if(t,e){const i=new Yo(e);return this._currentCond=oi(t,i),this.add(this._currentCond)}elseif(t,e){const i=new Yo(e),s=oi(t,i);return this._currentCond.elseNode=s,this._currentCond=s,this}else(t){return this._currentCond.elseNode=new Yo(t),this}build(t,...e){const i=v_();bh(this);for(const s of this.nodes)s.build(t,"void");return bh(i),this.outputNode?this.outputNode.build(t,...e):super.build(t,...e)}}const yc=I(PM);O("StackNode",PM);class FM extends st{constructor(t=lM){super("vec2"),this.dirNode=t}setup(){const t=this.dirNode,e=t.z.atan2(t.x).mul(1/(Math.PI*2)).add(.5),i=t.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return F(e,i)}}const IM=I(FM);O("EquirectUVNode",FM);class $E extends E1{constructor(t=1,e={}){super(t,e),this.isCubeRenderTarget=!0}fromEquirectangularTexture(t,e){const i=e.minFilter,s=e.generateMipmaps;e.generateMipmaps=!0,this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n=new xa(5,5,5),r=IM(lM),a=hf("MeshBasicNodeMaterial");a.colorNode=gt(e,r,0),a.side=ms,a.blending=Wr;const l=new so(n,a),h=new Q0;return h.add(l),e.minFilter===as&&(e.minFilter=Le),new Y0(1,10,this).update(t,h),e.minFilter=i,e.currentGenerateMipmaps=s,l.geometry.dispose(),l.material.dispose(),this}}const sy=C(1),tp=C(-2),Sl=C(.8),xc=C(-1),wl=C(.4),_c=C(2),Al=C(.305),Mc=C(3),ny=C(.21),qE=C(4),ry=C(4),jE=C(16),XE=z(([o])=>{const t=P(ue(o)).toVar(),e=C(-1).toVar();return it(t.x.greaterThan(t.z),()=>{it(t.x.greaterThan(t.y),()=>{e.assign(oi(o.x.greaterThan(0),0,3))}).else(()=>{e.assign(oi(o.y.greaterThan(0),1,4))})}).else(()=>{it(t.z.greaterThan(t.y),()=>{e.assign(oi(o.z.greaterThan(0),2,5))}).else(()=>{e.assign(oi(o.y.greaterThan(0),1,4))})}),e}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),YE=z(([o,t])=>{const e=F().toVar();return it(t.equal(0),()=>{e.assign(F(o.z,o.y).div(ue(o.x)))}).elseif(t.equal(1),()=>{e.assign(F(o.x.negate(),o.z.negate()).div(ue(o.y)))}).elseif(t.equal(2),()=>{e.assign(F(o.x.negate(),o.y).div(ue(o.z)))}).elseif(t.equal(3),()=>{e.assign(F(o.z.negate(),o.y).div(ue(o.x)))}).elseif(t.equal(4),()=>{e.assign(F(o.x.negate(),o.z).div(ue(o.y)))}).else(()=>{e.assign(F(o.x,o.y).div(ue(o.z)))}),ut(.5,e.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),ZE=z(([o])=>{const t=C(0).toVar();return it(o.greaterThanEqual(Sl),()=>{t.assign(sy.sub(o).mul(xc.sub(tp)).div(sy.sub(Sl)).add(tp))}).elseif(o.greaterThanEqual(wl),()=>{t.assign(Sl.sub(o).mul(_c.sub(xc)).div(Sl.sub(wl)).add(xc))}).elseif(o.greaterThanEqual(Al),()=>{t.assign(wl.sub(o).mul(Mc.sub(_c)).div(wl.sub(Al)).add(_c))}).elseif(o.greaterThanEqual(ny),()=>{t.assign(Al.sub(o).mul(qE.sub(Mc)).div(Al.sub(ny)).add(Mc))}).else(()=>{t.assign(C(-2).mul(Jh(ut(1.16,o))))}),t}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]}),QE=z(([o,t])=>{const e=o.toVar();e.assign(ut(2,e).sub(1));const i=P(e,1).toVar();return it(t.equal(0),()=>{i.assign(i.zyx)}).elseif(t.equal(1),()=>{i.assign(i.xzy),i.xz.mulAssign(-1)}).elseif(t.equal(2),()=>{i.x.mulAssign(-1)}).elseif(t.equal(3),()=>{i.assign(i.zyx),i.xz.mulAssign(-1)}).elseif(t.equal(4),()=>{i.assign(i.xzy),i.xy.mulAssign(-1)}).elseif(t.equal(5),()=>{i.z.mulAssign(-1)}),i}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]}),JE=z(([o,t,e,i,s,n])=>{const r=C(e),a=P(t),l=Me(ZE(r),tp,n),h=En(l),u=ba(l),c=P(ep(o,a,u,i,s,n)).toVar();return it(h.notEqual(0),()=>{const d=P(ep(o,a,u.add(1),i,s,n)).toVar();c.assign(K(c,d,h))}),c}),ep=z(([o,t,e,i,s,n])=>{const r=C(e).toVar(),a=P(t),l=C(XE(a)).toVar(),h=C(Et(ry.sub(r),0)).toVar();r.assign(Et(r,ry));const u=C($d(r)).toVar(),c=F(YE(a,l).mul(u.sub(2)).add(1)).toVar();return it(l.greaterThan(2),()=>{c.y.addAssign(u),l.subAssign(3)}),c.x.addAssign(l.mul(u)),c.x.addAssign(h.mul(ut(3,jE))),c.y.addAssign(ut(4,$d(n).sub(u))),c.x.mulAssign(i),c.y.mulAssign(s),o.uv(c).grad(F(),F())}),vc=z(({envMap:o,mipInt:t,outputDirection:e,theta:i,axis:s,CUBEUV_TEXEL_WIDTH:n,CUBEUV_TEXEL_HEIGHT:r,CUBEUV_MAX_MIP:a})=>{const l=$e(i),h=e.mul(l).add(s.cross(e).mul(he(i))).add(s.mul(s.dot(e).mul(l.oneMinus())));return ep(o,h,t,n,r,a)}),KE=z(({n:o,latitudinal:t,poleAxis:e,outputDirection:i,weights:s,samples:n,dTheta:r,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c})=>{const d=P(oi(t,e,Zo(e,i))).toVar();it(z_(d.equals(P(0))),()=>{d.assign(P(i.z,0,i.x.negate()))}),d.assign(Mi(d));const p=P().toVar();return p.addAssign(s.element(xt(0)).mul(vc({theta:0,axis:d,outputDirection:i,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c}))),Te({start:xt(1),end:o},({i:f})=>{it(f.greaterThanEqual(n),()=>{lf()});const m=C(r.mul(C(f))).toVar();p.addAssign(s.element(f).mul(vc({theta:m.mul(-1),axis:d,outputDirection:i,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c}))),p.addAssign(s.element(f).mul(vc({theta:m,axis:d,outputDirection:i,mipInt:a,envMap:l,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:u,CUBEUV_MAX_MIP:c})))}),G(p,1)}),Pr=4,oy=[.125,.215,.35,.446,.526,.582],pn=20,Tc=new Hp(-1,1,1,-1,0,1),tC=new is(90,1),ay=new nt;let bc=null,Sc=0,wc=0;const dn=(1+Math.sqrt(5))/2,dr=1/dn,ly=[new E(-dn,dr,0),new E(dn,dr,0),new E(-dr,0,dn),new E(dr,0,dn),new E(0,dn,-dr),new E(0,dn,dr),new E(-1,1,-1),new E(1,1,-1),new E(-1,1,1),new E(1,1,1)],eC=[3,1,5,0,4,2],Ac=QE(Nt(),le("faceIndex")).normalize(),cf=P(Ac.x,Ac.y.negate(),Ac.z);class iC{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}fromScene(t,e=0,i=.1,s=100){bc=this._renderer.getRenderTarget(),Sc=this._renderer.getActiveCubeFace(),wc=this._renderer.getActiveMipmapLevel(),this._setSize(256);const n=this._allocateTargets();return n.depthBuffer=!0,this._sceneToCubeUV(t,i,s,n),e>0&&this._blur(n,0,0,e),this._applyPMREM(n),this._cleanup(n),n}fromEquirectangular(t,e=null){return this._fromTexture(t,e)}fromCubemap(t,e=null){return this._fromTexture(t,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=uy(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=cy(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose(),this._backgroundBox!==null&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSize(t){this._lodMax=Math.floor(Math.log2(t)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let t=0;t<this._lodPlanes.length;t++)this._lodPlanes[t].dispose()}_cleanup(t){this._renderer.setRenderTarget(bc,Sc,wc),t.scissorTest=!1,Nl(t,0,0,t.width,t.height)}_fromTexture(t,e){t.mapping===Hr||t.mapping===ra?this._setSize(t.image.length===0?16:t.image[0].width||t.image[0].image.width):this._setSize(t.image.width/4),bc=this._renderer.getRenderTarget(),Sc=this._renderer.getActiveCubeFace(),wc=this._renderer.getActiveMipmapLevel();const i=e||this._allocateTargets();return this._textureToCubeUV(t,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const t=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,i={magFilter:Le,minFilter:Le,generateMipmaps:!1,type:wi,format:io,colorSpace:Qe},s=hy(t,e,i);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==t||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=hy(t,e,i);const{_lodMax:n}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas,lodMeshes:this._lodMeshes}=sC(n)),this._blurMaterial=nC(n,t,e)}return s}_compileMaterial(t){const e=this._lodMeshes[0];e.material=t,this._renderer.compile(e,Tc)}_sceneToCubeUV(t,e,i,s){const n=tC;n.near=e,n.far=i;const r=[-1,1,-1,-1,-1,-1],a=[1,1,1,-1,-1,-1],l=this._renderer,h=l.autoClear;l.getClearColor(ay),l.autoClear=!1;let u=this._backgroundBox;if(u===null){const p=new Vp({name:"PMREM.Background",side:ms,depthWrite:!1,depthTest:!1});u=new so(new xa,p)}let c=!1;const d=t.background;d?d.isColor&&(u.material.color.copy(d),t.background=null,c=!0):(u.material.color.copy(ay),c=!0),l.setRenderTarget(s),l.clear(),c&&l.render(u,n);for(let p=0;p<6;p++){const f=p%3;f===0?(n.up.set(0,r[p],0),n.lookAt(a[p],0,0)):f===1?(n.up.set(0,0,r[p]),n.lookAt(0,a[p],0)):(n.up.set(0,r[p],0),n.lookAt(0,0,a[p]));const m=this._cubeSize;Nl(s,f*m,p>2?m:0,m,m),l.render(t,n)}l.autoClear=h,t.background=d}_textureToCubeUV(t,e){const i=this._renderer,s=t.mapping===Hr||t.mapping===ra;s?this._cubemapMaterial===null&&(this._cubemapMaterial=uy(t)):this._equirectMaterial===null&&(this._equirectMaterial=cy(t));const n=s?this._cubemapMaterial:this._equirectMaterial;n.fragmentNode.value=t;const r=this._lodMeshes[0];r.material=n;const a=this._cubeSize;Nl(e,0,0,3*a,2*a),i.setRenderTarget(e),i.render(r,Tc)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;const s=this._lodPlanes.length;for(let n=1;n<s;n++){const r=Math.sqrt(this._sigmas[n]*this._sigmas[n]-this._sigmas[n-1]*this._sigmas[n-1]),a=ly[(s-n-1)%ly.length];this._blur(t,n-1,n,r,a)}e.autoClear=i}_blur(t,e,i,s,n){const r=this._pingPongRenderTarget;this._halfBlur(t,r,e,i,s,"latitudinal",n),this._halfBlur(r,t,i,i,s,"longitudinal",n)}_halfBlur(t,e,i,s,n,r,a){const l=this._renderer,h=this._blurMaterial;r!=="latitudinal"&&r!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,c=this._lodMeshes[s];c.material=h;const d=h.uniforms,p=this._sizeLods[i]-1,f=isFinite(n)?Math.PI/(2*p):2*Math.PI/(2*pn-1),m=n/f,g=isFinite(n)?1+Math.floor(u*m):pn;g>pn&&console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${pn}`);const y=[];let x=0;for(let T=0;T<pn;++T){const w=T/m,U=Math.exp(-w*w/2);y.push(U),T===0?x+=U:T<g&&(x+=2*U)}for(let T=0;T<y.length;T++)y[T]=y[T]/x;t.texture.frame=(t.texture.frame||0)+1,d.envMap.value=t.texture,d.samples.value=g,d.weights.array=y,d.latitudinal.value=r==="latitudinal"?1:0,a&&(d.poleAxis.value=a);const{_lodMax:M}=this;d.dTheta.value=f,d.mipInt.value=M-i;const _=this._sizeLods[s],v=3*_*(s>M-Pr?s-M+Pr:0),A=4*(this._cubeSize-_);Nl(e,v,A,3*_,2*_),l.setRenderTarget(e),l.render(c,Tc)}}function sC(o){const t=[],e=[],i=[],s=[];let n=o;const r=o-Pr+1+oy.length;for(let a=0;a<r;a++){const l=Math.pow(2,n);e.push(l);let h=1/l;a>o-Pr?h=oy[a-o+Pr-1]:a===0&&(h=0),i.push(h);const u=1/(l-2),c=-u,d=1+u,p=[c,c,d,c,d,d,c,c,d,d,c,d],f=6,m=6,g=3,y=2,x=1,M=new Float32Array(g*m*f),_=new Float32Array(y*m*f),v=new Float32Array(x*m*f);for(let T=0;T<f;T++){const w=T%3*2/3-1,U=T>2?0:-1,D=[w,U,0,w+2/3,U,0,w+2/3,U+1,0,w,U,0,w+2/3,U+1,0,w,U+1,0],V=eC[T];M.set(D,g*m*V),_.set(p,y*m*V);const W=[V,V,V,V,V,V];v.set(W,x*m*V)}const A=new An;A.setAttribute("position",new ai(M,g)),A.setAttribute("uv",new ai(_,y)),A.setAttribute("faceIndex",new ai(v,x)),t.push(A),s.push(new so(A,null)),n>Pr&&n--}return{lodPlanes:t,sizeLods:e,sigmas:i,lodMeshes:s}}function hy(o,t,e){const i=new be(o,t,e);return i.texture.mapping=xw,i.texture.name="PMREM.cubeUv",i.texture.isPMREMTexture=!0,i.scissorTest=!0,i}function Nl(o,t,e,i,s){const n=o.height-s-e;o.viewport.set(t,n,i,s),o.scissor.set(t,n,i,s)}function df(){const o=new Dt;return o.depthTest=!1,o.depthWrite=!1,o.blending=Wr,o}function nC(o,t,e){const i=zs(new Array(pn).fill(0)),s=H(new E(0,1,0)),n=H(0),r=C(pn),a=H(0),l=H(1),h=gt(null),u=H(0),c=C(1/t),d=C(1/e),p=C(o),f={n:r,latitudinal:a,weights:i,poleAxis:s,outputDirection:cf,dTheta:n,samples:l,envMap:h,mipInt:u,CUBEUV_TEXEL_WIDTH:c,CUBEUV_TEXEL_HEIGHT:d,CUBEUV_MAX_MIP:p},m=df();return m.uniforms=f,m.fragmentNode=KE({...f,latitudinal:a.equal(1)}),m}function uy(o){const t=df();return t.fragmentNode=nu(o,cf),t}function cy(o){const t=df();return t.fragmentNode=gt(o,IM(cf),0),t}let rC=0;class ip{constructor(t="",e=[]){this.name=t,this.bindings=e,this.id=rC++}}const dy=new WeakMap,oC=new Map([[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),aC=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),Rl=o=>(o=Number(o),o+(o%1?"":".0"));class BM{constructor(t,e,i){this.object=t,this.material=t&&t.material||null,this.geometry=t&&t.geometry||null,this.renderer=e,this.parser=i,this.scene=null,this.camera=null,this.nodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.updateAfterNodes=[],this.hashNodes={},this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:""},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:{},fragment:{},compute:{}},this.bindingsIndexes={},this.bindGroups=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.flow={code:""},this.chaining=[],this.stack=yc(),this.stacks=[],this.tab="	",this.instanceBindGroups=!0,this.currentFunctionNode=null,this.context={keywords:new bN,material:this.material},this.cache=new uc,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null}getBingGroupsCache(){let t=dy.get(this.renderer);return t===void 0&&(t=new hs,dy.set(this.renderer,t)),t}createRenderTarget(t,e,i){return new be(t,e,i)}createCubeRenderTarget(t,e){return new $E(t,e)}createPMREMGenerator(){return new iC(this.renderer)}includes(t){return this.nodes.includes(t)}_getBindGroup(t,e){const i=this.getBingGroupsCache(),s=[];let n=!0;for(const a of e)s.push(a),n=n&&a.groupNode.shared!==!0;let r;return n?(r=i.get(s),r===void 0&&(r=new ip(t,s),i.set(s,r))):r=new ip(t,s),r}getBindGroupArray(t,e){const i=this.bindings[e];let s=i[t];return s===void 0&&(this.bindingsIndexes[t]===void 0&&(this.bindingsIndexes[t]={binding:0,group:Object.keys(this.bindingsIndexes).length}),i[t]=s=[]),s}getBindings(){let t=this.bindGroups;if(t===null){const e={},i=this.bindings;for(const s of Wg)for(const n in i[s]){const r=i[s][n];(e[n]||(e[n]=[])).push(...r)}t=[];for(const s in e){const n=e[s],r=this._getBindGroup(s,n);t.push(r)}this.bindGroups=t}return t}setHashNode(t,e){this.hashNodes[e]=t}addNode(t){this.nodes.includes(t)===!1&&(this.nodes.push(t),this.setHashNode(t,t.getHash(this)))}buildUpdateNodes(){for(const t of this.nodes){const e=t.getUpdateType(),i=t.getUpdateBeforeType(),s=t.getUpdateAfterType();e!==Y.NONE&&this.updateNodes.push(t.getSelf()),i!==Y.NONE&&this.updateBeforeNodes.push(t),s!==Y.NONE&&this.updateAfterNodes.push(t)}}get currentNode(){return this.chaining[this.chaining.length-1]}isFilteredTexture(t){return t.magFilter===Le||t.magFilter===md||t.magFilter===Lr||t.magFilter===as||t.minFilter===Le||t.minFilter===md||t.minFilter===Lr||t.minFilter===as}addChain(t){this.chaining.push(t)}removeChain(t){if(this.chaining.pop()!==t)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(t){return t}getNodeFromHash(t){return this.hashNodes[t]}addFlow(t,e){return this.flowNodes[t].push(e),e}setContext(t){this.context=t}getContext(){return this.context}getSharedContext(){return{...this.context},this.context}setCache(t){this.cache=t}getCache(){return this.cache}getCacheFromNode(t,e=!0){const i=this.getDataFromNode(t);return i.cache===void 0&&(i.cache=new uc(e?this.getCache():null)),i.cache}isAvailable(){return!1}getVertexIndex(){console.warn("Abstract function.")}getInstanceIndex(){console.warn("Abstract function.")}getDrawIndex(){console.warn("Abstract function.")}getFrontFacing(){console.warn("Abstract function.")}getFragCoord(){console.warn("Abstract function.")}isFlipY(){return!1}generateTexture(){console.warn("Abstract function.")}generateTextureLod(){console.warn("Abstract function.")}generateConst(t,e=null){if(e===null&&(t==="float"||t==="int"||t==="uint"?e=0:t==="bool"?e=!1:t==="color"?e=new nt:t==="vec2"?e=new q:t==="vec3"?e=new E:t==="vec4"&&(e=new _t)),t==="float")return Rl(e);if(t==="int")return`${Math.round(e)}`;if(t==="uint")return e>=0?`${Math.round(e)}u`:"0u";if(t==="bool")return e?"true":"false";if(t==="color")return`${this.getType("vec3")}( ${Rl(e.r)}, ${Rl(e.g)}, ${Rl(e.b)} )`;const i=this.getTypeLength(t),s=this.getComponentType(t),n=r=>this.generateConst(s,r);if(i===2)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)} )`;if(i===3)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)}, ${n(e.z)} )`;if(i===4)return`${this.getType(t)}( ${n(e.x)}, ${n(e.y)}, ${n(e.z)}, ${n(e.w)} )`;if(i>4&&e&&(e.isMatrix3||e.isMatrix4))return`${this.getType(t)}( ${e.elements.map(n).join(", ")} )`;if(i>4)return`${this.getType(t)}()`;throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`)}getType(t){return t==="color"?"vec3":t}hasGeometryAttribute(t){return this.geometry&&this.geometry.getAttribute(t)!==void 0}getAttribute(t,e){const i=this.attributes;for(const n of i)if(n.name===t)return n;const s=new Yg(t,e);return i.push(s),s}getPropertyName(t){return t.name}isVector(t){return/vec\d/.test(t)}isMatrix(t){return/mat\d/.test(t)}isReference(t){return t==="void"||t==="property"||t==="sampler"||t==="texture"||t==="cubeTexture"||t==="storageTexture"||t==="depthTexture"||t==="texture3D"}needsColorSpaceToLinear(){return!1}getComponentTypeFromTexture(t){const e=t.type;if(t.isDataTexture){if(e===Ne)return"int";if(e===re)return"uint"}return"float"}getElementType(t){return t==="mat2"?"vec2":t==="mat3"?"vec3":t==="mat4"?"vec4":this.getComponentType(t)}getComponentType(t){if(t=this.getVectorType(t),t==="float"||t==="bool"||t==="int"||t==="uint")return t;const e=/(b|i|u|)(vec|mat)([2-4])/.exec(t);return e===null?null:e[1]==="b"?"bool":e[1]==="i"?"int":e[1]==="u"?"uint":"float"}getVectorType(t){return t==="color"?"vec3":t==="texture"||t==="cubeTexture"||t==="storageTexture"||t==="texture3D"?"vec4":t}getTypeFromLength(t,e="float"){if(t===1)return e;const i=oC.get(t);return(e==="float"?"":e[0])+i}getTypeFromArray(t){return aC.get(t.constructor)}getTypeFromAttribute(t){let e=t;t.isInterleavedBufferAttribute&&(e=t.data);const i=e.array,s=t.itemSize,n=t.normalized;let r;return!(t instanceof q0)&&n!==!0&&(r=this.getTypeFromArray(i)),this.getTypeFromLength(s,r)}getTypeLength(t){const e=this.getVectorType(t),i=/vec([2-4])/.exec(e);return i!==null?Number(i[1]):e==="float"||e==="bool"||e==="int"||e==="uint"?1:/mat2/.test(t)===!0?4:/mat3/.test(t)===!0?9:/mat4/.test(t)===!0?16:0}getVectorFromMatrix(t){return t.replace("mat","vec")}changeComponentType(t,e){return this.getTypeFromLength(this.getTypeLength(t),e)}getIntegerType(t){const e=this.getComponentType(t);return e==="int"||e==="uint"?t:this.changeComponentType(t,"int")}addStack(){return this.stack=yc(this.stack),this.stacks.push(v_()||this.stack),bh(this.stack),this.stack}removeStack(){const t=this.stack;return this.stack=t.parent,bh(this.stacks.pop()),t}getDataFromNode(t,e=this.shaderStage,i=null){i=i===null?t.isGlobal(this)?this.globalCache:this.cache:i;let s=i.getData(t);return s===void 0&&(s={},i.setData(t,s)),s[e]===void 0&&(s[e]={}),s[e]}getNodeProperties(t,e="any"){const i=this.getDataFromNode(t,e);return i.properties||(i.properties={outputNode:null})}getBufferAttributeFromNode(t,e){const i=this.getDataFromNode(t);let s=i.bufferAttribute;if(s===void 0){const n=this.uniforms.index++;s=new Yg("nodeAttribute"+n,e,t),this.bufferAttributes.push(s),i.bufferAttribute=s}return s}getStructTypeFromNode(t,e=this.shaderStage){const i=this.getDataFromNode(t,e);if(i.structType===void 0){const s=this.structs.index++;t.name=`StructType${s}`,this.structs[e].push(t),i.structType=t}return t}getUniformFromNode(t,e,i=this.shaderStage,s=null){const n=this.getDataFromNode(t,i,this.globalCache);let r=n.uniform;if(r===void 0){const a=this.uniforms.index++;r=new MN(s||"nodeUniform"+a,e,t),this.uniforms[i].push(r),n.uniform=r}return r}getVarFromNode(t,e=null,i=t.getNodeType(this),s=this.shaderStage){const n=this.getDataFromNode(t,s);let r=n.variable;if(r===void 0){const a=this.vars[s]||(this.vars[s]=[]);e===null&&(e="nodeVar"+a.length),r=new R_(e,i),a.push(r),n.variable=r}return r}getVaryingFromNode(t,e=null,i=t.getNodeType(this)){const s=this.getDataFromNode(t,"any");let n=s.varying;if(n===void 0){const r=this.varyings,a=r.length;e===null&&(e="nodeVarying"+a),n=new vN(e,i),r.push(n),s.varying=n}return n}getCodeFromNode(t,e,i=this.shaderStage){const s=this.getDataFromNode(t);let n=s.code;if(n===void 0){const r=this.codes[i]||(this.codes[i]=[]),a=r.length;n=new TN("nodeCode"+a,e),r.push(n),s.code=n}return n}addLineFlowCode(t){return t===""?this:(t=this.tab+t,/;\s*$/.test(t)||(t=t+`;
`),this.flow.code+=t,this)}addFlowCode(t){return this.flow.code+=t,this}addFlowTab(){return this.tab+="	",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(t){return this.flowsData.get(t)}flowNode(t){const e=t.getNodeType(this),i=this.flowChildNode(t,e);return this.flowsData.set(t,i),i}buildFunctionNode(t){const e=new L_,i=this.currentFunctionNode;return this.currentFunctionNode=e,e.code=this.buildFunctionCode(t),this.currentFunctionNode=i,e}flowShaderNode(t){const e=t.layout;let i;if(t.isArrayInput){i=[];for(const r of e.inputs)i.push(new Hd(r.type,r.name))}else{i={};for(const r of e.inputs)i[r.name]=new Hd(r.type,r.name)}t.layout=null;const s=t.call(i),n=this.flowStagesNode(s,e.type);return t.layout=e,n}flowStagesNode(t,e=null){const i=this.flow,s=this.vars,n=this.cache,r=this.buildStage,a=this.stack,l={code:""};this.flow=l,this.vars={},this.cache=new uc,this.stack=yc();for(const h of Gg)this.setBuildStage(h),l.result=t.build(this,e);return l.vars=this.getVars(this.shaderStage),this.flow=i,this.vars=s,this.cache=n,this.stack=a,this.setBuildStage(r),l}getFunctionOperator(){return null}flowChildNode(t,e=null){const i=this.flow,s={code:""};return this.flow=s,s.result=t.build(this,e),this.flow=i,s}flowNodeFromShaderStage(t,e,i=null,s=null){const n=this.shaderStage;this.setShaderStage(t);const r=this.flowChildNode(e,i);return s!==null&&(r.code+=`${this.tab+s} = ${r.result};
`),this.flowCode[t]=this.flowCode[t]+r.code,this.setShaderStage(n),r}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){console.warn("Abstract function.")}getVaryings(){console.warn("Abstract function.")}getVar(t,e){return`${this.getType(t)} ${e}`}getVars(t){let e="";const i=this.vars[t];if(i!==void 0)for(const s of i)e+=`${this.getVar(s.type,s.name)}; `;return e}getUniforms(){console.warn("Abstract function.")}getCodes(t){const e=this.codes[t];let i="";if(e!==void 0)for(const s of e)i+=s.code+`
`;return i}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(t){this.shaderStage=t}getShaderStage(){return this.shaderStage}setBuildStage(t){this.buildStage=t}getBuildStage(){return this.buildStage}buildCode(){console.warn("Abstract function.")}build(){const{object:t,material:e}=this;e!==null?Dt.fromMaterial(e).build(this):this.addFlow("compute",t);for(const i of Gg){this.setBuildStage(i),this.context.vertex&&this.context.vertex.isNode&&this.flowNodeFromShaderStage("vertex",this.context.vertex);for(const s of Wg){this.setShaderStage(s);const n=this.flowNodes[s];for(const r of n)i==="generate"?this.flowNode(r):r.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getNodeUniform(t,e){if(e==="float"||e==="int"||e==="uint")return new OE(t);if(e==="vec2"||e==="ivec2"||e==="uvec2")return new zE(t);if(e==="vec3"||e==="ivec3"||e==="uvec3")return new VE(t);if(e==="vec4"||e==="ivec4"||e==="uvec4")return new kE(t);if(e==="color")return new GE(t);if(e==="mat3")return new WE(t);if(e==="mat4")return new HE(t);throw new Error(`Uniform "${e}" not declared.`)}createNodeMaterial(t="NodeMaterial"){return hf(t)}format(t,e,i){if(e=this.getVectorType(e),i=this.getVectorType(i),e===i||i===null||this.isReference(i))return t;const s=this.getTypeLength(e),n=this.getTypeLength(i);return s===16&&n===9?`${this.getType(i)}(${t}[0].xyz, ${t}[1].xyz, ${t}[2].xyz)`:s===9&&n===4?`${this.getType(i)}(${t}[0].xy, ${t}[1].xy)`:s>4||n>4||n===0?t:s===n?`${this.getType(i)}( ${t} )`:s>n?this.format(`${t}.${"xyz".slice(0,n)}`,this.getTypeFromLength(n,this.getComponentType(e)),i):n===4&&s>1?`${this.getType(i)}( ${this.format(t,e,"vec3")}, 1.0 )`:s===2?`${this.getType(i)}( ${this.format(t,e,"vec2")}, 0.0 )`:(s===1&&n>1&&e!==this.getComponentType(i)&&(t=`${this.getType(this.getComponentType(i))}( ${t} )`),`${this.getType(i)}( ${t} )`)}getSignature(){return`// Three.js r${vn} - Node System
`}}class py{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.startTime=null,this.updateMap=new WeakMap,this.updateBeforeMap=new WeakMap,this.updateAfterMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}_getMaps(t,e){let i=t.get(e);return i===void 0&&(i={renderMap:new WeakMap,frameMap:new WeakMap},t.set(e,i)),i}updateBeforeNode(t){const e=t.getUpdateBeforeType(),i=t.updateReference(this);if(e===Y.FRAME){const{frameMap:s}=this._getMaps(this.updateBeforeMap,i);s.get(i)!==this.frameId&&t.updateBefore(this)!==!1&&s.set(i,this.frameId)}else if(e===Y.RENDER){const{renderMap:s}=this._getMaps(this.updateBeforeMap,i);s.get(i)!==this.renderId&&t.updateBefore(this)!==!1&&s.set(i,this.renderId)}else e===Y.OBJECT&&t.updateBefore(this)}updateAfterNode(t){const e=t.getUpdateAfterType(),i=t.updateReference(this);if(e===Y.FRAME){const{frameMap:s}=this._getMaps(this.updateAfterMap,i);s.get(i)!==this.frameId&&t.updateAfter(this)!==!1&&s.set(i,this.frameId)}else if(e===Y.RENDER){const{renderMap:s}=this._getMaps(this.updateAfterMap,i);s.get(i)!==this.renderId&&t.updateAfter(this)!==!1&&s.set(i,this.renderId)}else e===Y.OBJECT&&t.updateAfter(this)}updateNode(t){const e=t.getUpdateType(),i=t.updateReference(this);if(e===Y.FRAME){const{frameMap:s}=this._getMaps(this.updateMap,i);s.get(i)!==this.frameId&&t.update(this)!==!1&&s.set(i,this.frameId)}else if(e===Y.RENDER){const{renderMap:s}=this._getMaps(this.updateMap,i);s.get(i)!==this.renderId&&t.update(this)!==!1&&s.set(i,this.renderId)}else e===Y.OBJECT&&t.update(this)}update(){this.frameId++,this.lastTime===void 0&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}class pf{constructor(t,e,i=null,s="",n=!1){this.type=t,this.name=e,this.count=i,this.qualifier=s,this.isConst=n}}pf.isNodeFunctionInput=!0;class LM extends X{constructor(t){super(),this.types=t,this.isStructTypeNode=!0}getMemberTypes(){return this.types}}O("StructTypeNode",LM);class ff extends X{constructor(...t){super(),this.members=t,this.isOutputStructNode=!0}setup(t){super.setup(t);const e=this.members,i=[];for(let s=0;s<e.length;s++)i.push(e[s].getNodeType(t));this.nodeType=t.getStructTypeFromNode(new LM(i)).name}generate(t,e){const i=t.getOutputStructName(),s=this.members,n=i!==""?i+".":"";for(let r=0;r<s.length;r++){const a=s[r].build(t,e);t.addLineFlowCode(`${n}m${r} = ${a}`)}return i}}I(ff);O("OutputStructNode",ff);function lC(o,t){for(let e=0;e<o.length;e++)if(o[e].name===t)return e;return-1}class UM extends ff{constructor(t){super(),this.outputNodes=t,this.isMRTNode=!0}getNode(t){return this.outputNodes[t]}merge(t){const e={...this.outputNodes,...t.outputNodes};return hC(e)}setup(t){const e=this.outputNodes,i=t.renderer.getRenderTarget(),s=[],n=i.textures;for(const r in e){const a=lC(n,r);s[a]=G(e[r])}return this.members=s,super.setup(t)}}const hC=I(UM);O("MRTNode",UM);class DM extends X{constructor(t){super(),this.seedNode=t}setup(){const t=this.seedNode.toUint().mul(747796405).add(2891336453),e=t.shiftRight(t.shiftRight(28).add(4)).bitXor(t).mul(277803737);return e.shiftRight(22).bitXor(e).toFloat().mul(1/2**32)}}const uC=I(DM);N("hash",uC);O("HashNode",DM);const sp=(o,t)=>Xe(ut(4,o.mul(Ie(1,o))),t),cC=(o,t)=>o.lessThan(.5)?sp(o.mul(2),t).div(2):Ie(1,sp(ut(Ie(1,o),2),t).div(2)),dC=(o,t,e)=>Xe(Oi(Xe(o,t),Yt(Xe(o,t),Xe(Ie(1,o),e))),1/t),pC=(o,t)=>he(Yr.mul(t.mul(o).sub(1))).div(Yr.mul(t.mul(o).sub(1)));N("parabola",sp);N("gain",cC);N("pcurve",dC);N("sinc",pC);const Ii=z(([o])=>o.fract().sub(.5).abs()),OM=z(([o])=>P(Ii(o.z.add(Ii(o.y.mul(1)))),Ii(o.z.add(Ii(o.x.mul(1)))),Ii(o.y.add(Ii(o.x.mul(1)))))),fC=z(([o,t,e])=>{const i=P(o).toVar(),s=C(1.4).toVar(),n=C(0).toVar(),r=P(i).toVar();return Te({start:C(0),end:C(3),type:"float",condition:"<="},()=>{const a=P(OM(r.mul(2))).toVar();i.addAssign(a.add(e.mul(C(.1).mul(t)))),r.mulAssign(1.8),s.mulAssign(1.5),i.mulAssign(1.2);const l=C(Ii(i.z.add(Ii(i.x.add(Ii(i.y)))))).toVar();n.addAssign(l.div(s)),r.addAssign(.14)}),n});Ii.setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]});OM.setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]});fC.setLayout({name:"triNoise3D",type:"float",inputs:[{name:"p",type:"vec3"},{name:"spd",type:"float"},{name:"time",type:"float"}]});let Nc;class zM extends uf{constructor(t){Nc=Nc||tu("discard"),super(t,Nc)}}const mC=I(zM),gC=o=>mC(o).append();N("discard",gC);O("DiscardNode",zM);class VM extends X{constructor(t=[],...e){super(),this.functionNodes=t,this.parametersNodes=e,this._candidateFnCall=null,this.global=!0}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(t){const e=this.parametersNodes;let i=this._candidateFnCall;if(i===null){let s=null,n=-1;for(const r of this.functionNodes){const l=r.shaderNode.layout;if(l===null)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const h=l.inputs;if(e.length===h.length){let u=0;for(let c=0;c<e.length;c++){const d=e[c],p=h[c];d.getNodeType(t)===p.type?u++:u=0}u>n&&(s=r,n=u)}}this._candidateFnCall=i=s(...e)}return i}}I(VM);O("FunctionOverloadingNode",VM);class kM extends st{constructor(){super("vec2")}setup(){const t=P(Ft.z,0,Ft.x.negate()).normalize(),e=Ft.cross(t);return F(t.dot(Ct),e.dot(Ct)).mul(.495).add(.5)}}const GM=k(kM);O("MatcapUVNode",kM);class Ce extends Rn{constructor(t=Ce.LOCAL,e=1,i=0){super(i),this.scope=t,this.scale=e,this.updateType=Y.FRAME}update(t){const e=this.scope,i=this.scale;e===Ce.LOCAL?this.value+=t.deltaTime*i:e===Ce.DELTA?this.value=t.deltaTime*i:e===Ce.FRAME?this.value=t.frameId:this.value=t.time*i}serialize(t){super.serialize(t),t.scope=this.scope,t.scale=this.scale}deserialize(t){super.deserialize(t),this.scope=t.scope,this.scale=t.scale}}Ce.LOCAL="local";Ce.GLOBAL="global";Ce.DELTA="delta";Ce.FRAME="frame";const WM=(o,t=0)=>L(new Ce(Ce.LOCAL,o,t));k(Ce,Ce.FRAME).toUint();O("TimerNode",Ce);class jt extends X{constructor(t=jt.SINE,e=WM()){super(),this.method=t,this.timeNode=e}getNodeType(t){return this.timeNode.getNodeType(t)}setup(){const t=this.method,e=L(this.timeNode);let i=null;return t===jt.SINE?i=e.add(.75).mul(Math.PI*2).sin().mul(.5).add(.5):t===jt.SQUARE?i=e.fract().round():t===jt.TRIANGLE?i=e.add(.5).fract().mul(2).sub(1).abs():t===jt.SAWTOOTH&&(i=e.fract()),i}serialize(t){super.serialize(t),t.method=this.method}deserialize(t){super.deserialize(t),this.method=t.method}}jt.SINE="sine";jt.SQUARE="square";jt.TRIANGLE="triangle";jt.SAWTOOTH="sawtooth";I(jt,jt.SINE);I(jt,jt.SQUARE);I(jt,jt.TRIANGLE);I(jt,jt.SAWTOOTH);O("OscNode",jt);class Vi extends st{constructor(t,e){super(),this.scope=t,this.node=e}getNodeType(t){return this.node.getNodeType(t)}setup(){const{scope:t,node:e}=this;let i=null;return t===Vi.DIRECTION_TO_COLOR?i=e.mul(.5).add(.5):t===Vi.COLOR_TO_DIRECTION&&(i=e.mul(2).sub(1)),i}}Vi.DIRECTION_TO_COLOR="directionToColor";Vi.COLOR_TO_DIRECTION="colorToDirection";const HM=I(Vi,Vi.DIRECTION_TO_COLOR),yC=I(Vi,Vi.COLOR_TO_DIRECTION);N("directionToColor",HM);N("colorToDirection",yC);O("PackingNode",Vi);class mf extends X{constructor(t,e,i,s=C(0),n=C(1)){super(),this.node=t,this.inLowNode=e,this.inHighNode=i,this.outLowNode=s,this.outHighNode=n,this.doClamp=!0}setup(){const{node:t,inLowNode:e,inHighNode:i,outLowNode:s,outHighNode:n,doClamp:r}=this;let a=t.sub(e).div(i.sub(e));return r===!0&&(a=a.clamp()),a.mul(n.sub(s)).add(s)}}const xC=I(mf,null,null,{doClamp:!1}),_C=I(mf);N("remap",xC);N("remapClamp",_C);O("RemapNode",mf);class $M extends st{constructor(t,e,i=F(.5)){super("vec2"),this.uvNode=t,this.rotationNode=e,this.centerNode=i}setup(){const{uvNode:t,rotationNode:e,centerNode:i}=this;return t.sub(i).rotate(e).add(i)}}const MC=I($M);N("rotateUV",MC);O("RotateUVNode",$M);class qM extends st{constructor(t,e){super(),this.positionNode=t,this.rotationNode=e}getNodeType(t){return this.positionNode.getNodeType(t)}setup(t){const{rotationNode:e,positionNode:i}=this;if(this.getNodeType(t)==="vec2"){const n=e.cos(),r=e.sin();return va(n,r,r.negate(),n).mul(i)}else{const n=e,r=Or(G(1,0,0,0),G(0,$e(n.x),he(n.x).negate(),0),G(0,he(n.x),$e(n.x),0),G(0,0,0,1)),a=Or(G($e(n.y),0,he(n.y),0),G(0,1,0,0),G(he(n.y).negate(),0,$e(n.y),0),G(0,0,0,1)),l=Or(G($e(n.z),he(n.z).negate(),0,0),G(he(n.z),$e(n.z),0,0),G(0,0,1,0),G(0,0,0,1));return r.mul(a).mul(l).mul(G(i,1)).xyz}}}const vC=I(qM);N("rotate",vC);O("RotateNode",qM);class jM extends X{constructor(t,e=Nt(),i=C(0)){super("vec2"),this.countNode=t,this.uvNode=e,this.frameNode=i}setup(){const{frameNode:t,uvNode:e,countNode:i}=this,{width:s,height:n}=i,r=t.mod(s.mul(n)).floor(),a=r.mod(s),l=n.sub(r.add(1).div(s).ceil()),h=i.reciprocal(),u=F(a,l);return e.add(u).mul(h)}}I(jM);O("SpriteSheetUVNode",jM);class XM extends ao{constructor(t,e){super(t,e),this.isStorageArrayElementNode=!0}set storageBufferNode(t){this.node=t}get storageBufferNode(){return this.node}setup(t){return t.isAvailable("storageBuffer")===!1&&!this.node.instanceIndex&&this.node.bufferObject===!0&&t.setupPBO(this.node),super.setup(t)}generate(t,e){let i;const s=t.context.assign;if(t.isAvailable("storageBuffer")===!1){const{node:n}=this;!n.instanceIndex&&this.node.bufferObject===!0&&s!==!0?i=t.generatePBO(this):i=n.build(t)}else i=super.generate(t);if(s!==!0){const n=this.getNodeType(t);i=t.format(i,n,e)}return i}}const YM=I(XM);N("storageElement",YM);O("StorageArrayElementNode",XM);class ZM extends X{constructor(t,e=null,i=null,s=C(1),n=Ht,r=li){super("vec4"),this.textureXNode=t,this.textureYNode=e,this.textureZNode=i,this.scaleNode=s,this.positionNode=n,this.normalNode=r}setup(){const{textureXNode:t,textureYNode:e,textureZNode:i,scaleNode:s,positionNode:n,normalNode:r}=this;let a=r.abs().normalize();a=a.div(a.dot(P(1)));const l=n.yz.mul(s),h=n.zx.mul(s),u=n.xy.mul(s),c=t.value,d=e!==null?e.value:c,p=i!==null?i.value:c,f=gt(c,l).mul(a.x),m=gt(d,h).mul(a.y),g=gt(p,u).mul(a.z);return Yt(f,m,g)}}const TC=I(ZM),bC=(...o)=>TC(...o);N("triplanarTexture",bC);O("TriplanarTexturesNode",ZM);new Is;new E;new E;new E;new Bt;new E(0,0,-1);new _t;new E;new E;new _t;new q;new be;F(Zr.x.oneMinus(),Zr.y);const Rc=new Hp(-1,1,1,-1,0,1);class SC extends An{constructor(t=!1){super();const e=t===!1?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new ls([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new ls(e,2))}}const wC=new SC;class gs extends so{constructor(t=null){super(wC,t),this.camera=Rc}renderAsync(t){return t.renderAsync(this,Rc)}render(t){t.render(this,Rc)}}const AC=new q;class QM extends zi{constructor(t,e=null,i=null,s={type:wi}){const n=new be(e,i,s);super(n.texture,Nt()),this.node=t,this.width=e,this.height=i,this.renderTarget=n,this.textureNeedsUpdate=!0,this.autoUpdate=!0,this.updateMap=new WeakMap,this._rttNode=null,this._quadMesh=new gs(new Dt),this.updateBeforeType=Y.RENDER}get autoSize(){return this.width===null}setup(t){return this._rttNode=this.node.context(t.getSharedContext()),this._quadMesh.material.needsUpdate=!0,super.setup(t)}setSize(t,e){this.width=t,this.height=e;const i=t*this.pixelRatio,s=e*this.pixelRatio;this.renderTarget.setSize(i,s),this.textureNeedsUpdate=!0}setPixelRatio(t){this.pixelRatio=t,this.setSize(this.width,this.height)}updateBefore({renderer:t}){if(this.textureNeedsUpdate===!1&&this.autoUpdate===!1)return;if(this.textureNeedsUpdate=!1,this.autoSize===!0){this.pixelRatio=t.getPixelRatio();const i=t.getSize(AC);this.setSize(i.width,i.height)}this._quadMesh.material.fragmentNode=this._rttNode;const e=t.getRenderTarget();t.setRenderTarget(this.renderTarget),this._quadMesh.render(t),t.setRenderTarget(e)}clone(){const t=new zi(this.value,this.uvNode,this.levelNode);return t.sampler=this.sampler,t.referenceNode=this,t}}const NC=(o,...t)=>L(new QM(L(o),...t));N("toTexture",(o,...t)=>o.isTextureNode?o:NC(o,...t));O("RTTNode",QM);const RC=o=>o.mul(dM.w).xyz,EC=$t(RC(us.cross(pM)),"v_bitangentView").normalize().toVar("bitangentView"),Fr=de(pM,EC,us);Ft.mul(Fr);const CC=(()=>{let o=Vr.cross(Ft);return o=o.cross(Vr).normalize(),o=K(o,Ct,cn.mul(ns.oneMinus()).oneMinus().pow2().pow2()).normalize(),o})();class PC extends Qp{constructor(t=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=t}getAttributeName(){const t=this.index;return"color"+(t>0?t:"")}generate(t){const e=this.getAttributeName(t),i=t.hasGeometryAttribute(e);let s;return i===!0?s=super.generate(t):s=t.generateConst(this.nodeType,new _t(1,1,1,1)),s}serialize(t){super.serialize(t),t.index=this.index}deserialize(t){super.deserialize(t),this.index=t.index}}O("VertexColorNode",PC);class JM extends lo{constructor(t,e,i=null){super(t,e,i),this.renderer=i}updateReference(t){return this.reference=this.renderer!==null?this.renderer:t.renderer,this.reference}}const FC=(o,t,e)=>L(new JM(o,t,e));O("RendererReferenceNode",JM);const ru=1/6,KM=o=>ut(ru,ut(o,ut(o,o.negate().add(3)).sub(3)).add(1)),np=o=>ut(ru,ut(o,ut(o,ut(3,o).sub(6))).add(4)),tv=o=>ut(ru,ut(o,ut(o,ut(-3,o).add(3)).add(3)).add(1)),rp=o=>ut(ru,Xe(o,3)),fy=o=>KM(o).add(np(o)),my=o=>tv(o).add(rp(o)),gy=o=>Yt(-1,np(o).div(KM(o).add(np(o)))),yy=o=>Yt(1,rp(o).div(tv(o).add(rp(o)))),xy=(o,t,e)=>{const i=o.uvNode,s=ut(i,t.zw).add(.5),n=ba(s),r=En(s),a=fy(r.x),l=my(r.x),h=gy(r.x),u=yy(r.x),c=gy(r.y),d=yy(r.y),p=F(n.x.add(h),n.y.add(c)).sub(.5).mul(t.xy),f=F(n.x.add(u),n.y.add(c)).sub(.5).mul(t.xy),m=F(n.x.add(h),n.y.add(d)).sub(.5).mul(t.xy),g=F(n.x.add(u),n.y.add(d)).sub(.5).mul(t.xy),y=fy(r.y).mul(Yt(a.mul(o.uv(p).level(e)),l.mul(o.uv(f).level(e)))),x=my(r.y).mul(Yt(a.mul(o.uv(m).level(e)),l.mul(o.uv(g).level(e))));return y.add(x)},IC=(o,t)=>{const e=F(o.size(xt(t))),i=F(o.size(xt(t.add(1)))),s=Oi(1,e),n=Oi(1,i),r=xy(o,G(s,e),ba(t)),a=xy(o,G(n,i),W_(t));return En(t).mix(r,a)};class ev extends st{constructor(t,e=C(3)){super("vec4"),this.textureNode=t,this.blurNode=e}setup(){return IC(this.textureNode,this.blurNode)}}const BC=I(ev);N("bicubic",BC);O("TextureBicubicNode",ev);class iv extends X{constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}k(iv);O("PointUVNode",iv);class Ai extends X{constructor(t=Ai.BACKGROUND_BLURRINESS,e=null){super(),this.scope=t,this.scene=e}setup(t){const e=this.scope,i=this.scene!==null?this.scene:t.scene;let s;return e===Ai.BACKGROUND_BLURRINESS?s=Wt("backgroundBlurriness","float",i):e===Ai.BACKGROUND_INTENSITY?s=Wt("backgroundIntensity","float",i):console.error("THREE.SceneNode: Unknown scope:",e),s}}Ai.BACKGROUND_BLURRINESS="backgroundBlurriness";Ai.BACKGROUND_INTENSITY="backgroundIntensity";const LC=k(Ai,Ai.BACKGROUND_BLURRINESS),_y=k(Ai,Ai.BACKGROUND_INTENSITY);O("SceneNode",Ai);const Ir={PointList:"point-list",LineList:"line-list",LineStrip:"line-strip",TriangleList:"triangle-list",TriangleStrip:"triangle-strip"},se={Never:"never",Less:"less",Equal:"equal",LessEqual:"less-equal",Greater:"greater",NotEqual:"not-equal",GreaterEqual:"greater-equal",Always:"always"},ne={Store:"store"},Gt={Load:"load",Clear:"clear"},Ec={CCW:"ccw"},Cc={None:"none",Front:"front",Back:"back"},Qr={Uint16:"uint16",Uint32:"uint32"},b={R8Unorm:"r8unorm",R8Snorm:"r8snorm",R8Uint:"r8uint",R8Sint:"r8sint",R16Uint:"r16uint",R16Sint:"r16sint",R16Float:"r16float",RG8Unorm:"rg8unorm",RG8Snorm:"rg8snorm",RG8Uint:"rg8uint",RG8Sint:"rg8sint",R32Uint:"r32uint",R32Sint:"r32sint",R32Float:"r32float",RG16Uint:"rg16uint",RG16Sint:"rg16sint",RG16Float:"rg16float",RGBA8Unorm:"rgba8unorm",RGBA8UnormSRGB:"rgba8unorm-srgb",RGBA8Snorm:"rgba8snorm",RGBA8Uint:"rgba8uint",RGBA8Sint:"rgba8sint",BGRA8Unorm:"bgra8unorm",BGRA8UnormSRGB:"bgra8unorm-srgb",RGB9E5UFloat:"rgb9e5ufloat",RGB10A2Unorm:"rgb10a2unorm",RG32Uint:"rg32uint",RG32Sint:"rg32sint",RG32Float:"rg32float",RGBA16Uint:"rgba16uint",RGBA16Sint:"rgba16sint",RGBA16Float:"rgba16float",RGBA32Uint:"rgba32uint",RGBA32Sint:"rgba32sint",RGBA32Float:"rgba32float",Depth16Unorm:"depth16unorm",Depth24Plus:"depth24plus",Depth24PlusStencil8:"depth24plus-stencil8",Depth32Float:"depth32float",Depth32FloatStencil8:"depth32float-stencil8",BC1RGBAUnorm:"bc1-rgba-unorm",BC1RGBAUnormSRGB:"bc1-rgba-unorm-srgb",BC2RGBAUnorm:"bc2-rgba-unorm",BC2RGBAUnormSRGB:"bc2-rgba-unorm-srgb",BC3RGBAUnorm:"bc3-rgba-unorm",BC3RGBAUnormSRGB:"bc3-rgba-unorm-srgb",BC4RUnorm:"bc4-r-unorm",BC5RGUnorm:"bc5-rg-unorm",BC5RGSnorm:"bc5-rg-snorm",BC6HRGBUFloat:"bc6h-rgb-ufloat",BC6HRGBFloat:"bc6h-rgb-float",BC7RGBAUnorm:"bc7-rgba-unorm",BC7RGBAUnormSRGB:"bc7-rgba-srgb",ETC2RGB8Unorm:"etc2-rgb8unorm",ETC2RGB8UnormSRGB:"etc2-rgb8unorm-srgb",ETC2RGB8A1Unorm:"etc2-rgb8a1unorm",ETC2RGB8A1UnormSRGB:"etc2-rgb8a1unorm-srgb",ETC2RGBA8Unorm:"etc2-rgba8unorm",ETC2RGBA8UnormSRGB:"etc2-rgba8unorm-srgb",EACR11Unorm:"eac-r11unorm",EACR11Snorm:"eac-r11snorm",EACRG11Unorm:"eac-rg11unorm",EACRG11Snorm:"eac-rg11snorm",ASTC4x4Unorm:"astc-4x4-unorm",ASTC4x4UnormSRGB:"astc-4x4-unorm-srgb",ASTC5x4Unorm:"astc-5x4-unorm",ASTC5x4UnormSRGB:"astc-5x4-unorm-srgb",ASTC5x5Unorm:"astc-5x5-unorm",ASTC5x5UnormSRGB:"astc-5x5-unorm-srgb",ASTC6x5Unorm:"astc-6x5-unorm",ASTC6x5UnormSRGB:"astc-6x5-unorm-srgb",ASTC6x6Unorm:"astc-6x6-unorm",ASTC6x6UnormSRGB:"astc-6x6-unorm-srgb",ASTC8x5Unorm:"astc-8x5-unorm",ASTC8x5UnormSRGB:"astc-8x5-unorm-srgb",ASTC8x6Unorm:"astc-8x6-unorm",ASTC8x6UnormSRGB:"astc-8x6-unorm-srgb",ASTC8x8Unorm:"astc-8x8-unorm",ASTC8x8UnormSRGB:"astc-8x8-unorm-srgb",ASTC10x5Unorm:"astc-10x5-unorm",ASTC10x5UnormSRGB:"astc-10x5-unorm-srgb",ASTC10x6Unorm:"astc-10x6-unorm",ASTC10x6UnormSRGB:"astc-10x6-unorm-srgb",ASTC10x8Unorm:"astc-10x8-unorm",ASTC10x8UnormSRGB:"astc-10x8-unorm-srgb",ASTC10x10Unorm:"astc-10x10-unorm",ASTC10x10UnormSRGB:"astc-10x10-unorm-srgb",ASTC12x10Unorm:"astc-12x10-unorm",ASTC12x10UnormSRGB:"astc-12x10-unorm-srgb",ASTC12x12Unorm:"astc-12x12-unorm",ASTC12x12UnormSRGB:"astc-12x12-unorm-srgb"},Pc={ClampToEdge:"clamp-to-edge",Repeat:"repeat",MirrorRepeat:"mirror-repeat"},Fh={Linear:"linear",Nearest:"nearest"},Q={Zero:"zero",One:"one",Src:"src",OneMinusSrc:"one-minus-src",SrcAlpha:"src-alpha",OneMinusSrcAlpha:"one-minus-src-alpha",Dst:"dst",OneMinusDstColor:"one-minus-dst",DstAlpha:"dst-alpha",OneMinusDstAlpha:"one-minus-dst-alpha",SrcAlphaSaturated:"src-alpha-saturated",Constant:"constant",OneMinusConstant:"one-minus-constant"},sn={Add:"add",Subtract:"subtract",ReverseSubtract:"reverse-subtract",Min:"min",Max:"max"},My={None:0,All:15},Cs={Keep:"keep",Zero:"zero",Replace:"replace",Invert:"invert",IncrementClamp:"increment-clamp",DecrementClamp:"decrement-clamp",IncrementWrap:"increment-wrap",DecrementWrap:"decrement-wrap"},ha={Storage:"storage",ReadOnlyStorage:"read-only-storage"},Qo={WriteOnly:"write-only",ReadOnly:"read-only"},El={UnfilterableFloat:"unfilterable-float",Depth:"depth",SInt:"sint",UInt:"uint"},vy={TwoD:"2d",ThreeD:"3d"},ri={TwoD:"2d",TwoDArray:"2d-array",Cube:"cube",ThreeD:"3d"},UC={All:"all"},Cl={Vertex:"vertex",Instance:"instance"},ko={DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable",ClipDistances:"clip-distances",DualSourceBlending:"dual-source-blending"};class DC extends eu{constructor(t,e,i=0){super(t,e,i),this.isStorageBufferNode=!0,this.access=ha.Storage,this.bufferObject=!1,this.bufferCount=i,this._attribute=null,this._varying=null,this.global=!0,t.isStorageBufferAttribute!==!0&&t.isStorageInstancedBufferAttribute!==!0&&(t.isInstancedBufferAttribute?t.isStorageInstancedBufferAttribute=!0:t.isStorageBufferAttribute=!0)}getHash(t){if(this.bufferCount===0){let e=t.globalCache.getData(this.value);return e===void 0&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getInputType(){return"storageBuffer"}element(t){return YM(this,t)}setBufferObject(t){return this.bufferObject=t,this}setAccess(t){return this.access=t,this}toReadOnly(){return this.setAccess(ha.ReadOnlyStorage)}generate(t){if(t.isAvailable("storageBuffer"))return super.generate(t);const e=this.getNodeType(t);this._attribute===null&&(this._attribute=su(this.value),this._varying=$t(this._attribute));const i=this._varying.build(t,e);return t.registerTransform(i,this._attribute),i}}O("StorageBufferNode",DC);class sv extends zi{constructor(t,e,i=null){super(t,e),this.storeNode=i,this.isStorageTextureNode=!0,this.access=Qo.WriteOnly}getInputType(){return"storageTexture"}setup(t){super.setup(t);const e=t.getNodeProperties(this);e.storeNode=this.storeNode}setAccess(t){return this.access=t,this}generate(t,e){let i;return this.storeNode!==null?i=this.generateStore(t):i=super.generate(t,e),i}toReadOnly(){return this.setAccess(Qo.ReadOnly)}toWriteOnly(){return this.setAccess(Qo.WriteOnly)}generateStore(t){const e=t.getNodeProperties(this),{uvNode:i,storeNode:s}=e,n=super.generate(t,"property"),r=i.build(t,"uvec2"),a=s.build(t,"vec4"),l=t.generateTextureStore(t,n,r,a);t.addLineFlowCode(l)}}I(sv);O("StorageTextureNode",sv);const OC=z(({texture:o,uv:t})=>{const i=P().temp();return it(t.x.lessThan(1e-4),()=>{i.assign(P(1,0,0))}).elseif(t.y.lessThan(1e-4),()=>{i.assign(P(0,1,0))}).elseif(t.z.lessThan(1e-4),()=>{i.assign(P(0,0,1))}).elseif(t.x.greaterThan(1-1e-4),()=>{i.assign(P(-1,0,0))}).elseif(t.y.greaterThan(1-1e-4),()=>{i.assign(P(0,-1,0))}).elseif(t.z.greaterThan(1-1e-4),()=>{i.assign(P(0,0,-1))}).else(()=>{const n=o.uv(t.add(P(-.01,0,0))).r.sub(o.uv(t.add(P(.01,0,0))).r),r=o.uv(t.add(P(0,-.01,0))).r.sub(o.uv(t.add(P(0,.01,0))).r),a=o.uv(t.add(P(0,0,-.01))).r.sub(o.uv(t.add(P(0,0,.01))).r);i.assign(P(n,r,a))}),i.normalize()});class nv extends zi{constructor(t,e=null,i=null){super(t,e,i),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return P(.5,.5,.5)}setUpdateMatrix(){}setupUV(t,e){return e}generateUV(t,e){return e.build(t,"vec3")}normal(t){return OC({texture:this,uv:t})}}const zC=I(nv);O("Texture3DNode",nv);class VC extends lo{constructor(t,e,i=null){super(t,e,i),this.userData=i}update(t){this.reference=this.userData!==null?this.userData:t.object.userData,super.update(t)}}O("UserDataNode",VC);const kC=z(({base:o,blend:t})=>{const e=i=>t[i].lessThan(O_).cond(t[i],o[i].oneMinus().div(t[i]).oneMinus().max(0));return P(e("x"),e("y"),e("z"))}).setLayout({name:"burnColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),GC=z(({base:o,blend:t})=>{const e=i=>t[i].equal(1).cond(t[i],o[i].div(t[i].oneMinus()).max(0));return P(e("x"),e("y"),e("z"))}).setLayout({name:"dodgeColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),WC=z(({base:o,blend:t})=>{const e=i=>o[i].oneMinus().mul(t[i].oneMinus()).oneMinus();return P(e("x"),e("y"),e("z"))}).setLayout({name:"screenColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),HC=z(({base:o,blend:t})=>{const e=i=>o[i].lessThan(.5).cond(o[i].mul(t[i],2),o[i].oneMinus().mul(t[i].oneMinus()).oneMinus());return P(e("x"),e("y"),e("z"))}).setLayout({name:"overlayColor",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]});class Kt extends st{constructor(t,e,i){super(),this.blendMode=t,this.baseNode=e,this.blendNode=i}setup(){const{blendMode:t,baseNode:e,blendNode:i}=this,s={base:e,blend:i};let n=null;return t===Kt.BURN?n=kC(s):t===Kt.DODGE?n=GC(s):t===Kt.SCREEN?n=WC(s):t===Kt.OVERLAY&&(n=HC(s)),n}}Kt.BURN="burn";Kt.DODGE="dodge";Kt.SCREEN="screen";Kt.OVERLAY="overlay";const $C=I(Kt,Kt.BURN),qC=I(Kt,Kt.DODGE),jC=I(Kt,Kt.OVERLAY),XC=I(Kt,Kt.SCREEN);N("burn",$C);N("dodge",qC);N("overlay",jC);N("screen",XC);O("BlendModeNode",Kt);const YC=z(({textureNode:o,bumpScale:t})=>{const e=s=>o.cache().context({getUV:n=>s(n.uvNode||Nt()),forceUVContext:!0}),i=C(e(s=>s));return F(C(e(s=>s.add(s.dFdx()))).sub(i),C(e(s=>s.add(s.dFdy()))).sub(i)).mul(t)}),ZC=z(o=>{const{surf_pos:t,surf_norm:e,dHdxy:i}=o,s=t.dFdx().normalize(),n=t.dFdy().normalize(),r=e,a=n.cross(r),l=r.cross(s),h=s.dot(a).mul(Ph),u=h.sign().mul(i.x.mul(a).add(i.y.mul(l)));return h.abs().mul(e).sub(u).normalize()});class rv extends st{constructor(t,e=null){super("vec3"),this.textureNode=t,this.scaleNode=e}setup(){const t=this.scaleNode!==null?this.scaleNode:1,e=YC({textureNode:this.textureNode,bumpScale:t});return ZC({surf_pos:ve,surf_norm:us,dHdxy:e})}}const QC=I(rv);N("bumpMap",QC);O("BumpMapNode",rv);const JC=z(({color:o,adjustment:t})=>t.mix(Ee(o.rgb),o.rgb)),KC=z(({color:o,adjustment:t})=>{const e=Yt(o.r,o.g,o.b).div(3),i=o.r.max(o.g.max(o.b)),s=i.sub(e).mul(t).mul(-3);return K(o.rgb,i,s)}),tP=z(({color:o,adjustment:t})=>{const e=P(.57735,.57735,.57735),i=t.cos();return P(o.rgb.mul(i).add(e.cross(o.rgb).mul(t.sin()).add(e.mul(oe(e,o.rgb).mul(i.oneMinus())))))});class Be extends st{constructor(t,e,i=C(1)){super("vec3"),this.method=t,this.colorNode=e,this.adjustmentNode=i}setup(){const{method:t,colorNode:e,adjustmentNode:i}=this,s={color:e,adjustment:i};let n=null;return t===Be.SATURATION?n=JC(s):t===Be.VIBRANCE?n=KC(s):t===Be.HUE?n=tP(s):console.error(`${this.type}: Method "${this.method}" not supported!`),n}}Be.SATURATION="saturation";Be.VIBRANCE="vibrance";Be.HUE="hue";const eP=I(Be,Be.SATURATION),iP=I(Be,Be.VIBRANCE),sP=I(Be,Be.HUE),nP=new E,Ee=(o,t=P(...ni.getLuminanceCoefficients(nP)))=>oe(o,t),ov=(o,t)=>K(P(0),o,Ee(o).sub(t).max(0));N("saturation",eP);N("vibrance",iP);N("hue",sP);N("threshold",ov);O("ColorAdjustmentNode",Be);const rP=z(o=>{const{eye_pos:t,surf_norm:e,mapN:i,uv:s}=o,n=t.dFdx(),r=t.dFdy(),a=s.dFdx(),l=s.dFdy(),h=e,u=r.cross(h),c=h.cross(n),d=u.mul(a.x).add(c.mul(l.x)),p=u.mul(a.y).add(c.mul(l.y)),f=d.dot(d).max(p.dot(p)),m=Ph.mul(f.inverseSqrt());return Yt(d.mul(i.x,m),p.mul(i.y,m),h.mul(i.z)).normalize()});class av extends st{constructor(t,e=null){super("vec3"),this.node=t,this.scaleNode=e,this.normalMapType=Vs}setup(t){const{normalMapType:e,scaleNode:i}=this;let s=this.node.mul(2).sub(1);i!==null&&(s=P(s.xy.mul(i),s.z));let n=null;return e===Rw?n=rf.mul(s).normalize():e===Vs&&(t.hasGeometryAttribute("tangent")===!0?n=Fr.mul(s).normalize():n=rP({eye_pos:ve,surf_norm:us,mapN:s,uv:Nt()})),n}}const lv=I(av);N("normalMap",lv);O("NormalMapNode",av);class hv extends st{constructor(t,e){super(),this.sourceNode=t,this.stepsNode=e}setup(){const{sourceNode:t,stepsNode:e}=this;return t.mul(e).floor().div(e)}}const oP=I(hv);N("posterize",oP);O("PosterizeNode",hv);const aP=z(({color:o,exposure:t})=>o.mul(t).clamp()),lP=z(({color:o,exposure:t})=>(o=o.mul(t),o.div(o.add(1)).clamp())),hP=z(({color:o,exposure:t})=>{o=o.mul(t),o=o.sub(.004).max(0);const e=o.mul(o.mul(6.2).add(.5)),i=o.mul(o.mul(6.2).add(1.7)).add(.06);return e.div(i).pow(2.2)}),uP=z(({color:o})=>{const t=o.mul(o.add(.0245786)).sub(90537e-9),e=o.mul(o.add(.432951).mul(.983729)).add(.238081);return t.div(e)}),cP=z(({color:o,exposure:t})=>{const e=de(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),i=de(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return o=o.mul(t).div(.6),o=e.mul(o),o=uP({color:o}),o=i.mul(o),o.clamp()}),dP=de(P(1.6605,-.1246,-.0182),P(-.5876,1.1329,-.1006),P(-.0728,-.0083,1.1187)),pP=de(P(.6274,.0691,.0164),P(.3293,.9195,.088),P(.0433,.0113,.8956)),fP=z(([o])=>{const t=P(o).toVar(),e=P(t.mul(t)).toVar(),i=P(e.mul(e)).toVar();return C(15.5).mul(i.mul(e)).sub(ut(40.14,i.mul(t))).add(ut(31.96,i).sub(ut(6.868,e.mul(t))).add(ut(.4298,e).add(ut(.1191,t).sub(.00232))))}),mP=z(({color:o,exposure:t})=>{const e=P(o).toVar(),i=de(P(.856627153315983,.137318972929847,.11189821299995),P(.0951212405381588,.761241990602591,.0767994186031903),P(.0482516061458583,.101439036467562,.811302368396859)),s=de(P(1.1271005818144368,-.1413297634984383,-.14132976349843826),P(-.11060664309660323,1.157823702216272,-.11060664309660294),P(-.016493938717834573,-.016493938717834257,1.2519364065950405)),n=C(-12.47393),r=C(4.026069);return e.mulAssign(t),e.assign(pP.mul(e)),e.assign(i.mul(e)),e.assign(Et(e,1e-10)),e.assign(Jh(e)),e.assign(e.sub(n).div(r.sub(n))),e.assign(Me(e,0,1)),e.assign(fP(e)),e.assign(s.mul(e)),e.assign(Xe(Et(P(0),e),P(2.2))),e.assign(dP.mul(e)),e.assign(Me(e,0,1)),e}),gP=z(({color:o,exposure:t})=>{const e=C(.76),i=C(.15);o=o.mul(t);const s=Ui(o.r,Ui(o.g,o.b)),n=oi(s.lessThan(.08),s.sub(ut(6.25,s.mul(s))),.04);o.subAssign(n);const r=Et(o.r,Et(o.g,o.b));it(r.lessThan(e),()=>o);const a=Ie(1,e),l=Ie(1,a.mul(a).div(r.add(a.sub(e))));o.mulAssign(l.div(r));const h=Ie(1,Oi(1,i.mul(r.sub(l)).add(1)));return K(o,P(l),h)}).setLayout({name:"NeutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),yP={[dw]:aP,[pw]:lP,[fw]:hP,[mw]:cP,[gw]:mP,[yw]:gP};class uv extends st{constructor(t=Tn,e=_P,i=null){super("vec3"),this.toneMapping=t,this.exposureNode=e,this.colorNode=i}getCacheKey(){let t=super.getCacheKey();return t="{toneMapping:"+this.toneMapping+",nodes:"+t+"}",t}setup(t){const e=this.colorNode||t.context.color,i=this.toneMapping;if(i===Tn)return e;const s={exposure:this.exposureNode,color:e},n=yP[i];let r=null;return n?r=n(s):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",i),r=e),r}}const xP=(o,t,e)=>L(new uv(o,L(t),L(e))),_P=FC("toneMappingExposure","float");N("toneMapping",(o,t,e)=>xP(t,e,o));O("ToneMappingNode",uv);let Fc=null;class cv extends Sa{constructor(t=Zr,e=null){Fc===null&&(Fc=new n_),super(t,e,Fc)}updateReference(){return this}}const MP=I(cv);N("viewportSharedTexture",MP);O("ViewportSharedTextureNode",cv);const vP=new q;class dv extends zi{constructor(t,e){super(e),this.passNode=t,this.setUpdateMatrix(!1)}setup(t){return this.passNode.build(t),super.setup(t)}clone(){return new this.constructor(this.passNode,this.value)}}class TP extends dv{constructor(t,e){super(t,null),this.textureName=e}setup(t){return this.value=this.passNode.getTexture(this.textureName),super.setup(t)}clone(){return new this.constructor(this.passNode,this.textureName)}}class Sn extends st{constructor(t,e,i,s={}){super("vec4"),this.scope=t,this.scene=e,this.camera=i,this.options=s,this._pixelRatio=1,this._width=1,this._height=1;const n=new _a;n.isRenderTargetTexture=!0,n.name="depth";const r=new be(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:wi,...s});r.texture.name="output",r.depthTexture=n,this.renderTarget=r,this.updateBeforeType=Y.FRAME,this._textures={output:r.texture,depth:n},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._cameraNear=H(0),this._cameraFar=H(0),this._mrt=null,this.isPassNode=!0}setMRT(t){return this._mrt=t,this}getMRT(){return this._mrt}isGlobal(){return!0}getTexture(t){let e=this._textures[t];return e===void 0&&(e=this.renderTarget.texture.clone(),e.isRenderTargetTexture=!0,e.name=t,this._textures[t]=e,this.renderTarget.textures.push(e)),e}getTextureNode(t="output"){let e=this._textureNodes[t];return e===void 0&&(this._textureNodes[t]=e=L(new TP(this,t))),e}getViewZNode(t="depth"){let e=this._viewZNodes[t];if(e===void 0){const i=this._cameraNear,s=this._cameraFar;this._viewZNodes[t]=e=NM(this.getTextureNode(t),i,s)}return e}getLinearDepthNode(t="depth"){let e=this._linearDepthNodes[t];if(e===void 0){const i=this._cameraNear,s=this._cameraFar,n=this.getViewZNode(t);this._linearDepthNodes[t]=e=Jl(n,i,s)}return e}setup({renderer:t}){return this.renderTarget.samples=this.options.samples===void 0?t.samples:this.options.samples,t.backend.isWebGLBackend===!0&&(this.renderTarget.samples=0),this.renderTarget.depthTexture.isMultisampleRenderTargetTexture=this.renderTarget.samples>1,this.scope===Sn.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(t){const{renderer:e}=t,{scene:i,camera:s}=this;this._pixelRatio=e.getPixelRatio();const n=e.getSize(vP);this.setSize(n.width,n.height);const r=e.getRenderTarget(),a=e.getMRT();this._cameraNear.value=s.near,this._cameraFar.value=s.far,e.setRenderTarget(this.renderTarget),e.setMRT(this._mrt),e.render(i,s),e.setRenderTarget(r),e.setMRT(a)}setSize(t,e){this._width=t,this._height=e;const i=this._width*this._pixelRatio,s=this._height*this._pixelRatio;this.renderTarget.setSize(i,s)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}Sn.COLOR="color";Sn.DEPTH="depth";const JD=(o,t,e)=>L(new Sn(Sn.COLOR,o,t,e)),wa=(o,t)=>L(new dv(o,t));O("PassNode",Sn);const Ty=new gs,by=new gs;class bP extends st{constructor(t,e=null,i=2){super("vec4"),this.textureNode=t,this.directionNode=e,this.sigma=i,this._invSize=H(new q),this._passDirection=H(new q),this._horizontalRT=new be,this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new be,this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=wa(this,this._verticalRT.texture),this.updateBeforeType=Y.RENDER,this.resolution=new q(1,1)}setSize(t,e){t=Math.max(Math.round(t*this.resolution.x),1),e=Math.max(Math.round(e*this.resolution.y),1),this._invSize.value.set(1/t,1/e),this._horizontalRT.setSize(t,e),this._verticalRT.setSize(t,e)}updateBefore(t){const{renderer:e}=t,i=this.textureNode,s=i.value,n=e.getRenderTarget(),r=e.getMRT(),a=i.value;Ty.material=this._material,by.material=this._material,this.setSize(s.image.width,s.image.height);const l=s.type;this._horizontalRT.texture.type=l,this._verticalRT.texture.type=l,e.setMRT(null),e.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),Ty.render(e),i.value=this._horizontalRT.texture,e.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),by.render(e),e.setRenderTarget(n),e.setMRT(r),i.value=a}getTextureNode(){return this._textureNode}setup(t){const e=this.textureNode;if(e.isTextureNode!==!0)return console.error("GaussianBlurNode requires a TextureNode."),G();const i=e.uvNode||Nt(),s=F(this.directionNode||1),n=h=>e.uv(h),r=z(()=>{const h=3+2*this.sigma,u=this._getCoefficients(h),c=this._invSize,d=s.mul(this._passDirection),p=C(u[0]).toVar(),f=G(n(i).mul(p)).toVar();for(let m=1;m<h;m++){const g=C(m),y=C(u[m]),x=F(d.mul(c.mul(g))).toVar(),M=G(n(i.add(x))),_=G(n(i.sub(x)));f.addAssign(M.add(_).mul(y)),p.addAssign(ut(2,y))}return f.div(p)}),a=this._material||(this._material=t.createNodeMaterial());a.fragmentNode=r().context(t.getSharedContext()),a.needsUpdate=!0;const l=t.getNodeProperties(this);return l.textureNode=e,this._textureNode}dispose(){this._horizontalRT.dispose(),this._verticalRT.dispose()}_getCoefficients(t){const e=[];for(let i=0;i<t;i++)e.push(.39894*Math.exp(-.5*i*i/(t*t))/t);return e}}const SP=(o,t,e)=>L(new bP(L(o).toTexture(),t,e));N("gaussianBlur",SP);const Ic=new q,Sy=new gs;class wP extends st{constructor(t,e=.96){super(t),this.textureNode=t,this.textureNodeOld=gt(),this.damp=H(e),this._compRT=new be,this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new be,this._oldRT.texture.name="AfterImageNode.old",this._textureNode=wa(this,this._compRT.texture),this.updateBeforeType=Y.RENDER}getTextureNode(){return this._textureNode}setSize(t,e){this._compRT.setSize(t,e),this._oldRT.setSize(t,e)}updateBefore(t){const{renderer:e}=t,i=this.textureNode,n=i.value.type;this._compRT.texture.type=n,this._oldRT.texture.type=n,e.getDrawingBufferSize(Ic),this.setSize(Ic.x,Ic.y);const r=e.getRenderTarget(),a=i.value;this.textureNodeOld.value=this._oldRT.texture,e.setRenderTarget(this._compRT),Sy.render(e);const l=this._oldRT;this._oldRT=this._compRT,this._compRT=l,e.setRenderTarget(r),i.value=a}setup(t){const e=this.textureNode,i=this.textureNodeOld,s=e.uvNode||Nt();i.uvNode=s;const n=u=>e.uv(u),r=z(([u,c])=>{const d=C(c).toVar(),p=G(u).toVar();return Et(Kh(p.sub(d)),0)}),a=z(()=>{const u=G(i),c=G(n(s));return u.mulAssign(this.damp.mul(r(u,.1))),Et(c,u)}),l=this._materialComposed||(this._materialComposed=t.createNodeMaterial());l.fragmentNode=a(),Sy.material=l;const h=t.getNodeProperties(this);return h.textureNode=e,this._textureNode}dispose(){this._compRT.dispose(),this._oldRT.dispose()}}const AP=(o,t)=>L(new wP(L(o).toTexture(),t));N("afterImage",AP);const wy=new gs;class NP extends st{constructor(t,e,i,s){super("vec4"),this.textureNode=t,this.tresholdNode=e,this.scaleNode=i,this.colorNode=P(.1,0,1),this.samples=s,this.resolution=new q(1,1),this._renderTarget=new be,this._renderTarget.texture.name="anamorphic",this._invSize=H(new q),this._textureNode=wa(this,this._renderTarget.texture),this.updateBeforeType=Y.RENDER}getTextureNode(){return this._textureNode}setSize(t,e){this._invSize.value.set(1/t,1/e),t=Math.max(Math.round(t*this.resolution.x),1),e=Math.max(Math.round(e*this.resolution.y),1),this._renderTarget.setSize(t,e)}updateBefore(t){const{renderer:e}=t,i=this.textureNode,s=i.value;this._renderTarget.texture.type=s.type;const n=e.getRenderTarget(),r=i.value;wy.material=this._material,this.setSize(s.image.width,s.image.height),e.setRenderTarget(this._renderTarget),wy.render(e),e.setRenderTarget(n),i.value=r}setup(t){const e=this.textureNode,i=e.uvNode||Nt(),s=l=>e.uv(l),n=z(()=>{const l=this.samples,h=Math.floor(l/2),u=P(0).toVar();return Te({start:-h,end:h},({i:c})=>{const d=C(c).abs().div(h).oneMinus(),p=F(i.x.add(this._invSize.x.mul(c).mul(this.scaleNode)),i.y),f=s(p),m=ov(f,this.tresholdNode).mul(d);u.addAssign(m)}),u.mul(this.colorNode)}),r=this._material||(this._material=t.createNodeMaterial());r.fragmentNode=n();const a=t.getNodeProperties(this);return a.textureNode=e,this._textureNode}dispose(){this._renderTarget.dispose()}}const RP=(o,t=.9,e=3,i=32)=>L(new NP(L(o).toTexture(),L(t),L(e),i));N("anamorphic",RP);class EP extends st{constructor(t){super(),this.textureNode=t,this.updateBeforeType=Y.RENDER,this._invSize=H(new q)}updateBefore(){const t=this.textureNode.value;this._invSize.value.set(1/t.image.width,1/t.image.height)}setup(){const{textureNode:t}=this,e=t.uvNode||Nt(),i=r=>t.uv(r);return z(()=>{const r=this._invSize,a=de(-1,-2,-1,0,0,0,1,2,1),l=de(-1,0,1,-2,0,2,-1,0,1),h=Ee(i(e.add(r.mul(F(-1,-1)))).xyz),u=Ee(i(e.add(r.mul(F(-1,0)))).xyz),c=Ee(i(e.add(r.mul(F(-1,1)))).xyz),d=Ee(i(e.add(r.mul(F(0,-1)))).xyz),p=Ee(i(e.add(r.mul(F(0,0)))).xyz),f=Ee(i(e.add(r.mul(F(0,1)))).xyz),m=Ee(i(e.add(r.mul(F(1,-1)))).xyz),g=Ee(i(e.add(r.mul(F(1,0)))).xyz),y=Ee(i(e.add(r.mul(F(1,1)))).xyz),x=Yt(a[0][0].mul(h),a[1][0].mul(d),a[2][0].mul(m),a[0][1].mul(u),a[1][1].mul(p),a[2][1].mul(g),a[0][2].mul(c),a[1][2].mul(f),a[2][2].mul(y)),M=Yt(l[0][0].mul(h),l[1][0].mul(d),l[2][0].mul(m),l[0][1].mul(u),l[1][1].mul(p),l[2][1].mul(g),l[0][2].mul(c),l[1][2].mul(f),l[2][2].mul(y)),_=x.mul(x).add(M.mul(M)).sqrt();return G(P(_),1)})()}}const CP=o=>L(new EP(L(o).toTexture()));N("sobel",CP);class PP extends st{constructor(t,e,i,s,n){super(),this.textureNode=t,this.viewZNode=e,this.focusNode=i,this.apertureNode=s,this.maxblurNode=n,this._aspect=H(0),this.updateBeforeType=Y.RENDER}updateBefore(){const t=this.textureNode.value;this._aspect.value=t.image.width/t.image.height}setup(){const t=this.textureNode,e=t.uvNode||Nt(),i=r=>t.uv(r);return z(()=>{const r=F(1,this._aspect),a=this.focusNode.add(this.viewZNode),l=F(Me(a.mul(this.apertureNode),this.maxblurNode.negate(),this.maxblurNode)),h=l.mul(.9),u=l.mul(.7),c=l.mul(.4);let d=G(0);return d=d.add(i(e)),d=d.add(i(e.add(F(0,.4).mul(r).mul(l)))),d=d.add(i(e.add(F(.15,.37).mul(r).mul(l)))),d=d.add(i(e.add(F(.29,.29).mul(r).mul(l)))),d=d.add(i(e.add(F(-.37,.15).mul(r).mul(l)))),d=d.add(i(e.add(F(.4,0).mul(r).mul(l)))),d=d.add(i(e.add(F(.37,-.15).mul(r).mul(l)))),d=d.add(i(e.add(F(.29,-.29).mul(r).mul(l)))),d=d.add(i(e.add(F(-.15,-.37).mul(r).mul(l)))),d=d.add(i(e.add(F(0,-.4).mul(r).mul(l)))),d=d.add(i(e.add(F(-.15,.37).mul(r).mul(l)))),d=d.add(i(e.add(F(-.29,.29).mul(r).mul(l)))),d=d.add(i(e.add(F(.37,.15).mul(r).mul(l)))),d=d.add(i(e.add(F(-.4,0).mul(r).mul(l)))),d=d.add(i(e.add(F(-.37,-.15).mul(r).mul(l)))),d=d.add(i(e.add(F(-.29,-.29).mul(r).mul(l)))),d=d.add(i(e.add(F(.15,-.37).mul(r).mul(l)))),d=d.add(i(e.add(F(.15,.37).mul(r).mul(h)))),d=d.add(i(e.add(F(-.37,.15).mul(r).mul(h)))),d=d.add(i(e.add(F(.37,-.15).mul(r).mul(h)))),d=d.add(i(e.add(F(-.15,-.37).mul(r).mul(h)))),d=d.add(i(e.add(F(-.15,.37).mul(r).mul(h)))),d=d.add(i(e.add(F(.37,.15).mul(r).mul(h)))),d=d.add(i(e.add(F(-.37,-.15).mul(r).mul(h)))),d=d.add(i(e.add(F(.15,-.37).mul(r).mul(h)))),d=d.add(i(e.add(F(.29,.29).mul(r).mul(u)))),d=d.add(i(e.add(F(.4,0).mul(r).mul(u)))),d=d.add(i(e.add(F(.29,-.29).mul(r).mul(u)))),d=d.add(i(e.add(F(0,-.4).mul(r).mul(u)))),d=d.add(i(e.add(F(-.29,.29).mul(r).mul(u)))),d=d.add(i(e.add(F(-.4,0).mul(r).mul(u)))),d=d.add(i(e.add(F(-.29,-.29).mul(r).mul(u)))),d=d.add(i(e.add(F(0,.4).mul(r).mul(u)))),d=d.add(i(e.add(F(.29,.29).mul(r).mul(c)))),d=d.add(i(e.add(F(.4,0).mul(r).mul(c)))),d=d.add(i(e.add(F(.29,-.29).mul(r).mul(c)))),d=d.add(i(e.add(F(0,-.4).mul(r).mul(c)))),d=d.add(i(e.add(F(-.29,.29).mul(r).mul(c)))),d=d.add(i(e.add(F(-.4,0).mul(r).mul(c)))),d=d.add(i(e.add(F(-.29,-.29).mul(r).mul(c)))),d=d.add(i(e.add(F(0,.4).mul(r).mul(c)))),d=d.div(41),d.a=1,G(d)})()}}const FP=(o,t,e=1,i=.025,s=1)=>L(new PP(L(o).toTexture(),L(t),L(e),L(i),L(s)));N("dof",FP);class IP extends st{constructor(t,e=new q(.5,.5),i=1.57,s=1){super("vec4"),this.inputNode=t,this.center=H(e),this.angle=H(i),this.scale=H(s),this._size=H(new q),this.updateBeforeType=Y.RENDER}updateBefore(t){const{renderer:e}=t;e.getDrawingBufferSize(this._size.value)}setup(){const t=this.inputNode,e=z(()=>{const n=he(this.angle),r=$e(this.angle),a=Nt().mul(this._size).sub(this.center),l=F(r.mul(a.x).sub(n.mul(a.y)),n.mul(a.x).add(r.mul(a.y))).mul(this.scale);return he(l.x).mul(he(l.y)).mul(4)});return z(()=>{const n=t,r=Yt(n.r,n.g,n.b).div(3);return G(P(r.mul(10).sub(5).add(e())),n.a)})()}}const BP=(o,t,e,i)=>L(new IP(L(o),t,e,i));N("dotScreen",BP);class LP extends st{constructor(t,e=.005,i=0){super("vec4"),this.textureNode=t,this.amount=H(e),this.angle=H(i)}setup(){const{textureNode:t}=this,e=t.uvNode||Nt(),i=n=>t.uv(n);return z(()=>{const n=F($e(this.angle),he(this.angle)).mul(this.amount),r=i(e.add(n)),a=i(e),l=i(e.sub(n));return G(r.r,a.g,l.b,a.a)})()}}const UP=(o,t,e)=>L(new LP(L(o).toTexture(),t,e));N("rgbShift",UP);class DP extends st{constructor(t,e=null,i=null){super(),this.inputNode=t,this.intensityNode=e,this.uvNode=i}setup(){const t=this.uvNode||Nt();return z(()=>{const s=this.inputNode.rgb,n=X_(En(t.add(WM())));let r=s.add(s.mul(Me(n.add(.1),0,1)));return this.intensityNode!==null&&(r=K(s,r,this.intensityNode)),G(r,this.inputNode.a)})()}}const OP=I(DP);N("film",OP);class zP extends st{constructor(t,e,i,s){super(),this.inputNode=t,this.lutNode=e,this.size=H(i),this.intensityNode=s}setup(){const{inputNode:t,lutNode:e}=this,i=r=>e.uv(r);return z(()=>{const r=t,a=C(1).div(this.size),l=C(.5).div(this.size),h=P(l).add(r.rgb.mul(C(1).sub(a))),u=G(i(h).rgb,r.a);return G(K(r,u,this.intensityNode))})()}}const VP=(o,t,e,i)=>L(new zP(L(o),L(t),e,L(i)));N("lut3D",VP);const Ay=new gs,Ny=new nt,kP=new q;class GP extends st{constructor(t,e,i){super(),this.depthNode=t,this.normalNode=e,this.radius=H(.25),this.resolution=H(new q),this.thickness=H(1),this.distanceExponent=H(1),this.distanceFallOff=H(1),this.scale=H(1),this.noiseNode=gt(WP()),this.cameraProjectionMatrix=H(i.projectionMatrix),this.cameraProjectionMatrixInverse=H(i.projectionMatrixInverse),this.SAMPLES=H(16),this._aoRenderTarget=new be,this._aoRenderTarget.texture.name="GTAONode.AO",this._material=null,this._textureNode=wa(this,this._aoRenderTarget.texture),this.updateBeforeType=Y.FRAME}getTextureNode(){return this._textureNode}setSize(t,e){this.resolution.value.set(t,e),this._aoRenderTarget.setSize(t,e)}updateBefore(t){const{renderer:e}=t,i=e.getDrawingBufferSize(kP),s=e.getRenderTarget(),n=e.getMRT();e.getClearColor(Ny);const r=e.getClearAlpha();Ay.material=this._material,this.setSize(i.width,i.height),e.setMRT(null),e.setClearColor(16777215,1),e.setRenderTarget(this._aoRenderTarget),Ay.render(e),e.setRenderTarget(s),e.setMRT(n),e.setClearColor(Ny,r)}setup(t){const e=Nt(),i=h=>this.depthNode.uv(h).x,s=h=>this.noiseNode.uv(h),n=z(([h])=>{const u=this.cameraProjectionMatrix.mul(G(h,1));let c=u.xy.div(u.w).mul(.5).add(.5).toVar();c=F(c.x,c.y.oneMinus());const d=i(c);return P(c,d)}),r=z(([h,u])=>{h=F(h.x,h.y.oneMinus()).mul(2).sub(1);const c=G(P(h,u),1),d=G(this.cameraProjectionMatrixInverse.mul(c));return d.xyz.div(d.w)}),a=z(()=>{const h=i(e);h.greaterThanEqual(1).discard();const u=r(e,h),c=this.normalNode.rgb.normalize(),d=this.radius,p=Xr(this.noiseNode,0);let f=F(e.x,e.y.oneMinus());f=f.mul(this.resolution.div(p));const m=s(f),g=m.xyz.mul(2).sub(1),y=P(g.xy,0).normalize(),x=P(y.y.mul(-1),y.x,0),M=de(y,x,P(0,0,1)),_=this.SAMPLES.lessThan(30).cond(3,5),v=Yt(this.SAMPLES,_.sub(1)).div(_),A=C(0).toVar();return Te({start:xt(0),end:_,type:"int",condition:"<"},({i:T})=>{const w=C(T).div(C(_)).mul(Yr),U=G($e(w),he(w),0,Yt(.5,ut(.5,m.w)));U.xyz=Mi(M.mul(U.xyz));const D=Mi(u.xyz.negate()),V=Mi(Zo(U.xyz,D)),W=Zo(V,D),$=Mi(c.sub(V.mul(oe(c,V)))),at=Zo($,V),J=F(oe(D,at),oe(D,at.negate())).toVar();Te({end:v,type:"int",name:"j",condition:"<"},({j:qt})=>{const fe=U.xyz.mul(d).mul(U.w).mul(Xe(Oi(C(qt).add(1),C(v)),this.distanceExponent)),ti=n(u.add(fe)),ui=r(ti.xy,ti.z).sub(u);it(ue(ui.z).lessThan(this.thickness),()=>{const ys=oe(D,Mi(ui));J.x.addAssign(Et(0,ut(ys.sub(J.x),K(1,C(2).div(C(qt).add(2)),this.distanceFallOff))))});const ci=n(u.sub(fe)),qs=r(ci.xy,ci.z).sub(u);it(ue(qs.z).lessThan(this.thickness),()=>{const ys=oe(D,Mi(qs));J.y.addAssign(Et(0,ut(ys.sub(J.y),K(1,C(2).div(C(qt).add(2)),this.distanceFallOff))))})});const At=G_(Ie(1,J.mul(J))),St=oe($,W),Pt=oe($,D),dt=ut(.5,qd(J.y).sub(qd(J.x)).add(At.x.mul(J.x).sub(At.y.mul(J.y)))),tt=ut(.5,Ie(2,J.x.mul(J.x)).sub(J.y.mul(J.y))),Rt=St.mul(dt).add(Pt.mul(tt));A.addAssign(Rt)}),A.assign(Me(A.div(_),0,1)),A.assign(Xe(A,this.scale)),G(P(A),1)}),l=this._material||(this._material=t.createNodeMaterial());return l.fragmentNode=a().context(t.getSharedContext()),l.needsUpdate=!0,this._textureNode}dispose(){this._aoRenderTarget.dispose()}}function WP(o=5){const t=Math.floor(o)%2===0?Math.floor(o)+1:Math.floor(o),e=HP(t),i=e.length,s=new Uint8Array(i*4);for(let r=0;r<i;++r){const a=e[r],l=2*Math.PI*a/i,h=new E(Math.cos(l),Math.sin(l),0).normalize();s[r*4]=(h.x*.5+.5)*255,s[r*4+1]=(h.y*.5+.5)*255,s[r*4+2]=127,s[r*4+3]=255}const n=new K0(s,t,t);return n.wrapS=$r,n.wrapT=$r,n.needsUpdate=!0,n}function HP(o){const t=Math.floor(o)%2===0?Math.floor(o)+1:Math.floor(o),e=t*t,i=Array(e).fill(0);let s=Math.floor(t/2),n=t-1;for(let r=1;r<=e;){if(s===-1&&n===t?(n=t-2,s=0):(n===t&&(n=0),s<0&&(s=t-1)),i[s*t+n]!==0){n-=2,s++;continue}else i[s*t+n]=r++;n++,s--}return i}const $P=(o,t,e)=>L(new GP(L(o),L(t),e));N("ao",$P);class qP extends st{constructor(t,e,i,s,n){super(),this.textureNode=t,this.depthNode=e,this.normalNode=i,this.noiseNode=s,this.cameraProjectionMatrixInverse=H(n.projectionMatrixInverse),this.lumaPhi=H(5),this.depthPhi=H(5),this.normalPhi=H(5),this.radius=H(5),this.index=H(0),this._resolution=H(new q),this._sampleVectors=zs(jP(16,2,1)),this.updateBeforeType=Y.RENDER}updateBefore(){const t=this.textureNode.value;this._resolution.value.set(t.image.width,t.image.height)}setup(){const t=Nt(),e=c=>this.textureNode.uv(c),i=c=>this.depthNode.uv(c).x,s=c=>this.normalNode.uv(c),n=c=>this.noiseNode.uv(c),r=z(([c,d])=>{c=F(c.x,c.y.oneMinus()).mul(2).sub(1);const p=G(P(c,d),1),f=G(this.cameraProjectionMatrixInverse.mul(p));return f.xyz.div(f.w)}),a=z(([c,d,p,f])=>{const m=e(f),g=i(f),y=s(f).rgb.normalize(),x=m.rgb,M=r(f,g),_=oe(d,y).toVar(),v=Xe(Et(_,0),this.normalPhi).toVar(),A=ue(Ee(x).sub(Ee(c))).toVar(),T=Et(C(1).sub(A.div(this.lumaPhi)),0).toVar(),w=ue(oe(p.sub(M),d)).toVar(),U=Et(C(1).sub(w.div(this.depthPhi)),0),D=T.mul(U).mul(v);return G(x.mul(D),D)}),l=z(([c])=>{const d=i(c),p=s(c).rgb.normalize(),f=e(c);it(d.greaterThanEqual(1).or(oe(p,p).equal(0)),()=>f);const m=P(f.rgb),g=r(c,d),y=Xr(this.noiseNode,0);let x=F(c.x,c.y.oneMinus());x=x.mul(this._resolution.div(y));const M=n(x),_=he(M.element(this.index.mod(4).mul(2).mul(Yr))),v=$e(M.element(this.index.mod(4).mul(2).mul(Yr))),A=F(_,v),T=va(A.x,A.y.negate(),A.x,A.y),w=C(1).toVar(),U=P(f.rgb).toVar();return Te({start:xt(0),end:xt(16),type:"int",condition:"<"},({i:D})=>{const V=this._sampleVectors.element(D).toVar(),W=T.mul(V.xy.mul(C(1).add(V.z.mul(this.radius.sub(1))))).div(this._resolution).toVar(),$=c.add(W).toVar(),at=a(m,p,g,$);U.addAssign(at.xyz),w.addAssign(at.w)}),it(w.greaterThan(C(0)),()=>{U.divAssign(w)}),G(U,f.a)}).setLayout({name:"denoise",type:"vec4",inputs:[{name:"uv",type:"vec2"}]});return z(()=>l(t))()}}function jP(o,t,e){const i=XP(o,t,e),s=[];for(let n=0;n<o;n++){const r=i[n];s.push(r)}return s}function XP(o,t,e){const i=[];for(let s=0;s<o;s++){const n=2*Math.PI*t*s/o,r=Math.pow(s/(o-1),e);i.push(new E(Math.cos(n),Math.sin(n),r))}return i}const YP=(o,t,e,i,s)=>L(new qP(L(o).toTexture(),L(t),L(e),L(i),s));N("denoise",YP);class ZP extends st{constructor(t){super(),this.textureNode=t,this.updateBeforeType=Y.RENDER,this._invSize=H(new q)}updateBefore(){const t=this.textureNode.value;this._invSize.value.set(1/t.image.width,1/t.image.height)}setup(){const t=this.textureNode.bias(-100),e=t.uvNode||Nt(),i=u=>t.uv(u),s=(u,c,d)=>t.uv(u.add(c.mul(d))),n=xt(5),r=z(([u,c])=>{const d=G(c).toVar(),p=G(u).toVar(),f=G(ue(p.sub(d))).toVar();return Et(Et(Et(f.r,f.g),f.b),f.a)}),a=z(([u,c,d,p])=>{const f=i(u).toVar(),m=s(u,F(0,-1),c.xy).toVar(),g=s(u,F(1,0),c.xy).toVar(),y=s(u,F(0,1),c.xy).toVar(),x=s(u,F(-1,0),c.xy).toVar(),M=r(f,y).toVar(),_=r(f,m).toVar(),v=r(f,g).toVar(),A=r(f,x).toVar(),T=Et(M,Et(_,Et(v,A))).toVar();it(T.lessThan(d),()=>f);const w=Ie(M.add(_),v.add(A)).toVar();w.mulAssign(p),it(ue(w).lessThan(.3),()=>{const fe=v.greaterThan(A).cond(1,-1).toVar(),ti=_.greaterThan(M).cond(1,-1).toVar(),ie=F(fe,ti).toVar(),ui=s(u,F(ie.x,ie.y),c.xy),ci=r(f,ui).toVar(),uo=s(u,F(ie.x.negate(),ie.y.negate()),c.xy),qs=r(f,uo).toVar();w.assign(qs.sub(ci)),w.mulAssign(p),it(ue(w).lessThan(.3),()=>{const ys=y.add(m).add(g).add(x);return K(f,ys.mul(.25),.4)})});const U=F().toVar();it(w.lessThanEqual(0),()=>{y.assign(x),m.assign(g),U.x.assign(0),U.y.assign(c.y)}).else(()=>{U.x.assign(c.x),U.y.assign(0)});const D=r(f,y).toVar(),V=r(f,m).toVar();it(D.lessThanEqual(V),()=>{y.assign(m)});const W=xt(0).toVar(),$=xt(0).toVar(),at=C(0).toVar(),J=C(0).toVar(),At=F(u).toVar(),St=F(u).toVar(),Pt=xt(0).toVar(),dt=xt(0).toVar();Te(n,({i:fe})=>{const ti=fe.add(1).toVar();it(W.equal(0),()=>{at.addAssign(ti),At.assign(u.add(U.mul(at)));const ie=i(At.xy),ui=r(ie,f).toVar(),ci=r(ie,y).toVar();it(ui.greaterThan(ci),()=>{W.assign(1)}),Pt.assign(fe)}),it($.equal(0),()=>{J.addAssign(ti),St.assign(u.sub(U.mul(J)));const ie=i(St.xy),ui=r(ie,f).toVar(),ci=r(ie,y).toVar();it(ui.greaterThan(ci),()=>{$.assign(1)}),dt.assign(fe)}),it(W.equal(1).or($.equal(1)),()=>{lf()})}),it(W.equal(0).and($.equal(0)),()=>f);const tt=C(1).toVar(),Rt=C(1).toVar();it(W.equal(1),()=>{tt.assign(C(Pt).div(C(n.sub(1))))}),it($.equal(1),()=>{Rt.assign(C(dt).div(C(n.sub(1))))});const qt=Ui(tt,Rt);return qt.assign(Xe(qt,.5)),qt.assign(C(1).sub(qt)),K(f,y,qt.mul(.5))}).setLayout({name:"FxaaPixelShader",type:"vec4",inputs:[{name:"uv",type:"vec2"},{name:"fxaaQualityRcpFrame",type:"vec2"},{name:"fxaaQualityEdgeThreshold",type:"float"},{name:"fxaaQualityinvEdgeThreshold",type:"float"}]});return z(()=>{const u=C(.2),c=C(1).div(u);return a(e,this._invSize,u,c)})()}}const QP=o=>L(new ZP(L(o).toTexture()));N("fxaa",QP);const nn=new gs,JP=new nt(0,0,0),Ry=new nt,KP=new q,tF=new q(1,0),eF=new q(0,1);class iF extends st{constructor(t,e=1,i=0,s=0){super(),this.inputNode=t,this.strength=H(e),this.radius=H(i),this.threshold=H(s),this.smoothWidth=H(.01),this._renderTargetsHorizontal=[],this._renderTargetsVertical=[],this._nMips=5,this._renderTargetBright=new be(1,1,{type:wi}),this._renderTargetBright.texture.name="UnrealBloomPass.bright",this._renderTargetBright.texture.generateMipmaps=!1;for(let n=0;n<this._nMips;n++){const r=new be(1,1,{type:wi});r.texture.name="UnrealBloomPass.h"+n,r.texture.generateMipmaps=!1,this._renderTargetsHorizontal.push(r);const a=new be(1,1,{type:wi});a.texture.name="UnrealBloomPass.v"+n,a.texture.generateMipmaps=!1,this._renderTargetsVertical.push(a)}this._compositeMaterial=null,this._highPassFilterMaterial=null,this._separableBlurMaterials=[],this._textureNodeBright=gt(this._renderTargetBright.texture),this._textureNodeBlur0=gt(this._renderTargetsVertical[0].texture),this._textureNodeBlur1=gt(this._renderTargetsVertical[1].texture),this._textureNodeBlur2=gt(this._renderTargetsVertical[2].texture),this._textureNodeBlur3=gt(this._renderTargetsVertical[3].texture),this._textureNodeBlur4=gt(this._renderTargetsVertical[4].texture),this._textureOutput=wa(this,this._renderTargetsHorizontal[0].texture),this.updateBeforeType=Y.FRAME}getTextureNode(){return this._textureOutput}setSize(t,e){let i=Math.round(t/2),s=Math.round(e/2);this._renderTargetBright.setSize(i,s);for(let n=0;n<this._nMips;n++)this._renderTargetsHorizontal[n].setSize(i,s),this._renderTargetsVertical[n].setSize(i,s),this._separableBlurMaterials[n].invSize.value.set(1/i,1/s),i=Math.round(i/2),s=Math.round(s/2)}updateBefore(t){const{renderer:e}=t,i=e.getDrawingBufferSize(KP);this.setSize(i.width,i.height);const s=e.getRenderTarget(),n=e.getMRT();e.getClearColor(Ry);const r=e.getClearAlpha();this.setSize(i.width,i.height),e.setMRT(null),e.setClearColor(JP,0),e.setRenderTarget(this._renderTargetBright),nn.material=this._highPassFilterMaterial,nn.render(e);let a=this._renderTargetBright;for(let l=0;l<this._nMips;l++)nn.material=this._separableBlurMaterials[l],this._separableBlurMaterials[l].colorTexture.value=a.texture,this._separableBlurMaterials[l].direction.value=tF,e.setRenderTarget(this._renderTargetsHorizontal[l]),e.clear(),nn.render(e),this._separableBlurMaterials[l].colorTexture.value=this._renderTargetsHorizontal[l].texture,this._separableBlurMaterials[l].direction.value=eF,e.setRenderTarget(this._renderTargetsVertical[l]),e.clear(),nn.render(e),a=this._renderTargetsVertical[l];e.setRenderTarget(this._renderTargetsHorizontal[0]),e.clear(),nn.material=this._compositeMaterial,nn.render(e),e.setRenderTarget(s),e.setMRT(n),e.setClearColor(Ry,r)}setup(t){const e=z(()=>{const l=this.inputNode,h=Ee(l.rgb),u=Je(this.threshold,this.threshold.add(this.smoothWidth),h);return K(G(0),l,u)});this._highPassFilterMaterial=this._highPassFilterMaterial||t.createNodeMaterial(),this._highPassFilterMaterial.fragmentNode=e().context(t.getSharedContext()),this._highPassFilterMaterial.needsUpdate=!0;const i=[3,5,7,9,11];for(let l=0;l<this._nMips;l++)this._separableBlurMaterials.push(this._getSeperableBlurMaterial(t,i[l]));const s=zs([1,.8,.6,.4,.2]),n=zs([new E(1,1,1),new E(1,1,1),new E(1,1,1),new E(1,1,1),new E(1,1,1)]),r=z(([l,h])=>{const u=C(1.2).sub(l);return K(l,u,h)}).setLayout({name:"lerpBloomFactor",type:"float",inputs:[{name:"factor",type:"float"},{name:"radius",type:"float"}]}),a=z(()=>{const l=r(s.element(0),this.radius).mul(G(n.element(0),1)).mul(this._textureNodeBlur0),h=r(s.element(1),this.radius).mul(G(n.element(1),1)).mul(this._textureNodeBlur1),u=r(s.element(2),this.radius).mul(G(n.element(2),1)).mul(this._textureNodeBlur2),c=r(s.element(3),this.radius).mul(G(n.element(3),1)).mul(this._textureNodeBlur3),d=r(s.element(4),this.radius).mul(G(n.element(4),1)).mul(this._textureNodeBlur4);return l.add(h).add(u).add(c).add(d).mul(this.strength)});return this._compositeMaterial=this._compositeMaterial||t.createNodeMaterial(),this._compositeMaterial.fragmentNode=a().context(t.getSharedContext()),this._compositeMaterial.needsUpdate=!0,this._textureOutput}dispose(){for(let t=0;t<this._renderTargetsHorizontal.length;t++)this._renderTargetsHorizontal[t].dispose();for(let t=0;t<this._renderTargetsVertical.length;t++)this._renderTargetsVertical[t].dispose();this._renderTargetBright.dispose()}_getSeperableBlurMaterial(t,e){const i=[];for(let d=0;d<e;d++)i.push(.39894*Math.exp(-.5*d*d/(e*e))/e);const s=gt(),n=zs(i),r=H(new q),a=H(new q(.5,.5)),l=Nt(),h=d=>s.uv(d),u=z(()=>{const d=n.element(0).toVar(),p=h(l).rgb.mul(d).toVar();return Te({start:xt(1),end:xt(e),type:"int",condition:"<"},({i:f})=>{const m=C(f),g=n.element(f),y=a.mul(r).mul(m),x=h(l.add(y)).rgb,M=h(l.sub(y)).rgb;p.addAssign(Yt(x,M).mul(g)),d.addAssign(C(2).mul(g))}),G(p.div(d),1)}),c=t.createNodeMaterial();return c.fragmentNode=u().context(t.getSharedContext()),c.needsUpdate=!0,c.colorTexture=s,c.direction=a,c.invSize=r,c}}const sF=(o,t,e,i)=>L(new iF(L(o),t,e,i));N("bloom",sF);class nF extends st{constructor(t,e,i,s,n,r){super(),this.textureNodeA=t,this.textureNodeB=e,this.mixTextureNode=i,this.mixRatioNode=s,this.thresholdNode=n,this.useTextureNode=r}setup(){const{textureNodeA:t,textureNodeB:e,mixTextureNode:i,mixRatioNode:s,thresholdNode:n,useTextureNode:r}=this,a=u=>{const c=u.uvNode||Nt();return u.uv(c)};return z(()=>{const u=a(t),c=a(e),d=G().toVar();return it(r.equal(xt(1)),()=>{const p=a(i),f=s.mul(n.mul(2).add(1)).sub(n),m=Me(Ie(p.r,f).mul(C(1).div(n)),0,1);d.assign(K(u,c,m))}).else(()=>{d.assign(K(c,u,s))}),d})()}}const rF=(o,t,e,i=0,s=.1,n=0)=>L(new nF(L(o).toTexture(),L(t).toTexture(),L(e).toTexture(),L(i),L(s),L(n)));N("transition",rF);class pv extends st{constructor(t,e,i){super("vec4"),this.colorNode=t,this.toneMapping=e,this.outputColorSpace=i,this.isRenderOutput=!0}setup({context:t}){let e=this.colorNode||t.color;const i=this.toneMapping!==null?this.toneMapping:t.toneMapping,s=this.outputColorSpace!==null?this.outputColorSpace:t.outputColorSpace;return i!==Tn&&(e=e.toneMapping(i)),s===j&&(e=e.linearToColorSpace(s)),e}}const fv=(o,t=null,e=null)=>L(new pv(L(o),t,e));N("renderOutput",fv);O("RenderOutputNode",pv);class oF extends st{constructor(t,e,i,s,n,r){super(),this.textureNode=t,this.depthNode=e,this.normalNode=i,this.pixelSize=s,this.normalEdgeStrength=n,this.depthEdgeStrength=r,this._resolution=H(new _t),this.updateBeforeType=Y.RENDER}updateBefore(){const t=this.textureNode.value,e=t.image.width,i=t.image.height;this._resolution.value.set(e,i,1/e,1/i)}setup(){const{textureNode:t,depthNode:e,normalNode:i}=this,s=t.uvNode||Nt(),n=e.uvNode||Nt(),r=i.uvNode||Nt(),a=()=>t.uv(s),l=(m,g)=>e.uv(n.add(F(m,g).mul(this._resolution.zw))).r,h=(m,g)=>i.uv(r.add(F(m,g).mul(this._resolution.zw))).rgb.normalize(),u=m=>{const g=Tt("float","diff");return g.addAssign(Me(l(1,0).sub(m))),g.addAssign(Me(l(-1,0).sub(m))),g.addAssign(Me(l(0,1).sub(m))),g.addAssign(Me(l(0,-1).sub(m))),ba(Je(.01,.02,g).mul(2)).div(2)},c=(m,g,y,x)=>{const M=l(m,g).sub(y),_=h(m,g),v=P(1,1,1),A=oe(x.sub(_),v),T=Me(Je(-.01,.01,A),0,1),w=Me(Kh(M.mul(.25).add(.0025)),0,1);return C(1).sub(oe(x,_)).mul(w).mul(T)},d=(m,g)=>{const y=Tt("float","indicator");return y.addAssign(c(0,-1,m,g)),y.addAssign(c(0,1,m,g)),y.addAssign(c(-1,0,m,g)),y.addAssign(c(1,0,m,g)),$_(.1,y)};return z(()=>{const m=a(),g=Tt("float","depth"),y=Tt("vec3","normal");it(this.depthEdgeStrength.greaterThan(0).or(this.normalEdgeStrength.greaterThan(0)),()=>{g.assign(l(0,0)),y.assign(h(0,0))});const x=Tt("float","dei");it(this.depthEdgeStrength.greaterThan(0),()=>{x.assign(u(g))});const M=Tt("float","nei");it(this.normalEdgeStrength.greaterThan(0),()=>{M.assign(d(g,y))});const _=x.greaterThan(0).cond(C(1).sub(x.mul(this.depthEdgeStrength)),M.mul(this.normalEdgeStrength).add(1));return m.mul(_)})()}}const aF=(o,t,e,i=6,s=.3,n=.4)=>L(new oF(L(o).toTexture(),L(t).toTexture(),L(e).toTexture(),L(i),L(s),L(n)));N("pixelation",aF);class mv extends st{constructor(t=null,e={}){super(),this.functionNode=t,this.parameters=e}setParameters(t){return this.parameters=t,this}getParameters(){return this.parameters}getNodeType(t){return this.functionNode.getNodeType(t)}generate(t){const e=[],i=this.functionNode,s=i.getInputs(t),n=this.parameters;if(Array.isArray(n))for(let a=0;a<n.length;a++){const l=s[a],h=n[a];e.push(h.build(t,l.type))}else for(const a of s){const l=n[a.name];if(l!==void 0)e.push(l.build(t,a.type));else throw new Error(`FunctionCallNode: Input '${a.name}' not found in FunctionNode.`)}return`${i.build(t,"property")}( ${e.join(", ")} )`}}const lF=(o,...t)=>(t=t.length>1||t[0]&&t[0].isNode===!0?Dr(t):Zh(t[0]),L(new mv(L(o),t)));N("call",lF);O("FunctionCallNode",mv);class gv extends X{constructor(t=null){super(),this._value=t,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new Hs,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return this.outputType!==null}set value(t){this._value!==t&&(this._cache&&this.inputType==="URL"&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=t,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const t=this.value;if(t&&this._cache===null&&this.inputType==="URL"&&t.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([t.value]));else if(t&&t.value!==null&&t.value!==void 0&&((this.inputType==="URL"||this.inputType==="String")&&typeof t.value=="string"||this.inputType==="Number"&&typeof t.value=="number"||this.inputType==="Vector2"&&t.value.isVector2||this.inputType==="Vector3"&&t.value.isVector3||this.inputType==="Vector4"&&t.value.isVector4||this.inputType==="Color"&&t.value.isColor||this.inputType==="Matrix3"&&t.value.isMatrix3||this.inputType==="Matrix4"&&t.value.isMatrix4))return t.value;return this._cache||t}getNodeType(t){return this.value&&this.value.isNode?this.value.getNodeType(t):"float"}setup(){return this.value&&this.value.isNode?this.value:C()}serialize(t){super.serialize(t),this.value!==null?this.inputType==="ArrayBuffer"?t.value=m_(this.value):t.value=this.value?this.value.toJSON(t.meta).uuid:null:t.value=null,t.inputType=this.inputType,t.outputType=this.outputType}deserialize(t){super.deserialize(t);let e=null;t.value!==null&&(t.inputType==="ArrayBuffer"?e=g_(t.value):t.inputType==="Texture"?e=t.meta.textures[t.value]:e=t.meta.nodes[t.value]||null),this.value=e,this.inputType=t.inputType,this.outputType=t.outputType}}const Kl=I(gv);N("scriptableValue",Kl);O("ScriptableValueNode",gv);class yv extends Map{get(t,e=null,...i){if(this.has(t))return super.get(t);if(e!==null){const s=e(...i);return this.set(t,s),s}}}class hF{constructor(t){this.scriptableNode=t}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(t){return this.scriptableNode.getInputLayout(t)}get(t){const e=this.parameters[t];return e?e.getValue():null}}const Bc=new yv;class xv extends X{constructor(t=null,e={}){super(),this.codeNode=t,this.parameters=e,this._local=new yv,this._output=Kl(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(t,e){return this._local.set(t,e)}getLocal(t){return this._local.get(t)}onRefresh(){this._refresh()}getInputLayout(t){for(const e of this.getLayout())if(e.inputType&&(e.id===t||e.name===t))return e}getOutputLayout(t){for(const e of this.getLayout())if(e.outputType&&(e.id===t||e.name===t))return e}setOutput(t,e){const i=this._outputs;return i[t]===void 0?i[t]=Kl(e):i[t].value=e,this}getOutput(t){return this._outputs[t]}getParameter(t){return this.parameters[t]}setParameter(t,e){const i=this.parameters;return e&&e.isScriptableNode?(this.deleteParameter(t),i[t]=e,i[t].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):e&&e.isScriptableValueNode?(this.deleteParameter(t),i[t]=e,i[t].events.addEventListener("refresh",this.onRefresh)):i[t]===void 0?(i[t]=Kl(e),i[t].events.addEventListener("refresh",this.onRefresh)):i[t].value=e,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(t){let e=this.parameters[t];return e&&(e.isScriptableNode&&(e=e.getDefaultOutput()),e.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const t of Object.keys(this.parameters))this.deleteParameter(t);return this.needsUpdate=!0,this}call(t,...e){const s=this.getObject()[t];if(typeof s=="function")return s(...e)}async callAsync(t,...e){const s=this.getObject()[t];if(typeof s=="function")return s.constructor.name==="AsyncFunction"?await s(...e):s(...e)}getNodeType(t){return this.getDefaultOutputNode().getNodeType(t)}refresh(t=null){t!==null?this.getOutput(t).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),this._object!==null)return this._object;const t=()=>this.refresh(),e=(h,u)=>this.setOutput(h,u),i=new hF(this),s=Bc.get("THREE"),n=Bc.get("TSL"),r=this.getMethod(this.codeNode),a=[i,this._local,Bc,t,e,s,n];this._object=r(...a);const l=this._object.layout;if(l&&(l.cache===!1&&this._local.clear(),this._output.outputType=l.outputType||null,Array.isArray(l.elements)))for(const h of l.elements){const u=h.id||h.name;h.inputType&&(this.getParameter(u)===void 0&&this.setParameter(u,null),this.getParameter(u).inputType=h.inputType),h.outputType&&(this.getOutput(u)===void 0&&this.setOutput(u,null),this.getOutput(u).outputType=h.outputType)}return this._object}deserialize(t){super.deserialize(t);for(const e in this.parameters){let i=this.parameters[e];i.isScriptableNode&&(i=i.getDefaultOutput()),i.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const t=this.getDefaultOutput().value;return t&&t.isNode?t:C()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),this._method!==null)return this._method;const t=["parameters","local","global","refresh","setOutput","THREE","TSL"],i=["layout","init","main","dispose"].join(", "),s="var "+i+`; var output = {};
`,n=`
return { ...output, `+i+" };",r=s+this.codeNode.code+n;return this._method=new Function(...t,r),this._method}dispose(){this._method!==null&&(this._object&&typeof this._object.dispose=="function"&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}getCacheKey(t){const e=[this.source,this.getDefaultOutputNode().getCacheKey(t)];for(const i in this.parameters)e.push(this.parameters[i].getCacheKey(t));return e.join(",")}set needsUpdate(t){t===!0&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return this.codeNode===null?this:(this._needsOutputUpdate===!0&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value,this)}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const uF=I(xv);N("scriptable",uF);O("ScriptableNode",xv);class ou extends X{constructor(t,e){super("float"),this.isFogNode=!0,this.colorNode=t,this.factorNode=e}getViewZNode(t){let e;const i=t.context.getViewZ;return i!==void 0&&(e=i(this)),(e||ve.z).negate()}setup(){return this.factorNode}}const cF=I(ou);N("fog",cF);O("FogNode",ou);class _v extends ou{constructor(t,e,i){super(t),this.isFogRangeNode=!0,this.nearNode=e,this.farNode=i}setup(t){const e=this.getViewZNode(t);return Je(this.nearNode,this.farNode,e)}}const Mv=I(_v);N("rangeFog",Mv);O("FogRangeNode",_v);class vv extends ou{constructor(t,e){super(t),this.isFogExp2Node=!0,this.densityNode=e}setup(t){const e=this.getViewZNode(t),i=this.densityNode;return i.mul(i,e,e).negate().exp().oneMinus()}}const Tv=I(vv);N("densityFog",Tv);O("FogExp2Node",vv);let rn=null,on=null;class bv extends X{constructor(t=C(),e=C()){super(),this.minNode=t,this.maxNode=e}getVectorLength(t){const e=t.getTypeLength(Os(this.minNode.value)),i=t.getTypeLength(Os(this.maxNode.value));return e>i?e:i}getNodeType(t){return t.object.count>1?t.getTypeFromLength(this.getVectorLength(t)):"float"}setup(t){const e=t.object;let i=null;if(e.count>1){const s=this.minNode.value,n=this.maxNode.value,r=t.getTypeLength(Os(s)),a=t.getTypeLength(Os(n));rn=rn||new _t,on=on||new _t,rn.setScalar(0),on.setScalar(0),r===1?rn.setScalar(s):s.isColor?rn.set(s.r,s.g,s.b):rn.set(s.x,s.y,s.z||0,s.w||0),a===1?on.setScalar(n):n.isColor?on.set(n.r,n.g,n.b):on.set(n.x,n.y,n.z||0,n.w||0);const l=4,h=l*e.count,u=new Float32Array(h);for(let d=0;d<h;d++){const p=d%l,f=rn.getComponent(p),m=on.getComponent(p);u[d]=z0.lerp(f,m,Math.random())}const c=this.getNodeType(t);if(e.count<=4096)i=iu(u,"vec4",e.count).element(Qh).convert(c);else{const d=new t_(u,4);t.geometry.setAttribute("__range"+this.id,d),i=Qd(d).convert(c)}}else i=C(0);return i}}I(bv);O("RangeNode",bv);class Sv extends X{constructor(t,e,i=[64]){super("void"),this.isComputeNode=!0,this.computeNode=t,this.count=e,this.workgroupSize=i,this.dispatchCount=0,this.version=1,this.updateBeforeType=Y.OBJECT,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}updateDispatchCount(){const{count:t,workgroupSize:e}=this;let i=e[0];for(let s=1;s<e.length;s++)i*=e[s];this.dispatchCount=Math.ceil(t/i)}onInit(){}updateBefore({renderer:t}){t.compute(this)}generate(t){const{shaderStage:e}=t;if(e==="compute"){const i=this.computeNode.build(t,"void");i!==""&&t.addLineFlowCode(i)}}}const dF=(o,t,e)=>L(new Sv(L(o),t,e));N("compute",dF);O("ComputeNode",Sv);class wn extends X{constructor(t=wn.TARGET_DIRECTION,e=null){super(),this.scope=t,this.light=e}setup(){const{scope:t,light:e}=this;let i=null;return t===wn.TARGET_DIRECTION&&(i=Pn.transformDirection(jd(e).sub(jd(e.target)))),i}serialize(t){super.serialize(t),t.scope=this.scope}deserialize(t){super.deserialize(t),this.scope=t.scope}}wn.TARGET_DIRECTION="targetDirection";const wv=I(wn,wn.TARGET_DIRECTION);O("LightNode",wn);const Av=z(o=>{const{lightDistance:t,cutoffDistance:e,decayExponent:i}=o,s=t.pow(i).max(.01).reciprocal();return e.greaterThan(0).cond(s.mul(t.div(e).pow4().oneMinus().clamp().pow2()),s)});class Nv extends $s{constructor(t=null){super(t),this.cutoffDistanceNode=H(0),this.decayExponentNode=H(0)}update(t){const{light:e}=this;super.update(t),this.cutoffDistanceNode.value=e.distance,this.decayExponentNode.value=e.decay}setup(t){const{colorNode:e,cutoffDistanceNode:i,decayExponentNode:s,light:n}=this,r=t.context.lightingModel,a=nf(n).sub(ve),l=a.normalize(),h=a.length(),u=Av({lightDistance:h,cutoffDistance:i,decayExponent:s}),c=e.mul(u),d=t.context.reflectedLight;r.direct({lightDirection:l,lightColor:c,reflectedLight:d},t.stack,t)}}O("PointLightNode",Nv);In(Z1,Nv);class Rv extends $s{constructor(t=null){super(t)}setup(t){super.setup(t);const e=t.context.lightingModel,i=this.colorNode,s=wv(this.light),n=t.context.reflectedLight;e.direct({lightDirection:s,lightColor:i,reflectedLight:n},t.stack,t)}}O("DirectionalLightNode",Rv);In(J1,Rv);const Lc=new Bt,Pl=new Bt;let Fo=null;class Ev extends $s{constructor(t=null){super(t),this.halfHeight=H(new E),this.halfWidth=H(new E)}update(t){super.update(t);const{light:e}=this,i=t.camera.matrixWorldInverse;Pl.identity(),Lc.copy(e.matrixWorld),Lc.premultiply(i),Pl.extractRotation(Lc),this.halfWidth.value.set(e.width*.5,0,0),this.halfHeight.value.set(0,e.height*.5,0),this.halfWidth.value.applyMatrix4(Pl),this.halfHeight.value.applyMatrix4(Pl)}setup(t){super.setup(t);let e,i;t.isAvailable("float32Filterable")?(e=gt(Fo.LTC_FLOAT_1),i=gt(Fo.LTC_FLOAT_2)):(e=gt(Fo.LTC_HALF_1),i=gt(Fo.LTC_HALF_2));const{colorNode:s,light:n}=this,r=t.context.lightingModel,a=nf(n),l=t.context.reflectedLight;r.directRectArea({lightColor:s,lightPosition:a,halfWidth:this.halfWidth,halfHeight:this.halfHeight,reflectedLight:l,ltc_1:e,ltc_2:i},t.stack,t)}static setLTC(t){Fo=t}}O("RectAreaLightNode",Ev);In(tA,Ev);class gf extends $s{constructor(t=null){super(t),this.coneCosNode=H(0),this.penumbraCosNode=H(0),this.cutoffDistanceNode=H(0),this.decayExponentNode=H(0)}update(t){super.update(t);const{light:e}=this;this.coneCosNode.value=Math.cos(e.angle),this.penumbraCosNode.value=Math.cos(e.angle*(1-e.penumbra)),this.cutoffDistanceNode.value=e.distance,this.decayExponentNode.value=e.decay}getSpotAttenuation(t){const{coneCosNode:e,penumbraCosNode:i}=this;return Je(e,i,t)}setup(t){super.setup(t);const e=t.context.lightingModel,{colorNode:i,cutoffDistanceNode:s,decayExponentNode:n,light:r}=this,a=nf(r).sub(ve),l=a.normalize(),h=l.dot(wv(r)),u=this.getSpotAttenuation(h),c=a.length(),d=Av({lightDistance:c,cutoffDistance:s,decayExponent:n}),p=i.mul(u).mul(d),f=t.context.reflectedLight;e.direct({lightDirection:l,lightColor:p,reflectedLight:f},t.stack,t)}}O("SpotLightNode",gf);In(u_,gf);class pF extends u_{constructor(t,e,i,s,n,r){super(t,e,i,s,n,r),this.iesMap=null}copy(t,e){return super.copy(t,e),this.iesMap=t.iesMap,this}}class Cv extends gf{getSpotAttenuation(t){const e=this.light.iesMap;let i=null;if(e&&e.isTexture===!0){const s=t.acos().mul(1/Math.PI);i=gt(e,F(s,0),0).r}else i=super.getSpotAttenuation(t);return i}}O("IESSpotLightNode",Cv);In(pF,Cv);class Pv extends $s{constructor(t=null){super(t)}setup({context:t}){t.irradiance.addAssign(this.colorNode)}}O("AmbientLightNode",Pv);In(K1,Pv);class Fv extends $s{constructor(t=null){super(t),this.lightPositionNode=jd(t),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=H(new nt)}update(t){const{light:e}=this;super.update(t),this.lightPositionNode.object3d=e,this.groundColorNode.value.copy(e.groundColor).multiplyScalar(e.intensity)}setup(t){const{colorNode:e,groundColorNode:i,lightDirectionNode:s}=this,r=us.dot(s).mul(.5).add(.5),a=K(i,e,r);t.context.irradiance.addAssign(a)}}O("HemisphereLightNode",Fv);In(j1,Fv);let Ih=null;const Ey=new WeakMap;function fF(o){const t=Math.log2(o)-2,e=1/o;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:e,maxMip:t}}function mF(o){let t=Ey.get(o);if((t!==void 0?t.pmremVersion:-1)!==o.pmremVersion){if(o.isCubeTexture){if(o.source.data.some(i=>i===void 0))throw new Error("PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader");t=Ih.fromCubemap(o,t)}else{if(o.image===void 0)throw new Error("PMREMNode: Undefined image in Texture. Use onLoad callback or async loader");t=Ih.fromEquirectangular(o,t)}t.pmremVersion=o.pmremVersion,Ey.set(o,t)}return t.texture}class Iv extends st{constructor(t,e=null,i=null){super("vec3"),this._value=t,this._pmrem=null,this.uvNode=e,this.levelNode=i,this._generator=null,this._texture=gt(null),this._width=H(0),this._height=H(0),this._maxMip=H(0),this.updateBeforeType=Y.RENDER}set value(t){this._value=t,this._pmrem=null}get value(){return this._value}updateFromTexture(t){const e=fF(t.image.height);this._texture.value=t,this._width.value=e.texelWidth,this._height.value=e.texelHeight,this._maxMip.value=e.maxMip}updateBefore(){let t=this._pmrem;const e=t?t.pmremVersion:-1,i=this._value;e!==i.pmremVersion&&(i.isPMREMTexture===!0?t=i:t=mF(i),this._pmrem=t,this.updateFromTexture(t))}setup(t){Ih===null&&(Ih=t.createPMREMGenerator()),this.updateBefore(t);let e=this.uvNode;e===null&&t.context.getUV&&(e=t.context.getUV(this));const i=this.value;t.renderer.coordinateSystem===bi&&i.isPMREMTexture!==!0&&i.isRenderTargetTexture===!0&&(e=P(e.x.negate(),e.yz));let s=this.levelNode;return s===null&&t.context.getTextureLevel&&(s=t.context.getTextureLevel(this)),JE(this._texture,e,s,this._width,this._height,this._maxMip)}}const Bv=I(Iv);O("PMREMNode",Iv);const Cy=new WeakMap;class Lv extends Fn{constructor(t=null){super(),this.envNode=t}setup(t){let e=this.envNode;if(e.isTextureNode){let p=Cy.get(e.value);p===void 0&&(p=Bv(e.value),Cy.set(e.value,p)),e=p}const{material:i}=t,n=i.envMap?Wt("envMapIntensity","float",t.material):Wt("environmentIntensity","float",t.scene),a=i.useAnisotropy===!0||i.anisotropy>0?CC:Ct,l=zr(e,Py(ns,a)).mul(n),h=zr(e,gF(iM)).mul(Math.PI).mul(n),u=Xl(l),c=Xl(h);t.context.radiance.addAssign(u),t.context.iblIrradiance.addAssign(c);const d=t.context.lightingModel.clearcoatRadiance;if(d){const p=zr(e,Py(Ah,Cr)).mul(n),f=Xl(p);d.addAssign(f)}}}const Py=(o,t)=>{let e=null;return{getUV:()=>(e===null&&(e=Ft.negate().reflect(t),e=o.mul(o).mix(e,t).normalize(),e=e.transformDirection(Pn)),e),getTextureLevel:()=>o}},gF=o=>({getUV:()=>o,getTextureLevel:()=>C(1)});O("EnvironmentNode",Lv);class au extends Fn{constructor(t=null){super(),this.envNode=t}setup(t){t.context.environment=this.envNode}}O("BasicEnvironmentNode",au);const yF=z(o=>{const t=o.uv.mul(2),e=t.x.floor(),i=t.y.floor();return e.add(i).mod(2).sign()});class Uv extends st{constructor(t=Nt()){super("float"),this.uvNode=t}setup(){return yF({uv:this.uvNode})}}const xF=I(Uv);N("checker",xF);O("CheckerNode",Uv);const _F=new s_;class MF extends Dt{constructor(t={}){super(),this.normals=!1,this.lights=!1,this.useAlphaToCoverage=!0,this.useColor=t.vertexColors,this.pointWidth=1,this.pointColorNode=null,this.setDefaultValues(_F),this.setupShaders(),this.setValues(t)}setupShaders(){const t=this.alphaToCoverage,e=this.useColor;this.vertexNode=z(()=>{$t(F(),"vUv").assign(Nt());const i=le("instancePosition"),s=Tt("vec4","mvPos");s.assign(ks.mul(G(i,1)));const n=Gr.z.div(Gr.w),r=vi.mul(s),a=Tt("vec2","offset");return a.assign(Ae.xy),a.assign(a.mul(sE)),a.assign(a.div(Gr.z)),a.y.assign(a.y.mul(n)),a.assign(a.mul(r.w)),r.assign(r.add(G(a,0,0))),r})(),this.fragmentNode=z(()=>{const i=$t(F(),"vUv"),s=Tt("float","alpha");s.assign(1);const n=i.x,r=i.y,a=n.mul(n).add(r.mul(r));if(t){const h=Tt("float","dlen");h.assign(a.fwidth()),s.assign(Je(h.oneMinus(),h.add(1),a).oneMinus())}else a.greaterThan(1).discard();let l;return this.pointColorNode?l=this.pointColorNode:e?l=le("instanceColor").mul(la):l=la,G(l,s)})(),this.needsUpdate=!0}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(t){this.useAlphaToCoverage!==t&&(this.useAlphaToCoverage=t,this.setupShaders())}}ee("InstancedPointsNodeMaterial",MF);const vF=new i_;class TF extends Dt{constructor(t){super(),this.isLineBasicNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(vF),this.setValues(t)}}ee("LineBasicNodeMaterial",TF);const bF=new o_;class SF extends Dt{constructor(t){super(),this.isLineDashedNodeMaterial=!0,this.lights=!1,this.normals=!1,this.setDefaultValues(bF),this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(t)}setupVariants(){const t=this.offsetNode,e=this.dashScaleNode?C(this.dashScaleNode):Xd,i=this.dashSizeNode?C(this.dashSizeNode):rM,s=this.dashSizeNode?C(this.dashGapNode):oM;kr.assign(i),Rh.assign(s);const n=$t(le("lineDistance").mul(e));(t?n.add(t):n).mod(kr.add(Rh)).greaterThan(kr).discard()}}ee("LineDashedNodeMaterial",SF);const wF=new o_;class AF extends Dt{constructor(t={}){super(),this.normals=!1,this.lights=!1,this.setDefaultValues(wF),this.useAlphaToCoverage=!0,this.useColor=t.vertexColors,this.useDash=t.dashed,this.useWorldUnits=!1,this.dashOffset=0,this.lineWidth=1,this.lineColorNode=null,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(t)}setup(t){this.setupShaders(),super.setup(t)}setupShaders(){const t=this.alphaToCoverage,e=this.useColor,i=this.dashed,s=this.worldUnits,n=z(({start:a,end:l})=>{const h=vi.element(2).element(2),d=vi.element(3).element(2).mul(-.5).div(h).sub(a.z).div(l.z.sub(a.z));return G(K(a.xyz,l.xyz,d),l.w)});this.vertexNode=z(()=>{Pi("vec2","vUv").assign(Nt());const a=le("instanceStart"),l=le("instanceEnd"),h=Tt("vec4","start"),u=Tt("vec4","end");h.assign(ks.mul(G(a,1))),u.assign(ks.mul(G(l,1))),s&&(Pi("vec3","worldStart").assign(h.xyz),Pi("vec3","worldEnd").assign(u.xyz));const c=Gr.z.div(Gr.w),d=vi.element(2).element(3).equal(-1);it(d,()=>{it(h.z.lessThan(0).and(u.z.greaterThan(0)),()=>{u.assign(n({start:h,end:u}))}).elseif(u.z.lessThan(0).and(h.z.greaterThanEqual(0)),()=>{h.assign(n({start:u,end:h}))})});const p=vi.mul(h),f=vi.mul(u),m=p.xyz.div(p.w),g=f.xyz.div(f.w),y=g.xy.sub(m.xy).temp();y.x.assign(y.x.mul(c)),y.assign(y.normalize());const x=Sh(G());if(s){const M=u.xyz.sub(h.xyz).normalize(),_=K(h.xyz,u.xyz,.5).normalize(),v=M.cross(_).normalize(),A=M.cross(v),T=Pi("vec4","worldPos");T.assign(Ae.y.lessThan(.5).cond(h,u));const w=dc.mul(.5);T.addAssign(G(Ae.x.lessThan(0).cond(v.mul(w),v.mul(w).negate()),0)),i||(T.addAssign(G(Ae.y.lessThan(.5).cond(M.mul(w).negate(),M.mul(w)),0)),T.addAssign(G(A.mul(w),0)),it(Ae.y.greaterThan(1).or(Ae.y.lessThan(0)),()=>{T.subAssign(G(A.mul(2).mul(w),0))})),x.assign(vi.mul(T));const U=Sh(P());U.assign(Ae.y.lessThan(.5).cond(m,g)),x.z.assign(U.z.mul(x.w))}else{const M=Tt("vec2","offset");M.assign(F(y.y,y.x.negate())),y.x.assign(y.x.div(c)),M.x.assign(M.x.div(c)),M.assign(Ae.x.lessThan(0).cond(M.negate(),M)),it(Ae.y.lessThan(0),()=>{M.assign(M.sub(y))}).elseif(Ae.y.greaterThan(1),()=>{M.assign(M.add(y))}),M.assign(M.mul(dc)),M.assign(M.div(Gr.w)),x.assign(Ae.y.lessThan(.5).cond(p,f)),M.assign(M.mul(x.w)),x.assign(x.add(G(M,0,0)))}return x})();const r=z(({p1:a,p2:l,p3:h,p4:u})=>{const c=a.sub(h),d=u.sub(h),p=l.sub(a),f=c.dot(d),m=d.dot(p),g=c.dot(p),y=d.dot(d),M=p.dot(p).mul(y).sub(m.mul(m)),v=f.mul(m).sub(g.mul(y)).div(M).clamp(),A=f.add(m.mul(v)).div(y).clamp();return F(v,A)});this.fragmentNode=z(()=>{const a=Pi("vec2","vUv");if(i){const u=this.offsetNode?C(this.offsetNodeNode):ty,c=this.dashScaleNode?C(this.dashScaleNode):Xd,d=this.dashSizeNode?C(this.dashSizeNode):rM,p=this.dashSizeNode?C(this.dashGapNode):oM;kr.assign(d),Rh.assign(p);const f=le("instanceDistanceStart"),m=le("instanceDistanceEnd"),g=Ae.y.lessThan(.5).cond(c.mul(f),Xd.mul(m)),y=$t(g.add(ty)),x=u?y.add(u):y;a.y.lessThan(-1).or(a.y.greaterThan(1)).discard(),x.mod(kr.add(Rh)).greaterThan(kr).discard()}const l=Tt("float","alpha");if(l.assign(1),s){const u=Pi("vec3","worldStart"),c=Pi("vec3","worldEnd"),d=Pi("vec4","worldPos").xyz.normalize().mul(1e5),p=c.sub(u),f=r({p1:u,p2:c,p3:P(0,0,0),p4:d}),m=u.add(p.mul(f.x)),g=d.mul(f.y),M=m.sub(g).length().div(dc);if(!i)if(t){const _=M.fwidth();l.assign(Je(_.negate().add(.5),_.add(.5),M).oneMinus())}else M.greaterThan(.5).discard()}else if(t){const u=a.x,c=a.y.greaterThan(0).cond(a.y.sub(1),a.y.add(1)),d=u.mul(u).add(c.mul(c)),p=Tt("float","dlen");p.assign(d.fwidth()),it(a.y.abs().greaterThan(1),()=>{l.assign(Je(p.oneMinus(),p.add(1),d).oneMinus())})}else it(a.y.abs().greaterThan(1),()=>{const u=a.x,c=a.y.greaterThan(0).cond(a.y.sub(1),a.y.add(1));u.mul(u).add(c.mul(c)).greaterThan(1).discard()});let h;if(this.lineColorNode)h=this.lineColorNode;else if(e){const u=le("instanceColorStart"),c=le("instanceColorEnd");h=Ae.y.lessThan(.5).cond(u,c).mul(la)}else h=la;return G(h,l)})()}get worldUnits(){return this.useWorldUnits}set worldUnits(t){this.useWorldUnits!==t&&(this.useWorldUnits=t,this.needsUpdate=!0)}get dashed(){return this.useDash}set dashed(t){this.useDash!==t&&(this.useDash=t,this.needsUpdate=!0)}get alphaToCoverage(){return this.useAlphaToCoverage}set alphaToCoverage(t){this.useAlphaToCoverage!==t&&(this.useAlphaToCoverage=t,this.needsUpdate=!0)}}ee("Line2NodeMaterial",AF);const NF=new D1;class RF extends Dt{constructor(t){super(),this.lights=!1,this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(NF),this.setValues(t)}setupDiffuseColor(){const t=this.opacityNode?C(this.opacityNode):sM;pt.assign(G(HM(Ct),t))}}ee("MeshNormalNodeMaterial",RF);class Dv extends Fn{constructor(t=null){super(),this.lightMapNode=t}setup(t){const e=C(1/Math.PI);t.context.irradianceLightMap=this.lightMapNode.mul(e)}}O("BasicLightMapNode",Dv);class Ov extends Ta{constructor(){super()}indirect(t,e,i){const s=t.ambientOcclusion,n=t.reflectedLight,r=i.context.irradianceLightMap;n.indirectDiffuse.assign(G(0)),r?n.indirectDiffuse.addAssign(r):n.indirectDiffuse.addAssign(G(1,1,1,0)),n.indirectDiffuse.mulAssign(s),n.indirectDiffuse.mulAssign(pt.rgb)}finish(t,e,i){const s=i.material,n=t.outgoingLight,r=i.context.environment;if(r)switch(s.combine){case Hh:n.rgb.assign(K(n.rgb,n.rgb.mul(r.rgb),Ql.mul(cc)));break;case uw:n.rgb.assign(K(n.rgb,r.rgb,Ql.mul(cc)));break;case cw:n.rgb.addAssign(r.rgb.mul(Ql.mul(cc)));break;default:console.warn("THREE.BasicLightingModel: Unsupported .combine value:",s.combine);break}}}const EF=new Vp;class CF extends Dt{constructor(t){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!0,this.setDefaultValues(EF),this.setValues(t)}setupNormal(){Ct.assign(us)}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new au(e):null}setupLightMap(t){let e=null;return t.material.lightMap&&(e=new Dv(aM)),e}setupOutgoingLight(){return pt.rgb}setupLightingModel(){return new Ov}}ee("MeshBasicNodeMaterial",CF);const ua=z(({f0:o,f90:t,dotVH:e})=>{const i=e.mul(-5.55473).sub(6.98316).mul(e).exp2();return o.mul(i.oneMinus()).add(t.mul(i))}),cs=z(o=>o.diffuseColor.mul(1/Math.PI)),PF=()=>C(.25),FF=z(({dotNH:o})=>Gd.mul(C(.5)).add(1).mul(C(1/Math.PI)).mul(o.pow(Gd))),IF=z(({lightDirection:o})=>{const t=o.add(Ft).normalize(),e=Ct.dot(t).clamp(),i=Ft.dot(t).clamp(),s=ua({f0:He,f90:1,dotVH:i}),n=PF(),r=FF({dotNH:e});return s.mul(n).mul(r)});class zv extends Ov{constructor(t=!0){super(),this.specular=t}direct({lightDirection:t,lightColor:e,reflectedLight:i}){const n=Ct.dot(t).clamp().mul(e);i.directDiffuse.addAssign(n.mul(cs({diffuseColor:pt.rgb}))),this.specular===!0&&i.directSpecular.addAssign(n.mul(IF({lightDirection:t})).mul(Ql))}indirect({ambientOcclusion:t,irradiance:e,reflectedLight:i}){i.indirectDiffuse.addAssign(e.mul(cs({diffuseColor:pt}))),i.indirectDiffuse.mulAssign(t)}}const BF=new O1;class LF extends Dt{constructor(t){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(BF),this.setValues(t)}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new au(e):null}setupLightingModel(){return new zv(!1)}}ee("MeshLambertNodeMaterial",LF);const UF=new L1;class DF extends Dt{constructor(t){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(UF),this.setValues(t)}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new au(e):null}setupLightingModel(){return new zv}setupVariants(){const t=(this.shininessNode?C(this.shininessNode):UR).max(1e-4);Gd.assign(t);const e=this.specularNode||OR;He.assign(e)}copy(t){return this.shininessNode=t.shininessNode,this.specularNode=t.specularNode,super.copy(t)}}ee("MeshPhongNodeMaterial",DF);const OF=z(()=>{const o=Eh.dFdx().abs().max(Eh.dFdy().abs());return o.x.max(o.y).max(o.z)}),Vv=z(o=>{const{roughness:t}=o,e=OF();let i=t.max(.0525);return i=i.add(e),i=i.min(1),i}),zF=z(({alpha:o,dotNL:t,dotNV:e})=>{const i=o.pow2(),s=t.mul(i.add(i.oneMinus().mul(e.pow2())).sqrt()),n=e.mul(i.add(i.oneMinus().mul(t.pow2())).sqrt());return Oi(.5,s.add(n).max(O_))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),VF=z(({alphaT:o,alphaB:t,dotTV:e,dotBV:i,dotTL:s,dotBL:n,dotNV:r,dotNL:a})=>{const l=a.mul(P(o.mul(e),t.mul(i),r).length()),h=r.mul(P(o.mul(s),t.mul(n),a).length());return Oi(.5,l.add(h)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),kF=z(({alpha:o,dotNH:t})=>{const e=o.pow2(),i=t.pow2().mul(e.oneMinus()).oneMinus();return e.div(i.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),GF=C(1/Math.PI),WF=z(({alphaT:o,alphaB:t,dotNH:e,dotTH:i,dotBH:s})=>{const n=o.mul(t),r=P(t.mul(i),o.mul(s),n.mul(e)),a=r.dot(r),l=n.div(a);return GF.mul(n.mul(l.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),Fy=z(o=>{const{lightDirection:t,f0:e,f90:i,roughness:s,f:n,USE_IRIDESCENCE:r,USE_ANISOTROPY:a}=o,l=o.normalView||Ct,h=s.pow2(),u=t.add(Ft).normalize(),c=l.dot(t).clamp(),d=l.dot(Ft).clamp(),p=l.dot(u).clamp(),f=Ft.dot(u).clamp();let m=ua({f0:e,f90:i,dotVH:f}),g,y;if(Xg(r)&&(m=tf.mix(m,n)),Xg(a)){const x=Yl.dot(t),M=Yl.dot(Ft),_=Yl.dot(u),v=Vr.dot(t),A=Vr.dot(Ft),T=Vr.dot(u);g=VF({alphaT:kd,alphaB:h,dotTV:M,dotBV:A,dotTL:x,dotBL:v,dotNV:d,dotNL:c}),y=WF({alphaT:kd,alphaB:h,dotNH:p,dotTH:_,dotBH:T})}else g=zF({alpha:h,dotNL:c,dotNV:d}),y=kF({alpha:h,dotNH:p});return m.mul(g).mul(y)}),kv=z(({roughness:o,dotNV:t})=>{const e=G(-1,-.0275,-.572,.022),i=G(1,.0425,1.04,-.04),s=o.mul(e).add(i),n=s.x.mul(s.x).min(t.mul(-9.28).exp2()).mul(s.x).add(s.y);return F(-1.04,1.04).mul(n).add(s.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),Gv=z(o=>{const{dotNV:t,specularColor:e,specularF90:i,roughness:s}=o,n=kv({dotNV:t,roughness:s});return e.mul(n.x).add(i.mul(n.y))}),HF=z(({f:o,f90:t,dotVH:e})=>{const i=e.oneMinus().saturate(),s=i.mul(i),n=i.mul(s,s).clamp(0,.9999);return o.sub(P(t).mul(n)).div(n.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),$F=z(({roughness:o,dotNH:t})=>{const e=o.pow2(),i=C(1).div(e),n=t.pow2().oneMinus().max(.0078125);return C(2).add(i).mul(n.pow(i.mul(.5))).div(2*Math.PI)}).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),qF=z(({dotNV:o,dotNL:t})=>C(1).div(C(4).mul(t.add(o).sub(t.mul(o))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),jF=z(({lightDirection:o})=>{const t=o.add(Ft).normalize(),e=Ct.dot(o).clamp(),i=Ct.dot(Ft).clamp(),s=Ct.dot(t).clamp(),n=$F({roughness:Kp,dotNH:s}),r=qF({dotNV:i,dotNL:e});return Er.mul(n).mul(r)}),XF=z(({N:o,V:t,roughness:e})=>{const n=.0078125,r=o.dot(t).saturate(),a=F(e,r.oneMinus().sqrt());return a.assign(a.mul(.984375).add(n)),a}).setLayout({name:"LTC_Uv",type:"vec2",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"roughness",type:"float"}]}),YF=z(({f:o})=>{const t=o.length();return Et(t.mul(t).add(o.z).div(t.add(1)),0)}).setLayout({name:"LTC_ClippedSphereFormFactor",type:"float",inputs:[{name:"f",type:"vec3"}]}),Fl=z(({v1:o,v2:t})=>{const e=o.dot(t),i=e.abs().toVar(),s=i.mul(.0145206).add(.4965155).mul(i).add(.8543985).toVar(),n=i.add(4.1616724).mul(i).add(3.417594).toVar(),r=s.div(n),a=e.greaterThan(0).cond(r,Et(e.mul(e).oneMinus(),1e-7).inverseSqrt().mul(.5).sub(r));return o.cross(t).mul(a)}).setLayout({name:"LTC_EdgeVectorFormFactor",type:"vec3",inputs:[{name:"v1",type:"vec3"},{name:"v2",type:"vec3"}]}),Iy=z(({N:o,V:t,P:e,mInv:i,p0:s,p1:n,p2:r,p3:a})=>{const l=n.sub(s).toVar(),h=a.sub(s).toVar(),u=l.cross(h),c=P().toVar();return it(u.dot(e.sub(s)).greaterThanEqual(0),()=>{const d=t.sub(o.mul(t.dot(o))).normalize(),p=o.cross(d).negate(),f=i.mul(de(d,p,o).transpose()).toVar(),m=f.mul(s.sub(e)).normalize().toVar(),g=f.mul(n.sub(e)).normalize().toVar(),y=f.mul(r.sub(e)).normalize().toVar(),x=f.mul(a.sub(e)).normalize().toVar(),M=P(0).toVar();M.addAssign(Fl({v1:m,v2:g})),M.addAssign(Fl({v1:g,v2:y})),M.addAssign(Fl({v1:y,v2:x})),M.addAssign(Fl({v1:x,v2:m})),c.assign(P(YF({f:M})))}),c}).setLayout({name:"LTC_Evaluate",type:"vec3",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"P",type:"vec3"},{name:"mInv",type:"mat3"},{name:"p0",type:"vec3"},{name:"p1",type:"vec3"},{name:"p2",type:"vec3"},{name:"p3",type:"vec3"}]}),By=z(([o,t,e,i,s])=>{const n=P(j_(t.negate(),Mi(o),Oi(1,i))),r=P(_n(s[0].xyz),_n(s[1].xyz),_n(s[2].xyz));return Mi(n).mul(e.mul(r))}).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),ZF=z(([o,t])=>o.mul(Me(t.mul(2).sub(2),0,1))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),QF=SM(),Ly=z(([o,t,e])=>{const i=QF.uv(o),s=Jh(C(Jd.x)).mul(ZF(t,e));return i.bicubic(s)}),Uy=z(([o,t,e])=>(it(e.notEqual(0),()=>{const i=k_(t).negate().div(e);return V_(i.negate().mul(o))}),P(1))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),JF=z(([o,t,e,i,s,n,r,a,l,h,u,c,d,p,f])=>{let m,g;if(f){m=G().toVar(),g=P().toVar();const v=u.sub(1).mul(f.mul(.025)),A=P(u.sub(v),u,u.add(v));Te({start:0,end:3},({i:T})=>{const w=A.element(T),U=By(o,t,c,w,a),D=r.add(U),V=h.mul(l.mul(G(D,1))),W=F(V.xy.div(V.w)).toVar();W.addAssign(1),W.divAssign(2),W.assign(F(W.x,W.y.oneMinus()));const $=Ly(W,e,w);m.element(T).assign($.element(T)),m.a.addAssign($.a),g.element(T).assign(i.element(T).mul(Uy(_n(U),d,p).element(T)))}),m.a.divAssign(3)}else{const v=By(o,t,c,u,a),A=r.add(v),T=h.mul(l.mul(G(A,1))),w=F(T.xy.div(T.w)).toVar();w.addAssign(1),w.divAssign(2),w.assign(F(w.x,w.y.oneMinus())),m=Ly(w,e,u),g=i.mul(Uy(_n(v),d,p))}const y=g.rgb.mul(m.rgb),x=o.dot(t).clamp(),M=P(Gv({dotNV:x,specularColor:s,specularF90:n,roughness:e})),_=g.r.add(g.g,g.b).div(3);return G(M.oneMinus().mul(y),m.a.oneMinus().mul(_).oneMinus())}),KF=de(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),tI=o=>{const t=o.sqrt();return P(1).add(t).div(P(1).sub(t))},Dy=(o,t)=>o.sub(t).div(o.add(t)).pow2(),eI=(o,t)=>{const e=o.mul(2*Math.PI*1e-9),i=P(54856e-17,44201e-17,52481e-17),s=P(1681e3,1795300,2208400),n=P(43278e5,93046e5,66121e5),r=C(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(e.mul(2239900).add(t.x).cos()).mul(e.pow2().mul(-45282e5).exp());let a=i.mul(n.mul(2*Math.PI).sqrt()).mul(s.mul(e).add(t).cos()).mul(e.pow2().negate().mul(n).exp());return a=P(a.x.add(r),a.y,a.z).div(10685e-11),KF.mul(a)},iI=z(({outsideIOR:o,eta2:t,cosTheta1:e,thinFilmThickness:i,baseF0:s})=>{const n=K(o,t,Je(0,.03,i)),r=o.div(n).pow2().mul(C(1).sub(e.pow2())),l=C(1).sub(r).sqrt(),h=Dy(n,o),u=ua({f0:h,f90:1,dotVH:e}),c=u.oneMinus(),d=n.lessThan(o).cond(Math.PI,0),p=C(Math.PI).sub(d),f=tI(s.clamp(0,.9999)),m=Dy(f,n.toVec3()),g=ua({f0:m,f90:1,dotVH:l}),y=P(f.x.lessThan(n).cond(Math.PI,0),f.y.lessThan(n).cond(Math.PI,0),f.z.lessThan(n).cond(Math.PI,0)),x=n.mul(i,l,2),M=P(p).add(y),_=u.mul(g).clamp(1e-5,.9999),v=_.sqrt(),A=c.pow2().mul(g).div(P(1).sub(_));let w=u.add(A),U=A.sub(c);for(let D=1;D<=2;++D){U=U.mul(v);const V=eI(C(D).mul(x),C(D).mul(M)).mul(2);w=w.add(U.mul(V))}return w.max(P(0))}).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),sI=z(({normal:o,viewDir:t,roughness:e})=>{const i=o.dot(t).saturate(),s=e.pow2(),n=oi(e.lessThan(.25),C(-339.2).mul(s).add(C(161.4).mul(e)).sub(25.9),C(-8.48).mul(s).add(C(14.3).mul(e)).sub(9.95)),r=oi(e.lessThan(.25),C(44).mul(s).sub(C(23.7).mul(e)).add(3.26),C(1.97).mul(s).sub(C(3.27).mul(e)).add(.72));return oi(e.lessThan(.25),0,C(.1).mul(e).sub(.025)).add(n.mul(i).add(r).exp()).mul(1/Math.PI).saturate()}),Uc=P(.04),Dc=C(1);class yf extends Ta{constructor(t=!1,e=!1,i=!1,s=!1,n=!1,r=!1){super(),this.clearcoat=t,this.sheen=e,this.iridescence=i,this.anisotropy=s,this.transmission=n,this.dispersion=r,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null}start(t){if(this.clearcoat===!0&&(this.clearcoatRadiance=P().temp("clearcoatRadiance"),this.clearcoatSpecularDirect=P().temp("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=P().temp("clearcoatSpecularIndirect")),this.sheen===!0&&(this.sheenSpecularDirect=P().temp("sheenSpecularDirect"),this.sheenSpecularIndirect=P().temp("sheenSpecularIndirect")),this.iridescence===!0){const e=Ct.dot(Ft).clamp();this.iridescenceFresnel=iI({outsideIOR:C(1),eta2:E_,cosTheta1:e,thinFilmThickness:C_,baseF0:He}),this.iridescenceF0=HF({f:this.iridescenceFresnel,f90:1,dotVH:e})}if(this.transmission===!0){const e=Yd,i=eM.sub(Yd).normalize(),s=iM;t.backdrop=JF(s,i,ns,pt,He,Nh,e,aa,Pn,vi,Zl,P_,I_,F_,this.dispersion?B_:null),t.backdropAlpha=Wd,pt.a.mulAssign(K(1,t.backdrop.a,Wd))}}computeMultiscattering(t,e,i){const s=Ct.dot(Ft).clamp(),n=kv({roughness:ns,dotNV:s}),a=(this.iridescenceF0?tf.mix(He,this.iridescenceF0):He).mul(n.x).add(i.mul(n.y)),h=n.x.add(n.y).oneMinus(),u=He.add(He.oneMinus().mul(.047619)),c=a.mul(u).div(h.mul(u).oneMinus());t.addAssign(a),e.addAssign(c.mul(h))}direct({lightDirection:t,lightColor:e,reflectedLight:i}){const n=Ct.dot(t).clamp().mul(e);if(this.sheen===!0&&this.sheenSpecularDirect.addAssign(n.mul(jF({lightDirection:t}))),this.clearcoat===!0){const a=Cr.dot(t).clamp().mul(e);this.clearcoatSpecularDirect.addAssign(a.mul(Fy({lightDirection:t,f0:Uc,f90:Dc,roughness:Ah,normalView:Cr})))}i.directDiffuse.addAssign(n.mul(cs({diffuseColor:pt.rgb}))),i.directSpecular.addAssign(n.mul(Fy({lightDirection:t,f0:He,f90:1,roughness:ns,iridescence:this.iridescence,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}directRectArea({lightColor:t,lightPosition:e,halfWidth:i,halfHeight:s,reflectedLight:n,ltc_1:r,ltc_2:a}){const l=e.add(i).sub(s),h=e.sub(i).sub(s),u=e.sub(i).add(s),c=e.add(i).add(s),d=Ct,p=Ft,f=ve.toVar(),m=XF({N:d,V:p,roughness:ns}),g=r.uv(m).toVar(),y=a.uv(m).toVar(),x=de(P(g.x,0,g.y),P(0,1,0),P(g.z,0,g.w)).toVar(),M=He.mul(y.x).add(He.oneMinus().mul(y.y)).toVar();n.directSpecular.addAssign(t.mul(M).mul(Iy({N:d,V:p,P:f,mInv:x,p0:l,p1:h,p2:u,p3:c}))),n.directDiffuse.addAssign(t.mul(pt).mul(Iy({N:d,V:p,P:f,mInv:de(1,0,0,0,1,0,0,0,1),p0:l,p1:h,p2:u,p3:c})))}indirect(t,e,i){this.indirectDiffuse(t,e,i),this.indirectSpecular(t,e,i),this.ambientOcclusion(t,e,i)}indirectDiffuse({irradiance:t,reflectedLight:e}){e.indirectDiffuse.addAssign(t.mul(cs({diffuseColor:pt})))}indirectSpecular({radiance:t,iblIrradiance:e,reflectedLight:i}){if(this.sheen===!0&&this.sheenSpecularIndirect.addAssign(e.mul(Er,sI({normal:Ct,viewDir:Ft,roughness:Kp}))),this.clearcoat===!0){const h=Cr.dot(Ft).clamp(),u=Gv({dotNV:h,specularColor:Uc,specularF90:Dc,roughness:Ah});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(u))}const s=P().temp("singleScattering"),n=P().temp("multiScattering"),r=e.mul(1/Math.PI);this.computeMultiscattering(s,n,Nh);const a=s.add(n),l=pt.mul(a.r.max(a.g).max(a.b).oneMinus());i.indirectSpecular.addAssign(t.mul(s)),i.indirectSpecular.addAssign(n.mul(r)),i.indirectDiffuse.addAssign(l.mul(r))}ambientOcclusion({ambientOcclusion:t,reflectedLight:e}){const s=Ct.dot(Ft).clamp().add(t),n=ns.mul(-16).oneMinus().negate().exp2(),r=t.sub(s.pow(n).oneMinus()).clamp();this.clearcoat===!0&&this.clearcoatSpecularIndirect.mulAssign(t),this.sheen===!0&&this.sheenSpecularIndirect.mulAssign(t),e.indirectDiffuse.mulAssign(t),e.indirectSpecular.mulAssign(r)}finish(t){const{outgoingLight:e}=t;if(this.clearcoat===!0){const i=Cr.dot(Ft).clamp(),s=ua({dotVH:i,f0:Uc,f90:Dc}),n=e.mul(Vd.mul(s).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(Vd));e.assign(n)}if(this.sheen===!0){const i=Er.r.max(Er.g).max(Er.b).mul(.157).oneMinus(),s=e.mul(i).add(this.sheenSpecularDirect,this.sheenSpecularIndirect);e.assign(s)}}}const nI=new r_;class Wv extends Dt{constructor(t){super(),this.isMeshStandardNodeMaterial=!0,this.lights=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(nI),this.setValues(t)}setupEnvironment(t){const e=super.setupEnvironment(t);return e?new Lv(e):null}setupLightingModel(){return new yf}setupSpecular(){const t=K(P(.04),pt.rgb,wh);He.assign(t),Nh.assign(1)}setupVariants(){const t=this.metalnessNode?C(this.metalnessNode):kR;wh.assign(t);let e=this.roughnessNode?C(this.roughnessNode):VR;e=Vv({roughness:e}),ns.assign(e),this.setupSpecular(),pt.assign(G(pt.rgb.mul(t.oneMinus()),pt.a))}copy(t){return this.emissiveNode=t.emissiveNode,this.metalnessNode=t.metalnessNode,this.roughnessNode=t.roughnessNode,super.copy(t)}}ee("MeshStandardNodeMaterial",Wv);const rI=new B1;class Hv extends Wv{constructor(t){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.dispersionNode=null,this.anisotropyNode=null,this.setDefaultValues(rI),this.setValues(t)}get useClearcoat(){return this.clearcoat>0||this.clearcoatNode!==null}get useIridescence(){return this.iridescence>0||this.iridescenceNode!==null}get useSheen(){return this.sheen>0||this.sheenNode!==null}get useAnisotropy(){return this.anisotropy>0||this.anisotropyNode!==null}get useTransmission(){return this.transmission>0||this.transmissionNode!==null}get useDispersion(){return this.dispersion>0||this.dispersionNode!==null}setupSpecular(){const t=this.iorNode?C(this.iorNode):tE;Zl.assign(t),He.assign(K(Ui(q_(Zl.sub(1).div(Zl.add(1))).mul(zR),P(1)).mul(Kg),pt.rgb,wh)),Nh.assign(K(Kg,1,wh))}setupLightingModel(){return new yf(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission,this.useDispersion)}setupVariants(t){if(super.setupVariants(t),this.useClearcoat){const e=this.clearcoatNode?C(this.clearcoatNode):GR,i=this.clearcoatRoughnessNode?C(this.clearcoatRoughnessNode):WR;Vd.assign(e),Ah.assign(Vv({roughness:i}))}if(this.useSheen){const e=this.sheenNode?P(this.sheenNode):qR,i=this.sheenRoughnessNode?C(this.sheenRoughnessNode):jR;Er.assign(e),Kp.assign(i)}if(this.useIridescence){const e=this.iridescenceNode?C(this.iridescenceNode):YR,i=this.iridescenceIORNode?C(this.iridescenceIORNode):ZR,s=this.iridescenceThicknessNode?C(this.iridescenceThicknessNode):QR;tf.assign(e),E_.assign(i),C_.assign(s)}if(this.useAnisotropy){const e=(this.anisotropyNode?F(this.anisotropyNode):XR).toVar();cn.assign(e.length()),it(cn.equal(0),()=>{e.assign(F(1,0))}).else(()=>{e.divAssign(F(cn)),cn.assign(cn.saturate())}),kd.assign(cn.pow2().mix(ns.pow2(),1)),Yl.assign(Fr[0].mul(e.x).add(Fr[1].mul(e.y))),Vr.assign(Fr[1].mul(e.x).sub(Fr[0].mul(e.y)))}if(this.useTransmission){const e=this.transmissionNode?C(this.transmissionNode):JR,i=this.thicknessNode?C(this.thicknessNode):KR,s=this.attenuationDistanceNode?C(this.attenuationDistanceNode):eE,n=this.attenuationColorNode?P(this.attenuationColorNode):iE;if(Wd.assign(e),P_.assign(i),F_.assign(s),I_.assign(n),this.useDispersion){const r=this.dispersionNode?C(this.dispersionNode):nE;B_.assign(r)}}}setupNormal(t){super.setupNormal(t);const e=this.clearcoatNormalNode?P(this.clearcoatNormalNode):HR;Cr.assign(e)}copy(t){return this.clearcoatNode=t.clearcoatNode,this.clearcoatRoughnessNode=t.clearcoatRoughnessNode,this.clearcoatNormalNode=t.clearcoatNormalNode,this.sheenNode=t.sheenNode,this.sheenRoughnessNode=t.sheenRoughnessNode,this.iridescenceNode=t.iridescenceNode,this.iridescenceIORNode=t.iridescenceIORNode,this.iridescenceThicknessNode=t.iridescenceThicknessNode,this.specularIntensityNode=t.specularIntensityNode,this.specularColorNode=t.specularColorNode,this.transmissionNode=t.transmissionNode,this.thicknessNode=t.thicknessNode,this.attenuationDistanceNode=t.attenuationDistanceNode,this.attenuationColorNode=t.attenuationColorNode,this.dispersionNode=t.dispersionNode,this.anisotropyNode=t.anisotropyNode,super.copy(t)}}ee("MeshPhysicalNodeMaterial",Hv);class oI extends yf{constructor(t,e,i,s){super(t,e,i),this.useSSS=s}direct({lightDirection:t,lightColor:e,reflectedLight:i},s,n){if(this.useSSS===!0){const r=n.material,{thicknessColorNode:a,thicknessDistortionNode:l,thicknessAmbientNode:h,thicknessAttenuationNode:u,thicknessPowerNode:c,thicknessScaleNode:d}=r,p=t.add(Ct.mul(l)).normalize(),f=C(Ft.dot(p.negate()).saturate().pow(c).mul(d)),m=P(f.add(h).mul(a));i.directDiffuse.addAssign(m.mul(u.mul(e)))}super.direct({lightDirection:t,lightColor:e,reflectedLight:i},s,n)}}class aI extends Hv{constructor(t){super(t),this.thicknessColorNode=null,this.thicknessDistortionNode=C(.1),this.thicknessAmbientNode=C(0),this.thicknessAttenuationNode=C(.1),this.thicknessPowerNode=C(2),this.thicknessScaleNode=C(10)}get useSSS(){return this.thicknessColorNode!==null}setupLightingModel(){return new oI(this.useClearcoat,this.useSheen,this.useIridescence,this.useSSS)}copy(t){return this.thicknessColorNode=t.thicknessColorNode,this.thicknessDistortionNode=t.thicknessDistortionNode,this.thicknessAmbientNode=t.thicknessAmbientNode,this.thicknessAttenuationNode=t.thicknessAttenuationNode,this.thicknessPowerNode=t.thicknessPowerNode,this.thicknessScaleNode=t.thicknessScaleNode,super.copy(t)}}ee("MeshSSSNodeMaterial",aI);const lI=z(({normal:o,lightDirection:t,builder:e})=>{const i=o.dot(t),s=F(i.mul(.5).add(.5),0);if(e.material.gradientMap){const n=ct("gradientMap","texture").context({getUV:()=>s});return P(n.r)}else{const n=s.fwidth().mul(.5);return K(P(.7),P(1),Je(C(.7).sub(n.x),C(.7).add(n.x),s.x))}});class hI extends Ta{direct({lightDirection:t,lightColor:e,reflectedLight:i},s,n){const r=lI({normal:Eh,lightDirection:t,builder:n}).mul(e);i.directDiffuse.addAssign(r.mul(cs({diffuseColor:pt.rgb})))}indirect({ambientOcclusion:t,irradiance:e,reflectedLight:i}){i.indirectDiffuse.addAssign(e.mul(cs({diffuseColor:pt}))),i.indirectDiffuse.mulAssign(t)}}const uI=new U1;class cI extends Dt{constructor(t){super(),this.isMeshToonNodeMaterial=!0,this.lights=!0,this.setDefaultValues(uI),this.setValues(t)}setupLightingModel(){return new hI}}ee("MeshToonNodeMaterial",cI);const dI=new z1;class pI extends Dt{constructor(t){super(),this.lights=!1,this.isMeshMatcapNodeMaterial=!0,this.setDefaultValues(dI),this.setValues(t)}setupVariants(t){const e=GM;let i;t.material.matcap?i=ct("matcap","texture").context({getUV:()=>e}):i=P(K(.2,.8,e.y)),pt.rgb.mulAssign(i.rgb)}}ee("MeshMatcapNodeMaterial",pI);const fI=new s_;class mI extends Dt{constructor(t){super(),this.isPointsNodeMaterial=!0,this.lights=!1,this.normals=!1,this.transparent=!0,this.sizeNode=null,this.setDefaultValues(fI),this.setValues(t)}copy(t){return this.sizeNode=t.sizeNode,super.copy(t)}}ee("PointsNodeMaterial",mI);const gI=new C1;class yI extends Dt{constructor(t){super(),this.isSpriteNodeMaterial=!0,this.lights=!1,this.normals=!1,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.setDefaultValues(gI),this.setValues(t)}setupPosition({object:t,context:e}){const{positionNode:i,rotationNode:s,scaleNode:n}=this,r=Ht;let a=ks.mul(P(i||0)),l=F(aa[0].xyz.length(),aa[1].xyz.length());n!==null&&(l=l.mul(n));let h=r.xy;t.center&&t.center.isVector2===!0&&(h=h.sub(H(t.center).sub(.5))),h=h.mul(l);const u=C(s||$R),c=h.rotate(u);a=G(a.xy.add(c),a.zw);const d=vi.mul(a);return e.vertex=r,d}copy(t){return this.positionNode=t.positionNode,this.rotationNode=t.rotationNode,this.scaleNode=t.scaleNode,super.copy(t)}}ee("SpriteNodeMaterial",yI);class xI extends Ta{constructor(){super(),this.shadowNode=C(1).toVar("shadowMask")}direct({shadowMask:t}){this.shadowNode.mulAssign(t)}finish(t){pt.a.mulAssign(this.shadowNode.oneMinus()),t.outgoingLight.rgb.assign(pt.rgb)}}const _I=new I1;class MI extends Dt{constructor(t){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.setDefaultValues(_I),this.setValues(t)}setupLightingModel(){return new xI}}ee("ShadowNodeMaterial",MI);class vI extends Dt{constructor(t={}){super(),this.normals=!1,this.lights=!1,this.isVolumeNodeMaterial=!0,this.testNode=null,this.setValues(t)}setup(t){const e=zC(this.map,null,0),i=z(({orig:s,dir:n})=>{const r=P(-.5),a=P(.5),l=n.reciprocal(),h=r.sub(s).mul(l),u=a.sub(s).mul(l),c=Ui(h,u),d=Et(h,u),p=Et(c.x,Et(c.y,c.z)),f=Ui(d.x,Ui(d.y,d.z));return F(p,f)});this.fragmentNode=z(()=>{const s=$t(P(BR.mul(G(eM,1)))),r=$t(Ae.sub(s)).normalize(),a=Tt("vec2","bounds").assign(i({orig:s,dir:r}));a.x.greaterThan(a.y).discard(),a.assign(F(Et(a.x,0),a.y));const l=Tt("vec3","p").assign(s.add(a.x.mul(r))),h=Tt("vec3","inc").assign(P(r.abs().reciprocal())),u=Tt("float","delta").assign(Ui(h.x,Ui(h.y,h.z)));u.divAssign(ct("steps","float"));const c=Tt("vec4","ac").assign(G(ct("base","color"),0));return Te({type:"float",start:a.x,end:a.y,update:"+= delta"},()=>{const d=Tt("float","d").assign(e.uv(l.add(.5)).r);this.testNode!==null?this.testNode({map:e,mapValue:d,probe:l,finalColor:c}).append():(c.a.assign(1),lf()),l.addAssign(r.mul(u))}),c.a.equal(0).discard(),G(c)})(),super.setup(t)}}ee("VolumeNodeMaterial",vI);class $v{parseFunction(){console.warn("Abstract function.")}}class xf{constructor(t,e,i="",s=""){this.type=t,this.inputs=e,this.name=i,this.precision=s}getCode(){console.warn("Abstract function.")}}xf.isNodeFunction=!0;const TI=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,bI=/[a-z_0-9]+/ig,Oy="#pragma main",SI=o=>{o=o.trim();const t=o.indexOf(Oy),e=t!==-1?o.slice(t+Oy.length):o,i=e.match(TI);if(i!==null&&i.length===5){const s=i[4],n=[];let r=null;for(;(r=bI.exec(s))!==null;)n.push(r);const a=[];let l=0;for(;l<n.length;){const f=n[l][0]==="const";f===!0&&l++;let m=n[l][0];m==="in"||m==="out"||m==="inout"?l++:m="";const g=n[l++][0];let y=Number.parseInt(n[l][0]);Number.isNaN(y)===!1?l++:y=null;const x=n[l++][0];a.push(new pf(g,x,y,m,f))}const h=e.substring(i[0].length),u=i[3]!==void 0?i[3]:"",c=i[2],d=i[1]!==void 0?i[1]:"",p=t!==-1?o.slice(0,t):"";return{type:c,inputs:a,name:u,precision:d,inputsCode:s,blockCode:h,headerCode:p}}else throw new Error("FunctionNode: Function is not a GLSL code.")};class wI extends xf{constructor(t){const{type:e,inputs:i,name:s,precision:n,inputsCode:r,blockCode:a,headerCode:l}=SI(t);super(e,i,s,n),this.inputsCode=r,this.blockCode=a,this.headerCode=l}getCode(t=this.name){let e;const i=this.blockCode;if(i!==""){const{type:s,inputsCode:n,headerCode:r,precision:a}=this;let l=`${s} ${t} ( ${n.trim()} )`;a!==""&&(l=`${a} ${l}`),e=r+l+i}else e="";return e}}class AI extends $v{parseFunction(t){return new wI(t)}}function NI(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.material.id!==t.material.id?o.material.id-t.material.id:o.z!==t.z?o.z-t.z:o.id-t.id}function RI(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.z!==t.z?t.z-o.z:o.id-t.id}class EI{constructor(){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparent=[],this.bundles=[],this.lightsNode=new _M([]),this.lightsArray=[],this.occlusionQueryCount=0}begin(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparent.length=0,this.bundles.length=0,this.lightsArray.length=0,this.occlusionQueryCount=0,this}getNextRenderItem(t,e,i,s,n,r){let a=this.renderItems[this.renderItemsIndex];return a===void 0?(a={id:t.id,object:t,geometry:e,material:i,groupOrder:s,renderOrder:t.renderOrder,z:n,group:r},this.renderItems[this.renderItemsIndex]=a):(a.id=t.id,a.object=t,a.geometry=e,a.material=i,a.groupOrder=s,a.renderOrder=t.renderOrder,a.z=n,a.group=r),this.renderItemsIndex++,a}push(t,e,i,s,n,r){const a=this.getNextRenderItem(t,e,i,s,n,r);t.occlusionTest===!0&&this.occlusionQueryCount++,(i.transparent===!0||i.transmission>0?this.transparent:this.opaque).push(a)}unshift(t,e,i,s,n,r){const a=this.getNextRenderItem(t,e,i,s,n,r);(i.transparent===!0?this.transparent:this.opaque).unshift(a)}pushBundle(t){this.bundles.push(t)}pushLight(t){this.lightsArray.push(t)}getLightsNode(){return this.lightsNode.fromLights(this.lightsArray)}sort(t,e){this.opaque.length>1&&this.opaque.sort(t||NI),this.transparent.length>1&&this.transparent.sort(e||RI)}finish(){this.lightsNode.fromLights(this.lightsArray);for(let t=this.renderItemsIndex,e=this.renderItems.length;t<e;t++){const i=this.renderItems[t];if(i.id===null)break;i.id=null,i.object=null,i.geometry=null,i.material=null,i.groupOrder=null,i.renderOrder=null,i.z=null,i.group=null}}}class CI{constructor(){this.lists=new hs}get(t,e){const i=this.lists,s=[t,e];let n=i.get(s);return n===void 0&&(n=new EI,i.set(s,n)),n}dispose(){this.lists=new hs}}let PI=0;class FI{constructor(){this.id=PI++,this.color=!0,this.clearColor=!0,this.clearColorValue={r:0,g:0,b:0,a:1},this.depth=!0,this.clearDepth=!0,this.clearDepthValue=1,this.stencil=!1,this.clearStencil=!0,this.clearStencilValue=1,this.viewport=!1,this.viewportValue=new _t,this.scissor=!1,this.scissorValue=new _t,this.textures=null,this.depthTexture=null,this.activeCubeFace=0,this.sampleCount=1,this.width=0,this.height=0,this.isRenderContext=!0}}class II{constructor(){this.chainMaps={}}get(t,e,i=null){const s=[t,e];let n;if(i===null)n="default";else{const l=i.texture.format;n=`${i.textures.length}:${l}:${i.samples}:${i.depthBuffer}:${i.stencilBuffer}`}const r=this.getChainMap(n);let a=r.get(s);return a===void 0&&(a=new FI,r.set(s,a)),i!==null&&(a.sampleCount=i.samples===0?1:i.samples),a}getChainMap(t){return this.chainMaps[t]||(this.chainMaps[t]=new hs)}dispose(){this.chainMaps={}}}const BI=new E;class LI extends Nn{constructor(t,e,i){super(),this.renderer=t,this.backend=e,this.info=i}updateRenderTarget(t,e=0){const i=this.get(t),s=t.samples===0?1:t.samples,n=i.depthTextureMips||(i.depthTextureMips={}),r=t.texture,a=t.textures,l=this.getSize(r),h=l.width>>e,u=l.height>>e;let c=t.depthTexture||n[e],d=!1;c===void 0&&(c=new _a,c.format=t.stencilBuffer?qr:yn,c.type=t.stencilBuffer?ma:re,c.image.width=h,c.image.height=u,n[e]=c),(i.width!==l.width||l.height!==i.height)&&(d=!0,c.needsUpdate=!0,c.image.width=h,c.image.height=u),i.width=l.width,i.height=l.height,i.textures=a,i.depthTexture=c,i.depth=t.depthBuffer,i.stencil=t.stencilBuffer,i.renderTarget=t,i.sampleCount!==s&&(d=!0,c.needsUpdate=!0,i.sampleCount=s);const p={sampleCount:s};for(let f=0;f<a.length;f++){const m=a[f];d&&(m.needsUpdate=!0),this.updateTexture(m,p)}if(this.updateTexture(c,p),i.initialized!==!0){i.initialized=!0;const f=()=>{if(t.removeEventListener("dispose",f),a!==void 0)for(let m=0;m<a.length;m++)this._destroyTexture(a[m]);else this._destroyTexture(r);this._destroyTexture(c),this.delete(t)};t.addEventListener("dispose",f)}}updateTexture(t,e={}){const i=this.get(t);if(i.initialized===!0&&i.version===t.version)return;const s=t.isRenderTargetTexture||t.isDepthTexture||t.isFramebufferTexture,n=this.backend;if(s&&i.initialized===!0&&(n.destroySampler(t),n.destroyTexture(t)),t.isFramebufferTexture){const u=this.renderer.getRenderTarget();u?t.type=u.texture.type:t.type=rs}const{width:r,height:a,depth:l}=this.getSize(t);if(e.width=r,e.height=a,e.depth=l,e.needsMipmaps=this.needsMipmaps(t),e.levels=e.needsMipmaps?this.getMipLevels(t,r,a):1,s||t.isStorageTexture===!0)n.createSampler(t),n.createTexture(t,e);else if(i.initialized!==!0&&n.createSampler(t),t.version>0){const u=t.image;if(u===void 0)console.warn("THREE.Renderer: Texture marked for update but image is undefined.");else if(u.complete===!1)console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");else{if(t.images){const c=[];for(const d of t.images)c.push(d);e.images=c}else e.image=u;(i.isDefaultTexture===void 0||i.isDefaultTexture===!0)&&(n.createTexture(t,e),i.isDefaultTexture=!1),t.source.dataReady===!0&&n.updateTexture(t,e),e.needsMipmaps&&t.mipmaps.length===0&&n.generateMipmaps(t)}}else n.createDefaultTexture(t),i.isDefaultTexture=!0;if(i.initialized!==!0){i.initialized=!0,this.info.memory.textures++;const h=()=>{t.removeEventListener("dispose",h),this._destroyTexture(t),this.info.memory.textures--};t.addEventListener("dispose",h)}i.version=t.version}getSize(t,e=BI){let i=t.images?t.images[0]:t.image;return i?(i.image!==void 0&&(i=i.image),e.width=i.width,e.height=i.height,e.depth=t.isCubeTexture?6:i.depth||1):e.width=e.height=e.depth=1,e}getMipLevels(t,e,i){let s;return t.isCompressedTexture?s=t.mipmaps.length:s=Math.floor(Math.log2(Math.max(e,i)))+1,s}needsMipmaps(t){return this.isEnvironmentTexture(t)?!0:t.isCompressedTexture===!0||t.minFilter!==ce&&t.minFilter!==Le}isEnvironmentTexture(t){const e=t.mapping;return e===Np||e===Rp||e===Hr||e===ra}_destroyTexture(t){this.backend.destroySampler(t),this.backend.destroyTexture(t),this.delete(t)}}class _f extends nt{constructor(t,e,i,s=1){super(t,e,i),this.a=s}set(t,e,i,s=1){return this.a=s,super.set(t,e,i)}copy(t){return t.a!==void 0&&(this.a=t.a),super.copy(t)}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}}const _i=new _f;class UI extends Nn{constructor(t,e){super(),this.renderer=t,this.nodes=e}update(t,e,i){const s=this.renderer,n=this.nodes.getBackgroundNode(t)||t.background;let r=!1;if(n===null)s._clearColor.getRGB(_i,Qe),_i.a=s._clearColor.a;else if(n.isColor===!0)n.getRGB(_i,Qe),_i.a=1,r=!0;else if(n.isNode===!0){const a=this.get(t),l=n;_i.copy(s._clearColor);let h=a.backgroundMesh;if(h===void 0){const c=zr(G(l).mul(_y),{getUV:()=>of,getTextureLevel:()=>LC});let d=Zd();d=d.setZ(d.w);const p=new Dt;p.name="Background.material",p.side=ms,p.depthTest=!1,p.depthWrite=!1,p.fog=!1,p.lights=!1,p.vertexNode=d,p.colorNode=c,a.backgroundMeshNode=c,a.backgroundMesh=h=new so(new Gp(1,32,32),p),h.frustumCulled=!1,h.name="Background.mesh",h.onBeforeRender=function(f,m,g){this.matrixWorld.copyPosition(g.matrixWorld)}}const u=l.getCacheKey();a.backgroundCacheKey!==u&&(a.backgroundMeshNode.node=G(l).mul(_y),h.material.needsUpdate=!0,a.backgroundCacheKey=u),e.unshift(h,h.geometry,h.material,0,0,null)}else console.error("THREE.Renderer: Unsupported background configuration.",n);if(s.autoClear===!0||r===!0){_i.multiplyScalar(_i.a);const a=i.clearColorValue;a.r=_i.r,a.g=_i.g,a.b=_i.b,a.a=_i.a,i.depthClearValue=s._clearDepth,i.stencilClearValue=s._clearStencil,i.clearColor=s.autoClearColor===!0,i.clearDepth=s.autoClearDepth===!0,i.clearStencil=s.autoClearStencil===!0}else i.clearColor=!1,i.clearDepth=!1,i.clearStencil=!1}}class DI{constructor(t,e,i,s,n,r,a,l,h=!0,u=[]){this.vertexShader=t,this.fragmentShader=e,this.computeShader=i,this.transforms=u,this.nodeAttributes=s,this.bindings=n,this.updateNodes=r,this.updateBeforeNodes=a,this.updateAfterNodes=l,this.instanceBindGroups=h,this.usedTimes=0}createBindings(){const t=[];for(const e of this.bindings)if((this.instanceBindGroups&&e.bindings[0].groupNode.shared)!==!0){const s=new ip(e.name);t.push(s);for(const n of e.bindings)s.bindings.push(n.clone())}else t.push(e);return t}}const zy=new WeakMap;class OI extends Nn{constructor(t,e){super(),this.renderer=t,this.backend=e,this.nodeFrame=new py,this.nodeBuilderCache=new Map,this.callHashCache=new hs,this.groupsData=new hs}updateGroup(t){const e=t.groupNode,i=e.name;if(i===U_.name)return!0;if(i===RN.name){const r=this.get(t),a=this.nodeFrame.renderId;return r.renderId!==a?(r.renderId=a,!0):!1}if(i===NN.name){const r=this.get(t),a=this.nodeFrame.frameId;return r.frameId!==a?(r.frameId=a,!0):!1}const s=[e,t];let n=this.groupsData.get(s);return n===void 0&&this.groupsData.set(s,n={}),n.version!==e.version?(n.version=e.version,!0):!1}getForRenderCacheKey(t){return t.initialCacheKey}getForRender(t){const e=this.get(t);let i=e.nodeBuilderState;if(i===void 0){const{nodeBuilderCache:s}=this,n=this.getForRenderCacheKey(t);if(i=s.get(n),i===void 0){const r=this.backend.createNodeBuilder(t.object,this.renderer);r.scene=t.scene,r.material=t.material,r.camera=t.camera,r.context.material=t.material,r.lightsNode=t.lightsNode,r.environmentNode=this.getEnvironmentNode(t.scene),r.fogNode=this.getFogNode(t.scene),r.clippingContext=t.clippingContext,r.build(),i=this._createNodeBuilderState(r),s.set(n,i)}i.usedTimes++,e.nodeBuilderState=i}return i}delete(t){if(t.isRenderObject){const e=this.get(t).nodeBuilderState;e.usedTimes--,e.usedTimes===0&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(t))}return super.delete(t)}getForCompute(t){const e=this.get(t);let i=e.nodeBuilderState;if(i===void 0){const s=this.backend.createNodeBuilder(t,this.renderer);s.build(),i=this._createNodeBuilderState(s),e.nodeBuilderState=i}return i}_createNodeBuilderState(t){return new DI(t.vertexShader,t.fragmentShader,t.computeShader,t.getAttributesArray(),t.getBindings(),t.updateNodes,t.updateBeforeNodes,t.updateAfterNodes,t.instanceBindGroups,t.transforms)}getEnvironmentNode(t){return t.environmentNode||this.get(t).environmentNode||null}getBackgroundNode(t){return t.backgroundNode||this.get(t).backgroundNode||null}getFogNode(t){return t.fogNode||this.get(t).fogNode||null}getCacheKey(t,e){const i=[t,e],s=this.renderer.info.calls;let n=this.callHashCache.get(i);if(n===void 0||n.callId!==s){const r=this.getEnvironmentNode(t),a=this.getFogNode(t),l=[];e&&l.push(e.getCacheKey(!0)),r&&l.push(r.getCacheKey()),a&&l.push(a.getCacheKey()),n={callId:s,cacheKey:l.join(",")},this.callHashCache.set(i,n)}return n.cacheKey}updateScene(t){this.updateEnvironment(t),this.updateFog(t),this.updateBackground(t)}get isToneMappingState(){return!this.renderer.getRenderTarget()}updateBackground(t){const e=this.get(t),i=t.background;if(i){if(e.background!==i){let s=null;i.isCubeTexture===!0||i.mapping===Np||i.mapping===Rp?s=Bv(i,of):i.isTexture===!0?s=gt(i,SE).setUpdateMatrix(!0):i.isColor!==!0&&console.error("WebGPUNodes: Unsupported background configuration.",i),e.backgroundNode=s,e.background=i}}else e.backgroundNode&&(delete e.backgroundNode,delete e.background)}updateFog(t){const e=this.get(t),i=t.fog;if(i){if(e.fog!==i){let s=null;i.isFogExp2?s=Tv(Wt("color","color",i),Wt("density","float",i)):i.isFog?s=Mv(Wt("color","color",i),Wt("near","float",i),Wt("far","float",i)):console.error("WebGPUNodes: Unsupported fog configuration.",i),e.fogNode=s,e.fog=i}}else delete e.fogNode,delete e.fog}updateEnvironment(t){const e=this.get(t),i=t.environment;if(i){if(e.environment!==i){let s=null;i.isCubeTexture===!0?s=nu(i):i.isTexture===!0?s=gt(i):console.error("Nodes: Unsupported environment configuration.",i),e.environmentNode=s,e.environment=i}}else e.environmentNode&&(delete e.environmentNode,delete e.environment)}getNodeFrame(t=this.renderer,e=null,i=null,s=null,n=null){const r=this.nodeFrame;return r.renderer=t,r.scene=e,r.object=i,r.camera=s,r.material=n,r}getNodeFrameForRender(t){return this.getNodeFrame(t.renderer,t.scene,t.object,t.camera,t.material)}getOutputCacheKey(){const t=this.renderer;return t.toneMapping+","+t.currentColorSpace}hasOutputChange(t){return zy.get(t)!==this.getOutputCacheKey()}getOutputNode(t){const e=this.renderer,i=this.getOutputCacheKey(),s=gt(t,Zr).renderOutput(e.toneMapping,e.currentColorSpace);return zy.set(t,i),s}updateBefore(t){const e=this.getNodeFrameForRender(t),i=t.getNodeBuilderState();for(const s of i.updateBeforeNodes)e.updateBeforeNode(s)}updateAfter(t){const e=this.getNodeFrameForRender(t),i=t.getNodeBuilderState();for(const s of i.updateAfterNodes)e.updateAfterNode(s)}updateForCompute(t){const e=this.getNodeFrame(),i=this.getForCompute(t);for(const s of i.updateNodes)e.updateNode(s)}updateForRender(t){const e=this.getNodeFrameForRender(t),i=t.getNodeBuilderState();for(const s of i.updateNodes)e.updateNode(s)}dispose(){super.dispose(),this.nodeFrame=new py,this.nodeBuilderCache=new Map}}class zI{constructor(t,e){this.scene=t,this.camera=e}clone(){return Object.assign(new this.constructor,this)}}class VI{constructor(){this.lists=new hs}get(t,e){const i=this.lists,s=[t,e];let n=i.get(s);return n===void 0&&(n=new zI(t,e),i.set(s,n)),n}dispose(){this.lists=new hs}}const Vy=new Q0,Il=new q,Oc=new _t,zc=new e_,Bl=new Bt,Io=new E;class kI{constructor(t,e={}){this.isRenderer=!0;const{logarithmicDepthBuffer:i=!1,alpha:s=!0,antialias:n=!1,samples:r=0}=e;this.domElement=t.getDomElement(),this.backend=t,this.samples=r||n===!0?4:0,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=s,this.logarithmicDepthBuffer=i,this.outputColorSpace=j,this.toneMapping=Tn,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=!0,this.stencil=!1,this.clippingPlanes=[],this.info=new AA,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new _t(0,0,this._width,this._height),this._scissor=new _t(0,0,this._width,this._height),this._scissorTest=!1,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._bundles=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._quad=new gs(new Dt),this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._frameBufferTarget=null;const a=this.alpha===!0?0:1;this._clearColor=new _f(0,0,0,a),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._mrt=null,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._currentRenderBundle=null,this._handleObjectFunction=this._renderObjectDirect,this._initialized=!1,this._initPromise=null,this._compilationPromises=null,this.transparent=!0,this.opaque=!0,this.shadowMap={enabled:!1,type:aw},this.xr={enabled:!1},this.debug={checkShaderErrors:!0,onShaderError:null}}async init(){if(this._initialized)throw new Error("Renderer: Backend has already been initialized.");return this._initPromise!==null?this._initPromise:(this._initPromise=new Promise(async(t,e)=>{const i=this.backend;try{await i.init(this)}catch(s){e(s);return}this._nodes=new OI(this,i),this._animation=new gA(this._nodes,this.info),this._attributes=new bA(i),this._background=new UI(this,this._nodes),this._geometries=new wA(this._attributes,this.info),this._textures=new LI(this,i,this.info),this._pipelines=new CA(i,this._nodes),this._bindings=new PA(i,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new MA(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new CI,this._bundles=new VI,this._renderContexts=new II,this._initialized=!0,t()}),this._initPromise)}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(t,e,i=null){this._initialized===!1&&await this.init();const s=this._nodes.nodeFrame,n=s.renderId,r=this._currentRenderContext,a=this._currentRenderObjectFunction,l=this._compilationPromises,h=t.isScene===!0?t:Vy;i===null&&(i=t);const u=this._renderTarget,c=this._renderContexts.get(i,e,u),d=this._activeMipmapLevel,p=[];this._currentRenderContext=c,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=p,s.renderId++,s.update(),c.depth=this.depth,c.stencil=this.stencil,c.clippingContext||(c.clippingContext=new Dd),c.clippingContext.updateGlobal(this,e),h.onBeforeRender(this,t,e,u);const f=this._renderLists.get(t,e);if(f.begin(),this._projectObject(t,e,0,f),i!==t&&i.traverseVisible(function(x){x.isLight&&x.layers.test(e.layers)&&f.pushLight(x)}),f.finish(),u!==null){this._textures.updateRenderTarget(u,d);const x=this._textures.get(u);c.textures=x.textures,c.depthTexture=x.depthTexture}else c.textures=null,c.depthTexture=null;this._nodes.updateScene(h),this._background.update(h,f,c);const m=f.opaque,g=f.transparent,y=f.lightsNode;this.opaque===!0&&m.length>0&&this._renderObjects(m,e,h,y),this.transparent===!0&&g.length>0&&this._renderObjects(g,e,h,y),s.renderId=n,this._currentRenderContext=r,this._currentRenderObjectFunction=a,this._compilationPromises=l,this._handleObjectFunction=this._renderObjectDirect,await Promise.all(p)}async renderAsync(t,e){this._initialized===!1&&await this.init();const i=this._renderScene(t,e);await this.backend.resolveTimestampAsync(i,"render")}setMRT(t){return this._mrt=t,this}getMRT(){return this._mrt}_renderBundle(t,e,i){const{object:s,camera:n,renderList:r}=t,a=this._currentRenderContext,l=this.backend.get(a),h=this._bundles.get(s,n),u=this.backend.get(h);u.renderContexts===void 0&&(u.renderContexts=new Set);const c=u.renderContexts.has(a)===!1||s.needsUpdate===!0;if(u.renderContexts.add(a),c){if(l.renderObjects===void 0||s.needsUpdate===!0){const p=this._nodes.nodeFrame;l.renderObjects=[],l.renderBundles=[],l.scene=e,l.camera=n,l.renderId=p.renderId,l.registerBundlesPhase=!0}this._currentRenderBundle=h;const d=r.opaque;d.length>0&&this._renderObjects(d,n,e,i),this._currentRenderBundle=null,s.needsUpdate=!1}else{const d=this._currentRenderContext,p=this.backend.get(d);for(let f=0,m=p.renderObjects.length;f<m;f++){const g=p.renderObjects[f];this._nodes.updateBefore(g),g.object.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,g.object.matrixWorld),g.object.normalMatrix.getNormalMatrix(g.object.modelViewMatrix),this._nodes.updateForRender(g),this._bindings.updateForRender(g),this.backend.draw(g,this.info),this._nodes.updateAfter(g)}}}render(t,e){if(this._initialized===!1)return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."),this.renderAsync(t,e);this._renderScene(t,e)}_getFrameBufferTarget(){const{currentColorSpace:t}=this,e=this._renderTarget===null&&this.toneMapping!==Tn,i=this._renderTarget===null&&t!==Qe&&t!==ga;if(e===!1&&i===!1)return null;const{width:s,height:n}=this.getDrawingBufferSize(Il),{depth:r,stencil:a}=this;let l=this._frameBufferTarget;return l===null&&(l=new be(s,n,{depthBuffer:r,stencilBuffer:a,type:wi,format:io,colorSpace:Qe,generateMipmaps:!1,minFilter:Le,magFilter:Le,samples:this.samples}),l.isPostProcessingRenderTarget=!0,this._frameBufferTarget=l),l.depthBuffer=r,l.stencilBuffer=a,l.setSize(s,n),l.viewport.copy(this._viewport),l.scissor.copy(this._scissor),l.viewport.multiplyScalar(this._pixelRatio),l.scissor.multiplyScalar(this._pixelRatio),l.scissorTest=this._scissorTest,l}_renderScene(t,e,i=!0){const s=i?this._getFrameBufferTarget():null,n=this._nodes.nodeFrame,r=n.renderId,a=this._currentRenderContext,l=this._currentRenderObjectFunction,h=t.isScene===!0?t:Vy,u=this._renderTarget,c=this._activeCubeFace,d=this._activeMipmapLevel;let p;s!==null?(p=s,this.setRenderTarget(p)):p=u;const f=this._renderContexts.get(t,e,p);this._currentRenderContext=f,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this.info.calls++,this.info.render.calls++,this.info.render.frameCalls++,n.renderId=this.info.calls;const m=this.coordinateSystem;e.coordinateSystem!==m&&(e.coordinateSystem=m,e.updateProjectionMatrix()),t.matrixWorldAutoUpdate===!0&&t.updateMatrixWorld(),e.parent===null&&e.matrixWorldAutoUpdate===!0&&e.updateMatrixWorld();let g=this._viewport,y=this._scissor,x=this._pixelRatio;p!==null&&(g=p.viewport,y=p.scissor,x=1),this.getDrawingBufferSize(Il),Oc.set(0,0,Il.width,Il.height);const M=g.minDepth===void 0?0:g.minDepth,_=g.maxDepth===void 0?1:g.maxDepth;f.viewportValue.copy(g).multiplyScalar(x).floor(),f.viewportValue.width>>=d,f.viewportValue.height>>=d,f.viewportValue.minDepth=M,f.viewportValue.maxDepth=_,f.viewport=f.viewportValue.equals(Oc)===!1,f.scissorValue.copy(y).multiplyScalar(x).floor(),f.scissor=this._scissorTest&&f.scissorValue.equals(Oc)===!1,f.scissorValue.width>>=d,f.scissorValue.height>>=d,f.clippingContext||(f.clippingContext=new Dd),f.clippingContext.updateGlobal(this,e),h.onBeforeRender(this,t,e,p),Bl.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),zc.setFromProjectionMatrix(Bl,m);const v=this._renderLists.get(t,e);if(v.begin(),this._projectObject(t,e,0,v),v.finish(),this.sortObjects===!0&&v.sort(this._opaqueSort,this._transparentSort),p!==null){this._textures.updateRenderTarget(p,d);const D=this._textures.get(p);f.textures=D.textures,f.depthTexture=D.depthTexture,f.width=D.width,f.height=D.height,f.renderTarget=p,f.depth=p.depthBuffer,f.stencil=p.stencilBuffer}else f.textures=null,f.depthTexture=null,f.width=this.domElement.width,f.height=this.domElement.height,f.depth=this.depth,f.stencil=this.stencil;f.width>>=d,f.height>>=d,f.activeCubeFace=c,f.activeMipmapLevel=d,f.occlusionQueryCount=v.occlusionQueryCount,this._nodes.updateScene(h),this._background.update(h,v,f),this.backend.beginRender(f);const A=v.opaque,T=v.transparent,w=v.bundles,U=v.lightsNode;if(w.length>0&&this._renderBundles(w,h,U),this.opaque===!0&&A.length>0&&this._renderObjects(A,e,h,U),this.transparent===!0&&T.length>0&&this._renderObjects(T,e,h,U),this.backend.finishRender(f),n.renderId=r,this._currentRenderContext=a,this._currentRenderObjectFunction=l,s!==null){this.setRenderTarget(u,c,d);const D=this._quad;this._nodes.hasOutputChange(p.texture)&&(D.material.fragmentNode=this._nodes.getOutputNode(p.texture),D.material.needsUpdate=!0),this._renderScene(D,D.camera,!1)}return h.onAfterRender(this,t,e,p),f}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(t){this._initialized===!1&&await this.init(),this._animation.setAnimationLoop(t)}async getArrayBufferAsync(t){return await this.backend.getArrayBufferAsync(t)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(t){return t.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(t){return t.set(this._width,this._height)}setPixelRatio(t=1){this._pixelRatio=t,this.setSize(this._width,this._height,!1)}setDrawingBufferSize(t,e,i){this._width=t,this._height=e,this._pixelRatio=i,this.domElement.width=Math.floor(t*i),this.domElement.height=Math.floor(e*i),this.setViewport(0,0,t,e),this._initialized&&this.backend.updateSize()}setSize(t,e,i=!0){this._width=t,this._height=e,this.domElement.width=Math.floor(t*this._pixelRatio),this.domElement.height=Math.floor(e*this._pixelRatio),i===!0&&(this.domElement.style.width=t+"px",this.domElement.style.height=e+"px"),this.setViewport(0,0,t,e),this._initialized&&this.backend.updateSize()}setOpaqueSort(t){this._opaqueSort=t}setTransparentSort(t){this._transparentSort=t}getScissor(t){const e=this._scissor;return t.x=e.x,t.y=e.y,t.width=e.width,t.height=e.height,t}setScissor(t,e,i,s){const n=this._scissor;t.isVector4?n.copy(t):n.set(t,e,i,s)}getScissorTest(){return this._scissorTest}setScissorTest(t){this._scissorTest=t,this.backend.setScissorTest(t)}getViewport(t){return t.copy(this._viewport)}setViewport(t,e,i,s,n=0,r=1){const a=this._viewport;t.isVector4?a.copy(t):a.set(t,e,i,s),a.minDepth=n,a.maxDepth=r}getClearColor(t){return t.copy(this._clearColor)}setClearColor(t,e=1){this._clearColor.set(t),this._clearColor.a=e}getClearAlpha(){return this._clearColor.a}setClearAlpha(t){this._clearColor.a=t}getClearDepth(){return this._clearDepth}setClearDepth(t){this._clearDepth=t}getClearStencil(){return this._clearStencil}setClearStencil(t){this._clearStencil=t}isOccluded(t){const e=this._currentRenderContext;return e&&this.backend.isOccluded(e,t)}clear(t=!0,e=!0,i=!0){if(this._initialized===!1)return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."),this.clearAsync(t,e,i);const s=this._renderTarget||this._getFrameBufferTarget();let n=null;if(s!==null&&(this._textures.updateRenderTarget(s),n=this._textures.get(s)),this.backend.clear(t,e,i,n),s!==null&&this._renderTarget===null){const r=this._quad;this._nodes.hasOutputChange(s.texture)&&(r.material.fragmentNode=this._nodes.getOutputNode(s.texture),r.material.needsUpdate=!0),this._renderScene(r,r.camera,!1)}}clearColor(){return this.clear(!0,!1,!1)}clearDepth(){return this.clear(!1,!0,!1)}clearStencil(){return this.clear(!1,!1,!0)}async clearAsync(t=!0,e=!0,i=!0){this._initialized===!1&&await this.init(),this.clear(t,e,i)}clearColorAsync(){return this.clearAsync(!0,!1,!1)}clearDepthAsync(){return this.clearAsync(!1,!0,!1)}clearStencilAsync(){return this.clearAsync(!1,!1,!0)}get currentColorSpace(){const t=this._renderTarget;if(t!==null){const e=t.texture;return(Array.isArray(e)?e[0]:e).colorSpace}return this.outputColorSpace}dispose(){this.info.dispose(),this._animation.dispose(),this._objects.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(t,e=0,i=0){this._renderTarget=t,this._activeCubeFace=e,this._activeMipmapLevel=i}getRenderTarget(){return this._renderTarget}setRenderObjectFunction(t){this._renderObjectFunction=t}getRenderObjectFunction(){return this._renderObjectFunction}async computeAsync(t){this._initialized===!1&&await this.init();const e=this._nodes.nodeFrame,i=e.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.frameCalls++,e.renderId=this.info.calls;const s=this.backend,n=this._pipelines,r=this._bindings,a=this._nodes,l=Array.isArray(t)?t:[t];if(l[0]===void 0||l[0].isComputeNode!==!0)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");s.beginCompute(t);for(const h of l){if(n.has(h)===!1){const d=()=>{h.removeEventListener("dispose",d),n.delete(h),r.delete(h),a.delete(h)};h.addEventListener("dispose",d),h.onInit({renderer:this})}a.updateForCompute(h),r.updateForCompute(h);const u=r.getForCompute(h),c=n.getForCompute(h,u);s.compute(t,h,u,c)}s.finishCompute(t),await this.backend.resolveTimestampAsync(t,"compute"),e.renderId=i}async hasFeatureAsync(t){return this._initialized===!1&&await this.init(),this.backend.hasFeature(t)}hasFeature(t){return this._initialized===!1?(console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."),!1):this.backend.hasFeature(t)}copyFramebufferToTexture(t){const e=this._currentRenderContext;this._textures.updateTexture(t),this.backend.copyFramebufferToTexture(t,e)}copyTextureToTexture(t,e,i=null,s=null,n=0){this._textures.updateTexture(t),this._textures.updateTexture(e),this.backend.copyTextureToTexture(t,e,i,s,n)}readRenderTargetPixelsAsync(t,e,i,s,n,r=0){return this.backend.copyTextureToBuffer(t.textures[r],e,i,s,n)}_projectObject(t,e,i,s){if(t.visible===!1)return;if(t.layers.test(e.layers)){if(t.isGroup)i=t.renderOrder;else if(t.isLOD)t.autoUpdate===!0&&t.update(e);else if(t.isLight)s.pushLight(t);else if(t.isSprite){if(!t.frustumCulled||zc.intersectsSprite(t)){this.sortObjects===!0&&Io.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Bl);const a=t.geometry,l=t.material;l.visible&&s.push(t,a,l,i,Io.z,null)}}else if(t.isLineLoop)console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if((t.isMesh||t.isLine||t.isPoints)&&(!t.frustumCulled||zc.intersectsObject(t))){const a=t.geometry,l=t.material;if(this.sortObjects===!0&&(a.boundingSphere===null&&a.computeBoundingSphere(),Io.copy(a.boundingSphere.center).applyMatrix4(t.matrixWorld).applyMatrix4(Bl)),Array.isArray(l)){const h=a.groups;for(let u=0,c=h.length;u<c;u++){const d=h[u],p=l[d.materialIndex];p&&p.visible&&s.push(t,a,p,i,Io.z,d)}}else l.visible&&s.push(t,a,l,i,Io.z,null)}}if(t.static===!0){const a=s;s=this._renderLists.get(t,e),s.begin(),a.pushBundle({object:t,camera:e,renderList:s}),s.finish()}const r=t.children;for(let a=0,l=r.length;a<l;a++)this._projectObject(r[a],e,i,s)}_renderBundles(t,e,i){for(const s of t)this._renderBundle(s,e,i)}_renderObjects(t,e,i,s){for(let n=0,r=t.length;n<r;n++){const a=t[n],{object:l,geometry:h,material:u,group:c}=a;if(e.isArrayCamera){const d=e.cameras;for(let p=0,f=d.length;p<f;p++){const m=d[p];if(l.layers.test(m.layers)){const g=m.viewport,y=g.minDepth===void 0?0:g.minDepth,x=g.maxDepth===void 0?1:g.maxDepth,M=this._currentRenderContext.viewportValue;M.copy(g).multiplyScalar(this._pixelRatio).floor(),M.minDepth=y,M.maxDepth=x,this.backend.updateViewport(this._currentRenderContext),this._currentRenderObjectFunction(l,i,m,h,u,c,s)}}}else this._currentRenderObjectFunction(l,i,e,h,u,c,s)}}renderObject(t,e,i,s,n,r,a){let l,h,u;if(t.onBeforeRender(this,e,i,s,n,r),e.overrideMaterial!==null){const c=e.overrideMaterial;n.positionNode&&n.positionNode.isNode&&(l=c.positionNode,c.positionNode=n.positionNode),c.isShadowNodeMaterial&&(c.side=n.shadowSide===null?n.side:n.shadowSide,n.depthNode&&n.depthNode.isNode&&(u=c.depthNode,c.depthNode=n.depthNode),n.shadowNode&&n.shadowNode.isNode&&(h=c.fragmentNode,c.fragmentNode=n.shadowNode),this.localClippingEnabled&&(n.clipShadows?(c.clippingPlanes!==n.clippingPlanes&&(c.clippingPlanes=n.clippingPlanes,c.needsUpdate=!0),c.clipIntersection!==n.clipIntersection&&(c.clipIntersection=n.clipIntersection)):Array.isArray(c.clippingPlanes)&&(c.clippingPlanes=null,c.needsUpdate=!0))),n=c}n.transparent===!0&&n.side===lh&&n.forceSinglePass===!1?(n.side=ms,this._handleObjectFunction(t,n,e,i,a,r,"backSide"),n.side=na,this._handleObjectFunction(t,n,e,i,a,r),n.side=lh):this._handleObjectFunction(t,n,e,i,a,r),l!==void 0&&(e.overrideMaterial.positionNode=l),u!==void 0&&(e.overrideMaterial.depthNode=u),h!==void 0&&(e.overrideMaterial.fragmentNode=h),t.onAfterRender(this,e,i,s,n,r)}_renderObjectDirect(t,e,i,s,n,r,a){const l=this._objects.get(t,e,i,s,n,this._currentRenderContext,a);if(l.drawRange=r||t.geometry.drawRange,this._nodes.updateBefore(l),t.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),this._nodes.updateForRender(l),this._geometries.updateForRender(l),this._bindings.updateForRender(l),this._pipelines.updateForRender(l),this._currentRenderBundle!==null&&this._currentRenderBundle.needsUpdate===!0){const h=this.backend.get(l);h.bundleEncoder=void 0,h.lastPipelineGPU=void 0}this.backend.draw(l,this.info),this._currentRenderBundle!==null&&this.backend.get(this._currentRenderContext).renderObjects.push(l),this._nodes.updateAfter(l)}_createObjectPipeline(t,e,i,s,n,r){const a=this._objects.get(t,e,i,s,n,this._currentRenderContext,r);this._nodes.updateBefore(a),this._nodes.updateForRender(a),this._geometries.updateForRender(a),this._bindings.updateForRender(a),this._pipelines.getForRender(a,this._compilationPromises),this._nodes.updateAfter(a)}get compute(){return this.computeAsync}get compile(){return this.compileAsync}}class Mf{constructor(t=""){this.name=t,this.visibility=0}setVisibility(t){this.visibility|=t}clone(){return Object.assign(new this.constructor,this)}}function GI(o){return o+(Ls-o%Ls)%Ls}class qv extends Mf{constructor(t,e=null){super(t),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this._buffer=e}get byteLength(){return GI(this._buffer.byteLength)}get buffer(){return this._buffer}update(){return!0}}class jv extends qv{constructor(t,e=null){super(t,e),this.isUniformBuffer=!0}}let WI=0;class Xv extends jv{constructor(t,e){super("UniformBuffer_"+WI++,t?t.value:null),this.nodeUniform=t,this.groupNode=e}get buffer(){return this.nodeUniform.value}}class HI extends jv{constructor(t){super(t),this.isUniformsGroup=!0,this._values=null,this.uniforms=[]}addUniform(t){return this.uniforms.push(t),this}removeUniform(t){const e=this.uniforms.indexOf(t);return e!==-1&&this.uniforms.splice(e,1),this}get values(){return this._values===null&&(this._values=Array.from(this.buffer)),this._values}get buffer(){let t=this._buffer;if(t===null){const e=this.byteLength;t=new Float32Array(new ArrayBuffer(e)),this._buffer=t}return t}get byteLength(){let t=0;for(let e=0,i=this.uniforms.length;e<i;e++){const s=this.uniforms[e],{boundary:n,itemSize:r}=s,a=t%Ls,l=Ls-a;a!==0&&l-n<0?t+=Ls-a:a%n!==0&&(t+=a%n),s.offset=t/this.bytesPerElement,t+=r*this.bytesPerElement}return Math.ceil(t/Ls)*Ls}update(){let t=!1;for(const e of this.uniforms)this.updateByType(e)===!0&&(t=!0);return t}updateByType(t){if(t.isNumberUniform)return this.updateNumber(t);if(t.isVector2Uniform)return this.updateVector2(t);if(t.isVector3Uniform)return this.updateVector3(t);if(t.isVector4Uniform)return this.updateVector4(t);if(t.isColorUniform)return this.updateColor(t);if(t.isMatrix3Uniform)return this.updateMatrix3(t);if(t.isMatrix4Uniform)return this.updateMatrix4(t);console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.",t)}updateNumber(t){let e=!1;const i=this.values,s=t.getValue(),n=t.offset;if(i[n]!==s){const r=this.buffer;r[n]=i[n]=s,e=!0}return e}updateVector2(t){let e=!1;const i=this.values,s=t.getValue(),n=t.offset;if(i[n+0]!==s.x||i[n+1]!==s.y){const r=this.buffer;r[n+0]=i[n+0]=s.x,r[n+1]=i[n+1]=s.y,e=!0}return e}updateVector3(t){let e=!1;const i=this.values,s=t.getValue(),n=t.offset;if(i[n+0]!==s.x||i[n+1]!==s.y||i[n+2]!==s.z){const r=this.buffer;r[n+0]=i[n+0]=s.x,r[n+1]=i[n+1]=s.y,r[n+2]=i[n+2]=s.z,e=!0}return e}updateVector4(t){let e=!1;const i=this.values,s=t.getValue(),n=t.offset;if(i[n+0]!==s.x||i[n+1]!==s.y||i[n+2]!==s.z||i[n+4]!==s.w){const r=this.buffer;r[n+0]=i[n+0]=s.x,r[n+1]=i[n+1]=s.y,r[n+2]=i[n+2]=s.z,r[n+3]=i[n+3]=s.w,e=!0}return e}updateColor(t){let e=!1;const i=this.values,s=t.getValue(),n=t.offset;if(i[n+0]!==s.r||i[n+1]!==s.g||i[n+2]!==s.b){const r=this.buffer;r[n+0]=i[n+0]=s.r,r[n+1]=i[n+1]=s.g,r[n+2]=i[n+2]=s.b,e=!0}return e}updateMatrix3(t){let e=!1;const i=this.values,s=t.getValue().elements,n=t.offset;if(i[n+0]!==s[0]||i[n+1]!==s[1]||i[n+2]!==s[2]||i[n+4]!==s[3]||i[n+5]!==s[4]||i[n+6]!==s[5]||i[n+8]!==s[6]||i[n+9]!==s[7]||i[n+10]!==s[8]){const r=this.buffer;r[n+0]=i[n+0]=s[0],r[n+1]=i[n+1]=s[1],r[n+2]=i[n+2]=s[2],r[n+4]=i[n+4]=s[3],r[n+5]=i[n+5]=s[4],r[n+6]=i[n+6]=s[5],r[n+8]=i[n+8]=s[6],r[n+9]=i[n+9]=s[7],r[n+10]=i[n+10]=s[8],e=!0}return e}updateMatrix4(t){let e=!1;const i=this.values,s=t.getValue().elements,n=t.offset;return qI(i,s,n)===!1&&(this.buffer.set(s,n),$I(i,s,n),e=!0),e}}function $I(o,t,e){for(let i=0,s=t.length;i<s;i++)o[e+i]=t[i]}function qI(o,t,e){for(let i=0,s=t.length;i<s;i++)if(o[e+i]!==t[i])return!1;return!0}let jI=0;class Yv extends HI{constructor(t,e){super(t),this.id=jI++,this.groupNode=e,this.isNodeUniformsGroup=!0}getNodes(){const t=[];for(const e of this.uniforms){const i=e.nodeUniform.node;if(!i)throw new Error("NodeUniformsGroup: Uniform has no node.");t.push(i)}return t}}let XI=0;class YI extends Mf{constructor(t,e){super(t),this.id=XI++,this.texture=e,this.version=e?e.version:0,this.store=!1,this.isSampledTexture=!0}get needsBindingsUpdate(){const{texture:t,version:e}=this;return t.isVideoTexture?!0:e!==t.version}update(){const{texture:t,version:e}=this;return e!==t.version?(this.version=t.version,!0):!1}}class lu extends YI{constructor(t,e,i,s=null){super(t,e?e.value:null),this.textureNode=e,this.groupNode=i,this.access=s}get needsBindingsUpdate(){return this.textureNode.value!==this.texture||super.needsBindingsUpdate}update(){const{textureNode:t}=this;return this.texture!==t.value?(this.texture=t.value,!0):super.update()}}class Zv extends lu{constructor(t,e,i,s){super(t,e,i,s),this.isSampledCubeTexture=!0}}class Qv extends lu{constructor(t,e,i,s){super(t,e,i,s),this.isSampledTexture3D=!0}}const ZI={[R.ATAN2]:"atan",textureDimensions:"textureSize",equals:"equal"},QI={low:"lowp",medium:"mediump",high:"highp"},ky={swizzleAssign:!0,storageBuffer:!1},Gy=`
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;class JI extends BM{constructor(t,e){super(t,e,new AI),this.uniformGroups={},this.transforms=[],this.instanceBindGroups=!1}getMethod(t){return ZI[t]||t}getOutputStructName(){return""}buildFunctionCode(t){const e=t.layout,i=this.flowShaderNode(t),s=[];for(const r of e.inputs)s.push(this.getType(r.type)+" "+r.name);return`${this.getType(e.type)} ${e.name}( ${s.join(", ")} ) {

	${i.vars}

${i.code}
	return ${i.result};

}`}setupPBO(t){const e=t.value;if(e.pbo===void 0){const i=e.array,s=e.count*e.itemSize,{itemSize:n}=e,r=e.array.constructor.name.toLowerCase().includes("int");let a=r?Pp:Cp;n===2?a=r?Ip:Fp:n===3?a=r?Sw:Ep:n===4&&(a=r?Bp:io);const l={Float32Array:qe,Uint8Array:rs,Uint16Array:Sr,Uint32Array:re,Int8Array:$o,Int16Array:qo,Int32Array:Ne,Uint8ClampedArray:rs},h=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(s/n))));let u=Math.ceil(s/n/h);h*u*n<s&&u++;const c=h*u*n,d=new i.constructor(c);d.set(i,0),e.array=d;const p=new K0(e.array,h,u,a,l[e.array.constructor.name]||qe);p.needsUpdate=!0,p.isPBOTexture=!0;const f=new zi(p,null,null);f.setPrecision("high"),e.pboNode=f,e.pbo=f.value,this.getUniformFromNode(e.pboNode,"texture",this.shaderStage,this.context.label)}}getPropertyName(t,e=this.shaderStage){return t.isNodeUniform&&t.node.isTextureNode!==!0&&t.node.isBufferNode!==!0?e.charAt(0)+"_"+t.name:super.getPropertyName(t,e)}generatePBO(t){const{node:e,indexNode:i}=t,s=e.value;if(this.renderer.backend.has(s)){const u=this.renderer.backend.get(s);u.pbo=s.pbo}const n=this.getUniformFromNode(s.pboNode,"texture",this.shaderStage,this.context.label),r=this.getPropertyName(n);i.increaseUsage(this);const a=i.build(this,"uint"),l=this.getDataFromNode(t);let h=l.propertyName;if(h===void 0){const u=this.getVarFromNode(t);h=this.getPropertyName(u);const c=this.getDataFromNode(e);let d=c.propertySizeName;d===void 0&&(d=h+"Size",this.getVarFromNode(e,d,"uint"),this.addLineFlowCode(`${d} = uint( textureSize( ${r}, 0 ).x )`),c.propertySizeName=d);const{itemSize:p}=s,f="."+Ma.join("").slice(0,p),m=`ivec2(${a} % ${d}, ${a} / ${d})`,g=this.generateTextureLoad(null,r,m,null,"0");let y="vec4";s.pbo.type===re?y="uvec4":s.pbo.type===Ne&&(y="ivec4"),this.addLineFlowCode(`${h} = ${y}(${g})${f}`),l.propertyName=h}return h}generateTextureLoad(t,e,i,s,n="0"){return s?`texelFetch( ${e}, ivec3( ${i}, ${s} ), ${n} )`:`texelFetch( ${e}, ${i}, ${n} )`}generateTexture(t,e,i,s){return t.isDepthTexture?`texture( ${e}, ${i} ).x`:(s&&(i=`vec3( ${i}, ${s} )`),`texture( ${e}, ${i} )`)}generateTextureLevel(t,e,i,s){return`textureLod( ${e}, ${i}, ${s} )`}generateTextureBias(t,e,i,s){return`texture( ${e}, ${i}, ${s} )`}generateTextureGrad(t,e,i,s){return`textureGrad( ${e}, ${i}, ${s[0]}, ${s[1]} )`}generateTextureCompare(t,e,i,s,n,r=this.shaderStage){if(r==="fragment")return`texture( ${e}, vec3( ${i}, ${s} ) )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${r} shader.`)}getVars(t){const e=[],i=this.vars[t];if(i!==void 0)for(const s of i)e.push(`${this.getVar(s.type,s.name)};`);return e.join(`
	`)}getUniforms(t){const e=this.uniforms[t],i=[],s={};for(const r of e){let a=null,l=!1;if(r.type==="texture"){const u=r.node.value;let c="";u.isDataTexture===!0&&(u.type===re?c="u":u.type===Ne&&(c="i")),u.compareFunction?a=`sampler2DShadow ${r.name};`:u.isDataArrayTexture===!0?a=`${c}sampler2DArray ${r.name};`:a=`${c}sampler2D ${r.name};`}else if(r.type==="cubeTexture")a=`samplerCube ${r.name};`;else if(r.type==="texture3D")a=`sampler3D ${r.name};`;else if(r.type==="buffer"){const u=r.node,c=this.getType(u.bufferType),d=u.bufferCount,p=d>0?d:"";a=`${u.name} {
	${c} ${r.name}[${p}];
};
`}else a=`${this.getVectorType(r.type)} ${this.getPropertyName(r,t)};`,l=!0;const h=r.node.precision;if(h!==null&&(a=QI[h]+" "+a),l){a="	"+a;const u=r.groupNode.name;(s[u]||(s[u]=[])).push(a)}else a="uniform "+a,i.push(a)}let n="";for(const r in s){const a=s[r];n+=this._getGLSLUniformStruct(t+"_"+r,a.join(`
`))+`
`}return n+=i.join(`
`),n}getTypeFromAttribute(t){let e=super.getTypeFromAttribute(t);if(/^[iu]/.test(e)&&t.gpuType!==Ne){let i=t;t.isInterleavedBufferAttribute&&(i=t.data);const s=i.array;s instanceof Uint32Array||s instanceof Int32Array||(e=e.slice(1))}return e}getAttributes(t){let e="";if(t==="vertex"||t==="compute"){const i=this.getAttributesArray();let s=0;for(const n of i)e+=`layout( location = ${s++} ) in ${n.type} ${n.name};
`}return e}getStructMembers(t){const e=[],i=t.getMemberTypes();for(let s=0;s<i.length;s++){const n=i[s];e.push(`layout( location = ${s} ) out ${n} m${s};`)}return e.join(`
`)}getStructs(t){const e=[],i=this.structs[t];if(i.length===0)return`layout( location = 0 ) out vec4 fragColor;
`;for(let s=0,n=i.length;s<n;s++){const r=i[s];let a=`
`;a+=this.getStructMembers(r),a+=`
`,e.push(a)}return e.join(`

`)}getVaryings(t){let e="";const i=this.varyings;if(t==="vertex"||t==="compute")for(const s of i){t==="compute"&&(s.needsInterpolation=!0);const n=s.type,r=n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":"";e+=`${r}${s.needsInterpolation?"out":"/*out*/"} ${n} ${s.name};
`}else if(t==="fragment"){for(const s of i)if(s.needsInterpolation){const n=s.type,r=n.includes("int")||n.includes("uv")||n.includes("iv")?"flat ":"";e+=`${r}in ${n} ${s.name};
`}}return e}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getDrawIndex(){return this.renderer.backend.extensions.has("WEBGL_multi_draw")?"uint( gl_DrawID )":null}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord"}getFragDepth(){return"gl_FragDepth"}getExtensions(t){let e="";if(t==="vertex"){const i=this.renderer.backend.extensions;this.object.isBatchedMesh&&i.has("WEBGL_multi_draw")&&(e+=`#extension GL_ANGLE_multi_draw : require
`)}return e}isAvailable(t){let e=ky[t];if(e===void 0){if(t==="float32Filterable"){const i=this.renderer.backend.extensions;i.has("OES_texture_float_linear")?(i.get("OES_texture_float_linear"),e=!0):e=!1}ky[t]=e}return e}isFlipY(){return!0}registerTransform(t,e){this.transforms.push({varyingName:t,attributeNode:e})}getTransforms(){const t=this.transforms;let e="";for(let i=0;i<t.length;i++){const s=t[i],n=this.getPropertyName(s.attributeNode);e+=`${s.varyingName} = ${n};
	`}return e}_getGLSLUniformStruct(t,e){return`
layout( std140 ) uniform ${t} {
${e}
};`}_getGLSLVertexCode(t){return`#version 300 es

// extensions 
${t.extensions}

// precision
${Gy}

// uniforms
${t.uniforms}

// varyings
${t.varyings}

// attributes
${t.attributes}

// codes
${t.codes}

void main() {

	// vars
	${t.vars}

	// transforms
	${t.transforms}

	// flow
	${t.flow}

	gl_PointSize = 1.0;

}
`}_getGLSLFragmentCode(t){return`#version 300 es

${this.getSignature()}

// precision
${Gy}

// uniforms
${t.uniforms}

// varyings
${t.varyings}

// codes
${t.codes}

${t.structs}

void main() {

	// vars
	${t.vars}

	// flow
	${t.flow}

}
`}buildCode(){const t=this.material!==null?{fragment:{},vertex:{}}:{compute:{}};for(const e in t){let i=`// code

`;i+=this.flowCode[e];const s=this.flowNodes[e],n=s[s.length-1];for(const a of s){const l=this.getFlowData(a),h=a.name;h&&(i.length>0&&(i+=`
`),i+=`	// flow -> ${h}
	`),i+=`${l.code}
	`,a===n&&e!=="compute"&&(i+=`// result
	`,e==="vertex"?(i+="gl_Position = ",i+=`${l.result};`):e==="fragment"&&(a.outputNode.isOutputStructNode||(i+="fragColor = ",i+=`${l.result};`)))}const r=t[e];r.extensions=this.getExtensions(e),r.uniforms=this.getUniforms(e),r.attributes=this.getAttributes(e),r.varyings=this.getVaryings(e),r.vars=this.getVars(e),r.structs=this.getStructs(e),r.codes=this.getCodes(e),r.transforms=this.getTransforms(e),r.flow=i}this.material!==null?(this.vertexShader=this._getGLSLVertexCode(t.vertex),this.fragmentShader=this._getGLSLFragmentCode(t.fragment)):this.computeShader=this._getGLSLVertexCode(t.compute)}getUniformFromNode(t,e,i,s=null){const n=super.getUniformFromNode(t,e,i,s),r=this.getDataFromNode(t,i,this.globalCache);let a=r.uniformGPU;if(a===void 0){const l=t.groupNode,h=l.name,u=this.getBindGroupArray(h,i);if(e==="texture")a=new lu(n.name,n.node,l),u.push(a);else if(e==="cubeTexture")a=new Zv(n.name,n.node,l),u.push(a);else if(e==="texture3D")a=new Qv(n.name,n.node,l),u.push(a);else if(e==="buffer"){t.name=`NodeBuffer_${t.id}`,n.name=`buffer${t.id}`;const c=new Xv(t,l);c.name=t.name,u.push(c),a=c}else{const c=this.uniformGroups[i]||(this.uniformGroups[i]={});let d=c[h];d===void 0&&(d=new Yv(i+"_"+h,l),c[h]=d,u.push(d)),a=this.getNodeUniform(n,e),d.addUniform(a)}r.uniformGPU=a}return n}}let Vc=null,kc=null,pr=null;class Jv{constructor(t={}){this.parameters=Object.assign({},t),this.data=new WeakMap,this.renderer=null,this.domElement=null}async init(t){this.renderer=t}begin(){}finish(){}draw(){}createProgram(){}destroyProgram(){}createBindings(){}updateBindings(){}createRenderPipeline(){}createComputePipeline(){}destroyPipeline(){}needsRenderUpdate(){}getRenderCacheKey(){}createNodeBuilder(){}createSampler(){}createDefaultTexture(){}createTexture(){}copyTextureToBuffer(){}createAttribute(){}createIndexAttribute(){}updateAttribute(){}destroyAttribute(){}getContext(){}updateSize(){}resolveTimestampAsync(){}hasFeatureAsync(){}hasFeature(){}getInstanceCount(t){const{object:e,geometry:i}=t;return i.isInstancedBufferGeometry?i.instanceCount:e.count>1?e.count:1}getDrawingBufferSize(){return Vc=Vc||new q,this.renderer.getDrawingBufferSize(Vc)}getScissor(){return kc=kc||new _t,this.renderer.getScissor(kc)}setScissorTest(){}getClearColor(){const t=this.renderer;return pr=pr||new _f,t.getClearColor(pr),pr.getRGB(pr,this.renderer.currentColorSpace),pr}getDomElement(){let t=this.domElement;return t===null&&(t=this.parameters.canvas!==void 0?this.parameters.canvas:a1(),"setAttribute"in t&&t.setAttribute("data-engine",`three.js r${vn} webgpu`),this.domElement=t),t}set(t,e){this.data.set(t,e)}get(t){let e=this.data.get(t);return e===void 0&&(e={},this.data.set(t,e)),e}has(t){return this.data.has(t)}delete(t){this.data.delete(t)}}let KI=0;class tB{constructor(t,e){this.buffers=[t.bufferGPU,e],this.type=t.type,this.bufferType=t.bufferType,this.pbo=t.pbo,this.byteLength=t.byteLength,this.bytesPerElement=t.BYTES_PER_ELEMENT,this.version=t.version,this.isInteger=t.isInteger,this.activeBufferIndex=0,this.baseId=t.id}get id(){return`${this.baseId}|${this.activeBufferIndex}`}get bufferGPU(){return this.buffers[this.activeBufferIndex]}get transformBuffer(){return this.buffers[this.activeBufferIndex^1]}switchBuffers(){this.activeBufferIndex^=1}}class eB{constructor(t){this.backend=t}createAttribute(t,e){const i=this.backend,{gl:s}=i,n=t.array,r=t.usage||s.STATIC_DRAW,a=t.isInterleavedBufferAttribute?t.data:t,l=i.get(a);let h=l.bufferGPU;h===void 0&&(h=this._createBuffer(s,e,n,r),l.bufferGPU=h,l.bufferType=e,l.version=a.version);let u;if(n instanceof Float32Array)u=s.FLOAT;else if(n instanceof Uint16Array)t.isFloat16BufferAttribute?u=s.HALF_FLOAT:u=s.UNSIGNED_SHORT;else if(n instanceof Int16Array)u=s.SHORT;else if(n instanceof Uint32Array)u=s.UNSIGNED_INT;else if(n instanceof Int32Array)u=s.INT;else if(n instanceof Int8Array)u=s.BYTE;else if(n instanceof Uint8Array)u=s.UNSIGNED_BYTE;else if(n instanceof Uint8ClampedArray)u=s.UNSIGNED_BYTE;else throw new Error("THREE.WebGLBackend: Unsupported buffer data format: "+n);let c={bufferGPU:h,bufferType:e,type:u,byteLength:n.byteLength,bytesPerElement:n.BYTES_PER_ELEMENT,version:t.version,pbo:t.pbo,isInteger:u===s.INT||u===s.UNSIGNED_INT||t.gpuType===Ne,id:KI++};if(t.isStorageBufferAttribute||t.isStorageInstancedBufferAttribute){const d=this._createBuffer(s,e,n,r);c=new tB(c,d)}i.set(t,c)}updateAttribute(t){const e=this.backend,{gl:i}=e,s=t.array,n=t.isInterleavedBufferAttribute?t.data:t,r=e.get(n),a=r.bufferType,l=t.isInterleavedBufferAttribute?t.data.updateRanges:t.updateRanges;if(i.bindBuffer(a,r.bufferGPU),l.length===0)i.bufferSubData(a,0,s);else{for(let h=0,u=l.length;h<u;h++){const c=l[h];i.bufferSubData(a,c.start*s.BYTES_PER_ELEMENT,s,c.start,c.count)}n.clearUpdateRanges()}i.bindBuffer(a,null),r.version=n.version}destroyAttribute(t){const e=this.backend,{gl:i}=e;t.isInterleavedBufferAttribute&&e.delete(t.data);const s=e.get(t);i.deleteBuffer(s.bufferGPU),e.delete(t)}async getArrayBufferAsync(t){const e=this.backend,{gl:i}=e,s=t.isInterleavedBufferAttribute?t.data:t,{bufferGPU:n}=e.get(s),r=t.array,a=r.byteLength;i.bindBuffer(i.COPY_READ_BUFFER,n);const l=i.createBuffer();i.bindBuffer(i.COPY_WRITE_BUFFER,l),i.bufferData(i.COPY_WRITE_BUFFER,a,i.STREAM_READ),i.copyBufferSubData(i.COPY_READ_BUFFER,i.COPY_WRITE_BUFFER,0,0,a),await e.utils._clientWaitAsync();const h=new t.array.constructor(r.length);return i.getBufferSubData(i.COPY_WRITE_BUFFER,0,h),i.deleteBuffer(l),h.buffer}_createBuffer(t,e,i,s){const n=t.createBuffer();return t.bindBuffer(e,n),t.bufferData(e,i,s),t.bindBuffer(e,null),n}}let Wy=!1,Gc,Bo;class iB{constructor(t){this.backend=t,this.gl=this.backend.gl,this.enabled={},this.currentFlipSided=null,this.currentCullFace=null,this.currentProgram=null,this.currentBlendingEnabled=!1,this.currentBlending=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipledAlpha=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentColorMask=null,this.currentDepthFunc=null,this.currentDepthMask=null,this.currentStencilFunc=null,this.currentStencilRef=null,this.currentStencilFuncMask=null,this.currentStencilFail=null,this.currentStencilZFail=null,this.currentStencilZPass=null,this.currentStencilMask=null,this.currentLineWidth=null,this.currentBoundFramebuffers={},this.currentDrawbuffers=new WeakMap,this.maxTextures=this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.currentTextureSlot=null,this.currentBoundTextures={},Wy===!1&&(this._init(this.gl),Wy=!0)}_init(t){Gc={[Bs]:t.FUNC_ADD,[h0]:t.FUNC_SUBTRACT,[u0]:t.FUNC_REVERSE_SUBTRACT},Bo={[c0]:t.ZERO,[d0]:t.ONE,[p0]:t.SRC_COLOR,[dh]:t.SRC_ALPHA,[_0]:t.SRC_ALPHA_SATURATE,[y0]:t.DST_COLOR,[m0]:t.DST_ALPHA,[f0]:t.ONE_MINUS_SRC_COLOR,[ph]:t.ONE_MINUS_SRC_ALPHA,[x0]:t.ONE_MINUS_DST_COLOR,[g0]:t.ONE_MINUS_DST_ALPHA}}enable(t){const{enabled:e}=this;e[t]!==!0&&(this.gl.enable(t),e[t]=!0)}disable(t){const{enabled:e}=this;e[t]!==!1&&(this.gl.disable(t),e[t]=!1)}setFlipSided(t){if(this.currentFlipSided!==t){const{gl:e}=this;t?e.frontFace(e.CW):e.frontFace(e.CCW),this.currentFlipSided=t}}setCullFace(t){const{gl:e}=this;t!==nw?(this.enable(e.CULL_FACE),t!==this.currentCullFace&&(t===rw?e.cullFace(e.BACK):t===ow?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):this.disable(e.CULL_FACE),this.currentCullFace=t}setLineWidth(t){const{currentLineWidth:e,gl:i}=this;t!==e&&(i.lineWidth(t),this.currentLineWidth=t)}setBlending(t,e,i,s,n,r,a,l){const{gl:h}=this;if(t===Wr){this.currentBlendingEnabled===!0&&(this.disable(h.BLEND),this.currentBlendingEnabled=!1);return}if(this.currentBlendingEnabled===!1&&(this.enable(h.BLEND),this.currentBlendingEnabled=!0),t!==l0){if(t!==this.currentBlending||l!==this.currentPremultipledAlpha){if((this.currentBlendEquation!==Bs||this.currentBlendEquationAlpha!==Bs)&&(h.blendEquation(h.FUNC_ADD),this.currentBlendEquation=Bs,this.currentBlendEquationAlpha=Bs),l)switch(t){case os:h.blendFuncSeparate(h.ONE,h.ONE_MINUS_SRC_ALPHA,h.ONE,h.ONE_MINUS_SRC_ALPHA);break;case hh:h.blendFunc(h.ONE,h.ONE);break;case uh:h.blendFuncSeparate(h.ZERO,h.ONE_MINUS_SRC_COLOR,h.ZERO,h.ONE);break;case ch:h.blendFuncSeparate(h.ZERO,h.SRC_COLOR,h.ZERO,h.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}else switch(t){case os:h.blendFuncSeparate(h.SRC_ALPHA,h.ONE_MINUS_SRC_ALPHA,h.ONE,h.ONE_MINUS_SRC_ALPHA);break;case hh:h.blendFunc(h.SRC_ALPHA,h.ONE);break;case uh:h.blendFuncSeparate(h.ZERO,h.ONE_MINUS_SRC_COLOR,h.ZERO,h.ONE);break;case ch:h.blendFunc(h.ZERO,h.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",t);break}this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentBlending=t,this.currentPremultipledAlpha=l}return}n=n||e,r=r||i,a=a||s,(e!==this.currentBlendEquation||n!==this.currentBlendEquationAlpha)&&(h.blendEquationSeparate(Gc[e],Gc[n]),this.currentBlendEquation=e,this.currentBlendEquationAlpha=n),(i!==this.currentBlendSrc||s!==this.currentBlendDst||r!==this.currentBlendSrcAlpha||a!==this.currentBlendDstAlpha)&&(h.blendFuncSeparate(Bo[i],Bo[s],Bo[r],Bo[a]),this.currentBlendSrc=i,this.currentBlendDst=s,this.currentBlendSrcAlpha=r,this.currentBlendDstAlpha=a),this.currentBlending=t,this.currentPremultipledAlpha=!1}setColorMask(t){this.currentColorMask!==t&&(this.gl.colorMask(t,t,t,t),this.currentColorMask=t)}setDepthTest(t){const{gl:e}=this;t?this.enable(e.DEPTH_TEST):this.disable(e.DEPTH_TEST)}setDepthMask(t){this.currentDepthMask!==t&&(this.gl.depthMask(t),this.currentDepthMask=t)}setDepthFunc(t){if(this.currentDepthFunc!==t){const{gl:e}=this;switch(t){case M0:e.depthFunc(e.NEVER);break;case v0:e.depthFunc(e.ALWAYS);break;case T0:e.depthFunc(e.LESS);break;case fh:e.depthFunc(e.LEQUAL);break;case b0:e.depthFunc(e.EQUAL);break;case S0:e.depthFunc(e.GEQUAL);break;case w0:e.depthFunc(e.GREATER);break;case A0:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}this.currentDepthFunc=t}}setStencilTest(t){const{gl:e}=this;t?this.enable(e.STENCIL_TEST):this.disable(e.STENCIL_TEST)}setStencilMask(t){this.currentStencilMask!==t&&(this.gl.stencilMask(t),this.currentStencilMask=t)}setStencilFunc(t,e,i){(this.currentStencilFunc!==t||this.currentStencilRef!==e||this.currentStencilFuncMask!==i)&&(this.gl.stencilFunc(t,e,i),this.currentStencilFunc=t,this.currentStencilRef=e,this.currentStencilFuncMask=i)}setStencilOp(t,e,i){(this.currentStencilFail!==t||this.currentStencilZFail!==e||this.currentStencilZPass!==i)&&(this.gl.stencilOp(t,e,i),this.currentStencilFail=t,this.currentStencilZFail=e,this.currentStencilZPass=i)}setMaterial(t,e){const{gl:i}=this;t.side===lh?this.disable(i.CULL_FACE):this.enable(i.CULL_FACE);let s=t.side===ms;e&&(s=!s),this.setFlipSided(s),t.blending===os&&t.transparent===!1?this.setBlending(Wr):this.setBlending(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),this.setDepthFunc(t.depthFunc),this.setDepthTest(t.depthTest),this.setDepthMask(t.depthWrite),this.setColorMask(t.colorWrite);const n=t.stencilWrite;this.setStencilTest(n),n&&(this.setStencilMask(t.stencilWriteMask),this.setStencilFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),this.setStencilOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),this.setPolygonOffset(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),t.alphaToCoverage===!0?this.enable(i.SAMPLE_ALPHA_TO_COVERAGE):this.disable(i.SAMPLE_ALPHA_TO_COVERAGE)}setPolygonOffset(t,e,i){const{gl:s}=this;t?(this.enable(s.POLYGON_OFFSET_FILL),(this.currentPolygonOffsetFactor!==e||this.currentPolygonOffsetUnits!==i)&&(s.polygonOffset(e,i),this.currentPolygonOffsetFactor=e,this.currentPolygonOffsetUnits=i)):this.disable(s.POLYGON_OFFSET_FILL)}useProgram(t){return this.currentProgram!==t?(this.gl.useProgram(t),this.currentProgram=t,!0):!1}bindFramebuffer(t,e){const{gl:i,currentBoundFramebuffers:s}=this;return s[t]!==e?(i.bindFramebuffer(t,e),s[t]=e,t===i.DRAW_FRAMEBUFFER&&(s[i.FRAMEBUFFER]=e),t===i.FRAMEBUFFER&&(s[i.DRAW_FRAMEBUFFER]=e),!0):!1}drawBuffers(t,e){const{gl:i}=this;let s=[],n=!1;if(t.textures!==null){s=this.currentDrawbuffers.get(e),s===void 0&&(s=[],this.currentDrawbuffers.set(e,s));const r=t.textures;if(s.length!==r.length||s[0]!==i.COLOR_ATTACHMENT0){for(let a=0,l=r.length;a<l;a++)s[a]=i.COLOR_ATTACHMENT0+a;s.length=r.length,n=!0}}else s[0]!==i.BACK&&(s[0]=i.BACK,n=!0);n&&i.drawBuffers(s)}activeTexture(t){const{gl:e,currentTextureSlot:i,maxTextures:s}=this;t===void 0&&(t=e.TEXTURE0+s-1),i!==t&&(e.activeTexture(t),this.currentTextureSlot=t)}bindTexture(t,e,i){const{gl:s,currentTextureSlot:n,currentBoundTextures:r,maxTextures:a}=this;i===void 0&&(n===null?i=s.TEXTURE0+a-1:i=n);let l=r[i];l===void 0&&(l={type:void 0,texture:void 0},r[i]=l),(l.type!==t||l.texture!==e)&&(n!==i&&(s.activeTexture(i),this.currentTextureSlot=i),s.bindTexture(t,e),l.type=t,l.texture=e)}unbindTexture(){const{gl:t,currentTextureSlot:e,currentBoundTextures:i}=this,s=i[e];s!==void 0&&s.type!==void 0&&(t.bindTexture(s.type,null),s.type=void 0,s.texture=void 0)}}class sB{constructor(t){this.backend=t,this.gl=this.backend.gl,this.extensions=t.extensions}convert(t,e=ga){const{gl:i,extensions:s}=this;let n;if(t===rs)return i.UNSIGNED_BYTE;if(t===_w)return i.UNSIGNED_SHORT_4_4_4_4;if(t===Mw)return i.UNSIGNED_SHORT_5_5_5_1;if(t===R0)return i.UNSIGNED_INT_5_9_9_9_REV;if(t===$o)return i.BYTE;if(t===qo)return i.SHORT;if(t===Sr)return i.UNSIGNED_SHORT;if(t===Ne)return i.INT;if(t===re)return i.UNSIGNED_INT;if(t===qe)return i.FLOAT;if(t===wi)return i.HALF_FLOAT;if(t===vw)return i.ALPHA;if(t===Ep)return i.RGB;if(t===io)return i.RGBA;if(t===Tw)return i.LUMINANCE;if(t===bw)return i.LUMINANCE_ALPHA;if(t===yn)return i.DEPTH_COMPONENT;if(t===qr)return i.DEPTH_STENCIL;if(t===Cp)return i.RED;if(t===Pp)return i.RED_INTEGER;if(t===Fp)return i.RG;if(t===Ip)return i.RG_INTEGER;if(t===Bp)return i.RGBA_INTEGER;if(t===Du||t===$l||t===ql||t===jl)if(e===j)if(n=s.get("WEBGL_compressed_texture_s3tc_srgb"),n!==null){if(t===Du)return n.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===$l)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===ql)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===jl)return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(n=s.get("WEBGL_compressed_texture_s3tc"),n!==null){if(t===Du)return n.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===$l)return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===ql)return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===jl)return n.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(t===eg||t===ig||t===sg||t===ng)if(n=s.get("WEBGL_compressed_texture_pvrtc"),n!==null){if(t===eg)return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===ig)return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===sg)return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===ng)return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(t===rg||t===gd||t===yd)if(n=s.get("WEBGL_compressed_texture_etc"),n!==null){if(t===rg||t===gd)return e===j?n.COMPRESSED_SRGB8_ETC2:n.COMPRESSED_RGB8_ETC2;if(t===yd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:n.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(t===xd||t===_d||t===Md||t===vd||t===Td||t===bd||t===Sd||t===wd||t===Ad||t===Nd||t===Rd||t===Ed||t===Cd||t===Pd)if(n=s.get("WEBGL_compressed_texture_astc"),n!==null){if(t===xd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:n.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===_d)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:n.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===Md)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:n.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===vd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:n.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Td)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:n.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===bd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:n.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Sd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:n.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===wd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:n.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===Ad)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:n.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Nd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:n.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===Rd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:n.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===Ed)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:n.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===Cd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:n.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===Pd)return e===j?n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:n.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(t===Ou)if(n=s.get("EXT_texture_compression_bptc"),n!==null){if(t===Ou)return e===j?n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:n.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(t===ww||t===og||t===ag||t===lg)if(n=s.get("EXT_texture_compression_rgtc"),n!==null){if(t===Ou)return n.COMPRESSED_RED_RGTC1_EXT;if(t===og)return n.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(t===ag)return n.COMPRESSED_RED_GREEN_RGTC2_EXT;if(t===lg)return n.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return t===ma?i.UNSIGNED_INT_24_8:i[t]!==void 0?i[t]:null}_clientWaitAsync(){const{gl:t}=this,e=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),new Promise((i,s)=>{function n(){const r=t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0);if(r===t.WAIT_FAILED){t.deleteSync(e),s();return}if(r===t.TIMEOUT_EXPIRED){requestAnimationFrame(n);return}t.deleteSync(e),i()}n()})}}let Hy=!1,Ll,Wc,$y;class nB{constructor(t){this.backend=t,this.gl=t.gl,this.extensions=t.extensions,this.defaultTextures={},Hy===!1&&(this._init(this.gl),Hy=!0)}_init(t){Ll={[$r]:t.REPEAT,[br]:t.CLAMP_TO_EDGE,[mh]:t.MIRRORED_REPEAT},Wc={[ce]:t.NEAREST,[fd]:t.NEAREST_MIPMAP_NEAREST,[Lr]:t.NEAREST_MIPMAP_LINEAR,[Le]:t.LINEAR,[md]:t.LINEAR_MIPMAP_NEAREST,[as]:t.LINEAR_MIPMAP_LINEAR},$y={[F0]:t.NEVER,[O0]:t.ALWAYS,[Up]:t.LESS,[B0]:t.LEQUAL,[I0]:t.EQUAL,[D0]:t.GEQUAL,[L0]:t.GREATER,[U0]:t.NOTEQUAL}}filterFallback(t){const{gl:e}=this;return t===ce||t===fd||t===Lr?e.NEAREST:e.LINEAR}getGLTextureType(t){const{gl:e}=this;let i;return t.isCubeTexture===!0?i=e.TEXTURE_CUBE_MAP:t.isDataArrayTexture===!0?i=e.TEXTURE_2D_ARRAY:t.isData3DTexture===!0?i=e.TEXTURE_3D:i=e.TEXTURE_2D,i}getInternalFormat(t,e,i,s,n=!1){const{gl:r,extensions:a}=this;if(t!==null){if(r[t]!==void 0)return r[t];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+t+"'")}let l=e;return e===r.RED&&(i===r.FLOAT&&(l=r.R32F),i===r.HALF_FLOAT&&(l=r.R16F),i===r.UNSIGNED_BYTE&&(l=r.R8),i===r.UNSIGNED_SHORT&&(l=r.R16),i===r.UNSIGNED_INT&&(l=r.R32UI),i===r.BYTE&&(l=r.R8I),i===r.SHORT&&(l=r.R16I),i===r.INT&&(l=r.R32I)),e===r.RED_INTEGER&&(i===r.UNSIGNED_BYTE&&(l=r.R8UI),i===r.UNSIGNED_SHORT&&(l=r.R16UI),i===r.UNSIGNED_INT&&(l=r.R32UI),i===r.BYTE&&(l=r.R8I),i===r.SHORT&&(l=r.R16I),i===r.INT&&(l=r.R32I)),e===r.RG&&(i===r.FLOAT&&(l=r.RG32F),i===r.HALF_FLOAT&&(l=r.RG16F),i===r.UNSIGNED_BYTE&&(l=r.RG8),i===r.UNSIGNED_SHORT&&(l=r.RG16),i===r.UNSIGNED_INT&&(l=r.RG32UI),i===r.BYTE&&(l=r.RG8I),i===r.SHORT&&(l=r.RG16I),i===r.INT&&(l=r.RG32I)),e===r.RG_INTEGER&&(i===r.UNSIGNED_BYTE&&(l=r.RG8UI),i===r.UNSIGNED_SHORT&&(l=r.RG16UI),i===r.UNSIGNED_INT&&(l=r.RG32UI),i===r.BYTE&&(l=r.RG8I),i===r.SHORT&&(l=r.RG16I),i===r.INT&&(l=r.RG32I)),e===r.RGB&&(i===r.FLOAT&&(l=r.RGB32F),i===r.HALF_FLOAT&&(l=r.RGB16F),i===r.UNSIGNED_BYTE&&(l=r.RGB8),i===r.UNSIGNED_SHORT&&(l=r.RGB16),i===r.UNSIGNED_INT&&(l=r.RGB32UI),i===r.BYTE&&(l=r.RGB8I),i===r.SHORT&&(l=r.RGB16I),i===r.INT&&(l=r.RGB32I),i===r.UNSIGNED_BYTE&&(l=s===j&&n===!1?r.SRGB8:r.RGB8),i===r.UNSIGNED_SHORT_5_6_5&&(l=r.RGB565),i===r.UNSIGNED_SHORT_5_5_5_1&&(l=r.RGB5_A1),i===r.UNSIGNED_SHORT_4_4_4_4&&(l=r.RGB4),i===r.UNSIGNED_INT_5_9_9_9_REV&&(l=r.RGB9_E5)),e===r.RGB_INTEGER&&(i===r.UNSIGNED_BYTE&&(l=r.RGB8UI),i===r.UNSIGNED_SHORT&&(l=r.RGB16UI),i===r.UNSIGNED_INT&&(l=r.RGB32UI),i===r.BYTE&&(l=r.RGB8I),i===r.SHORT&&(l=r.RGB16I),i===r.INT&&(l=r.RGB32I)),e===r.RGBA&&(i===r.FLOAT&&(l=r.RGBA32F),i===r.HALF_FLOAT&&(l=r.RGBA16F),i===r.UNSIGNED_BYTE&&(l=r.RGBA8),i===r.UNSIGNED_SHORT&&(l=r.RGBA16),i===r.UNSIGNED_INT&&(l=r.RGBA32UI),i===r.BYTE&&(l=r.RGBA8I),i===r.SHORT&&(l=r.RGBA16I),i===r.INT&&(l=r.RGBA32I),i===r.UNSIGNED_BYTE&&(l=s===j&&n===!1?r.SRGB8_ALPHA8:r.RGBA8),i===r.UNSIGNED_SHORT_4_4_4_4&&(l=r.RGBA4),i===r.UNSIGNED_SHORT_5_5_5_1&&(l=r.RGB5_A1)),e===r.RGBA_INTEGER&&(i===r.UNSIGNED_BYTE&&(l=r.RGBA8UI),i===r.UNSIGNED_SHORT&&(l=r.RGBA16UI),i===r.UNSIGNED_INT&&(l=r.RGBA32UI),i===r.BYTE&&(l=r.RGBA8I),i===r.SHORT&&(l=r.RGBA16I),i===r.INT&&(l=r.RGBA32I)),e===r.DEPTH_COMPONENT&&(i===r.UNSIGNED_INT&&(l=r.DEPTH24_STENCIL8),i===r.FLOAT&&(l=r.DEPTH_COMPONENT32F)),e===r.DEPTH_STENCIL&&i===r.UNSIGNED_INT_24_8&&(l=r.DEPTH24_STENCIL8),(l===r.R16F||l===r.R32F||l===r.RG16F||l===r.RG32F||l===r.RGBA16F||l===r.RGBA32F)&&a.get("EXT_color_buffer_float"),l}setTextureParameters(t,e){const{gl:i,extensions:s,backend:n}=this,{currentAnisotropy:r}=n.get(e);i.texParameteri(t,i.TEXTURE_WRAP_S,Ll[e.wrapS]),i.texParameteri(t,i.TEXTURE_WRAP_T,Ll[e.wrapT]),(t===i.TEXTURE_3D||t===i.TEXTURE_2D_ARRAY)&&i.texParameteri(t,i.TEXTURE_WRAP_R,Ll[e.wrapR]),i.texParameteri(t,i.TEXTURE_MAG_FILTER,Wc[e.magFilter]);const a=!e.isVideoTexture&&e.minFilter===Le?as:e.minFilter;if(i.texParameteri(t,i.TEXTURE_MIN_FILTER,Wc[a]),e.compareFunction&&(i.texParameteri(t,i.TEXTURE_COMPARE_MODE,i.COMPARE_REF_TO_TEXTURE),i.texParameteri(t,i.TEXTURE_COMPARE_FUNC,$y[e.compareFunction])),s.has("EXT_texture_filter_anisotropic")===!0){if(e.magFilter===ce||e.minFilter!==Lr&&e.minFilter!==as||e.type===qe&&s.has("OES_texture_float_linear")===!1)return;if(e.anisotropy>1||r!==e.anisotropy){const l=s.get("EXT_texture_filter_anisotropic");i.texParameterf(t,l.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(e.anisotropy,n.getMaxAnisotropy())),n.get(e).currentAnisotropy=e.anisotropy}}}createDefaultTexture(t){const{gl:e,backend:i,defaultTextures:s}=this,n=this.getGLTextureType(t);let r=s[n];r===void 0&&(r=e.createTexture(),i.state.bindTexture(n,r),e.texParameteri(n,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(n,e.TEXTURE_MAG_FILTER,e.NEAREST),s[n]=r),i.set(t,{textureGPU:r,glTextureType:n,isDefault:!0})}createTexture(t,e){const{gl:i,backend:s}=this,{levels:n,width:r,height:a,depth:l}=e,h=s.utils.convert(t.format,t.colorSpace),u=s.utils.convert(t.type),c=this.getInternalFormat(t.internalFormat,h,u,t.colorSpace,t.isVideoTexture),d=i.createTexture(),p=this.getGLTextureType(t);s.state.bindTexture(p,d),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,t.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,t.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,i.NONE),this.setTextureParameters(p,t),t.isDataArrayTexture?i.texStorage3D(i.TEXTURE_2D_ARRAY,n,c,r,a,l):t.isData3DTexture?i.texStorage3D(i.TEXTURE_3D,n,c,r,a,l):t.isVideoTexture||i.texStorage2D(p,n,c,r,a),s.set(t,{textureGPU:d,glTextureType:p,glFormat:h,glType:u,glInternalFormat:c})}copyBufferToTexture(t,e){const{gl:i,backend:s}=this,{textureGPU:n,glTextureType:r,glFormat:a,glType:l}=s.get(e),{width:h,height:u}=e.source.data;i.bindBuffer(i.PIXEL_UNPACK_BUFFER,t),s.state.bindTexture(r,n),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,!1),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),i.texSubImage2D(r,0,0,0,h,u,a,l,0),i.bindBuffer(i.PIXEL_UNPACK_BUFFER,null),s.state.unbindTexture()}updateTexture(t,e){const{gl:i}=this,{width:s,height:n}=e,{textureGPU:r,glTextureType:a,glFormat:l,glType:h,glInternalFormat:u}=this.backend.get(t);if(t.isRenderTargetTexture||r===void 0)return;const c=d=>d.isDataTexture?d.image.data:d instanceof ImageBitmap||d instanceof OffscreenCanvas||d instanceof HTMLImageElement||d instanceof HTMLCanvasElement?d:d.data;if(this.backend.state.bindTexture(a,r),t.isCompressedTexture){const d=t.mipmaps;for(let p=0;p<d.length;p++){const f=d[p];if(t.isCompressedArrayTexture){const m=e.image;t.format!==i.RGBA?l!==null?i.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY,p,0,0,0,f.width,f.height,m.depth,l,f.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):i.texSubImage3D(i.TEXTURE_2D_ARRAY,p,0,0,0,f.width,f.height,m.depth,l,h,f.data)}else l!==null?i.compressedTexSubImage2D(i.TEXTURE_2D,p,0,0,f.width,f.height,l,f.data):console.warn("Unsupported compressed texture format")}}else if(t.isCubeTexture){const d=e.images;for(let p=0;p<6;p++){const f=c(d[p]);i.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+p,0,0,0,s,n,l,h,f)}}else if(t.isDataArrayTexture){const d=e.image;i.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,0,d.width,d.height,d.depth,l,h,d.data)}else if(t.isData3DTexture){const d=e.image;i.texSubImage3D(i.TEXTURE_3D,0,0,0,0,d.width,d.height,d.depth,l,h,d.data)}else if(t.isVideoTexture)t.update(),i.texImage2D(a,0,u,l,h,e.image);else{const d=c(e.image);i.texSubImage2D(a,0,0,0,s,n,l,h,d)}}generateMipmaps(t){const{gl:e,backend:i}=this,{textureGPU:s,glTextureType:n}=i.get(t);i.state.bindTexture(n,s),e.generateMipmap(n)}deallocateRenderBuffers(t){const{gl:e,backend:i}=this;if(t){const s=i.get(t);if(s.renderBufferStorageSetup=void 0,s.framebuffer&&(e.deleteFramebuffer(s.framebuffer),s.framebuffer=void 0),s.depthRenderbuffer&&(e.deleteRenderbuffer(s.depthRenderbuffer),s.depthRenderbuffer=void 0),s.stencilRenderbuffer&&(e.deleteRenderbuffer(s.stencilRenderbuffer),s.stencilRenderbuffer=void 0),s.msaaFrameBuffer&&(e.deleteFramebuffer(s.msaaFrameBuffer),s.msaaFrameBuffer=void 0),s.msaaRenderbuffers){for(let n=0;n<s.msaaRenderbuffers.length;n++)e.deleteRenderbuffer(s.msaaRenderbuffers[n]);s.msaaRenderbuffers=void 0}}}destroyTexture(t){const{gl:e,backend:i}=this,{textureGPU:s,renderTarget:n}=i.get(t);this.deallocateRenderBuffers(n),e.deleteTexture(s),i.delete(t)}copyTextureToTexture(t,e,i=null,s=null,n=0){const{gl:r,backend:a}=this,{state:l}=this.backend,{textureGPU:h,glTextureType:u,glType:c,glFormat:d}=a.get(e);let p,f,m,g,y,x;i!==null?(p=i.max.x-i.min.x,f=i.max.y-i.min.y,m=i.min.x,g=i.min.y):(p=t.image.width,f=t.image.height,m=0,g=0),s!==null?(y=s.x,x=s.y):(y=0,x=0),l.bindTexture(u,h),r.pixelStorei(r.UNPACK_ALIGNMENT,e.unpackAlignment),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,e.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,e.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,e.unpackAlignment);const M=r.getParameter(r.UNPACK_ROW_LENGTH),_=r.getParameter(r.UNPACK_IMAGE_HEIGHT),v=r.getParameter(r.UNPACK_SKIP_PIXELS),A=r.getParameter(r.UNPACK_SKIP_ROWS),T=r.getParameter(r.UNPACK_SKIP_IMAGES),w=t.isCompressedTexture?t.mipmaps[n]:t.image;r.pixelStorei(r.UNPACK_ROW_LENGTH,w.width),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,w.height),r.pixelStorei(r.UNPACK_SKIP_PIXELS,m),r.pixelStorei(r.UNPACK_SKIP_ROWS,g),t.isDataTexture?r.texSubImage2D(r.TEXTURE_2D,n,y,x,p,f,d,c,w.data):t.isCompressedTexture?r.compressedTexSubImage2D(r.TEXTURE_2D,n,y,x,w.width,w.height,d,w.data):r.texSubImage2D(r.TEXTURE_2D,n,y,x,p,f,d,c,w),r.pixelStorei(r.UNPACK_ROW_LENGTH,M),r.pixelStorei(r.UNPACK_IMAGE_HEIGHT,_),r.pixelStorei(r.UNPACK_SKIP_PIXELS,v),r.pixelStorei(r.UNPACK_SKIP_ROWS,A),r.pixelStorei(r.UNPACK_SKIP_IMAGES,T),n===0&&e.generateMipmaps&&r.generateMipmap(r.TEXTURE_2D),l.unbindTexture()}copyFramebufferToTexture(t,e){const{gl:i}=this,{state:s}=this.backend,{textureGPU:n}=this.backend.get(t),r=t.image.width,a=t.image.height;if(t.isDepthTexture===!0||e.renderTarget&&e.renderTarget.samples>0){let h,u;t.isDepthTexture===!0?(h=i.DEPTH_BUFFER_BIT,u=i.DEPTH_ATTACHMENT,e.stencil&&(h|=i.STENCIL_BUFFER_BIT)):(h=i.COLOR_BUFFER_BIT,u=i.COLOR_ATTACHMENT0);const c=i.createFramebuffer();s.bindFramebuffer(i.DRAW_FRAMEBUFFER,c),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,u,i.TEXTURE_2D,n,0),i.blitFramebuffer(0,0,r,a,0,0,r,a,h,i.NEAREST),i.deleteFramebuffer(c)}else s.bindTexture(i.TEXTURE_2D,n),i.copyTexSubImage2D(i.TEXTURE_2D,0,0,0,0,0,r,a),s.unbindTexture();t.generateMipmaps&&this.generateMipmaps(t),this.backend._setFramebuffer(e)}setupRenderBufferStorage(t,e){const{gl:i}=this,s=e.renderTarget,{samples:n,depthTexture:r,depthBuffer:a,stencilBuffer:l,width:h,height:u}=s;if(i.bindRenderbuffer(i.RENDERBUFFER,t),a&&!l){let c=i.DEPTH_COMPONENT24;n>0?(r&&r.isDepthTexture&&r.type===i.FLOAT&&(c=i.DEPTH_COMPONENT32F),i.renderbufferStorageMultisample(i.RENDERBUFFER,n,c,h,u)):i.renderbufferStorage(i.RENDERBUFFER,c,h,u),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.RENDERBUFFER,t)}else a&&l&&(n>0?i.renderbufferStorageMultisample(i.RENDERBUFFER,n,i.DEPTH24_STENCIL8,h,u):i.renderbufferStorage(i.RENDERBUFFER,i.DEPTH_STENCIL,h,u),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.RENDERBUFFER,t))}async copyTextureToBuffer(t,e,i,s,n){const{backend:r,gl:a}=this,{textureGPU:l,glFormat:h,glType:u}=this.backend.get(t),c=a.createFramebuffer();a.bindFramebuffer(a.READ_FRAMEBUFFER,c),a.framebufferTexture2D(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,l,0);const d=this._getTypedArrayType(u),p=this._getBytesPerTexel(h),m=s*n*p,g=a.createBuffer();a.bindBuffer(a.PIXEL_PACK_BUFFER,g),a.bufferData(a.PIXEL_PACK_BUFFER,m,a.STREAM_READ),a.readPixels(e,i,s,n,h,u,0),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),await r.utils._clientWaitAsync();const y=new d(m/d.BYTES_PER_ELEMENT);return a.bindBuffer(a.PIXEL_PACK_BUFFER,g),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,y),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),a.deleteFramebuffer(c),y}_getTypedArrayType(t){const{gl:e}=this;if(t===e.UNSIGNED_BYTE)return Uint8Array;if(t===e.UNSIGNED_SHORT_4_4_4_4||t===e.UNSIGNED_SHORT_5_5_5_1||t===e.UNSIGNED_SHORT_5_6_5||t===e.UNSIGNED_SHORT)return Uint16Array;if(t===e.UNSIGNED_INT)return Uint32Array;if(t===e.FLOAT)return Float32Array;throw new Error(`Unsupported WebGL type: ${t}`)}_getBytesPerTexel(t){const{gl:e}=this;if(t===e.RGBA)return 4;if(t===e.RGB)return 3;if(t===e.ALPHA)return 1}}class rB{constructor(t){this.backend=t,this.gl=this.backend.gl,this.availableExtensions=this.gl.getSupportedExtensions(),this.extensions={}}get(t){let e=this.extensions[t];return e===void 0&&(e=this.gl.getExtension(t),this.extensions[t]=e),e}has(t){return this.availableExtensions.includes(t)}}class oB{constructor(t){this.backend=t,this.maxAnisotropy=null}getMaxAnisotropy(){if(this.maxAnisotropy!==null)return this.maxAnisotropy;const t=this.backend.gl,e=this.backend.extensions;if(e.has("EXT_texture_filter_anisotropic")===!0){const i=e.get("EXT_texture_filter_anisotropic");this.maxAnisotropy=t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else this.maxAnisotropy=0;return this.maxAnisotropy}}const qy={WEBGL_multi_draw:"WEBGL_multi_draw",WEBGL_compressed_texture_astc:"texture-compression-astc",WEBGL_compressed_texture_etc:"texture-compression-etc2",WEBGL_compressed_texture_etc1:"texture-compression-etc1",WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBKIT_WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBGL_compressed_texture_s3tc:"texture-compression-bc",EXT_texture_compression_bptc:"texture-compression-bptc",EXT_disjoint_timer_query_webgl2:"timestamp-query"};class aB{constructor(t){this.gl=t.gl,this.extensions=t.extensions,this.info=t.renderer.info,this.mode=null,this.index=0,this.type=null,this.object=null}render(t,e){const{gl:i,mode:s,object:n,type:r,info:a,index:l}=this;l!==0?i.drawElements(s,e,r,t):i.drawArrays(s,t,e),a.update(n,e,s,1)}renderInstances(t,e,i){const{gl:s,mode:n,type:r,index:a,object:l,info:h}=this;i!==0&&(a!==0?s.drawElementsInstanced(n,e,r,t,i):s.drawArraysInstanced(n,t,e,i),h.update(l,e,n,i))}renderMultiDraw(t,e,i){const{extensions:s,mode:n,object:r,info:a}=this;if(i===0)return;const l=s.get("WEBGL_multi_draw");if(l===null)for(let h=0;h<i;h++)this.render(t[h],e[h]);else{this.index!==0?l.multiDrawElementsWEBGL(n,e,0,this.type,t,0,i):l.multiDrawArraysWEBGL(n,t,0,e,0,i);let h=0;for(let u=0;u<i;u++)h+=e[u];a.update(r,h,n,1)}}renderMultiDrawInstances(t,e,i,s){const{extensions:n,mode:r,object:a,info:l}=this;if(i===0)return;const h=n.get("WEBGL_multi_draw");if(h===null)for(let u=0;u<i;u++)this.renderInstances(t[u],e[u],s[u]);else{this.index!==0?h.multiDrawElementsInstancedWEBGL(r,e,0,this.type,t,0,s,0,i):h.multiDrawArraysInstancedWEBGL(r,t,0,e,0,s,0,i);let u=0;for(let c=0;c<i;c++)u+=e[c];for(let c=0;c<s.length;c++)l.update(a,u,r,s[c])}}}class jy extends Jv{constructor(t={}){super(t),this.isWebGLBackend=!0}init(t){super.init(t);const e=this.parameters,i=e.context!==void 0?e.context:t.domElement.getContext("webgl2");this.gl=i,this.extensions=new rB(this),this.capabilities=new oB(this),this.attributeUtils=new eB(this),this.textureUtils=new nB(this),this.bufferRenderer=new aB(this),this.state=new iB(this),this.utils=new sB(this),this.vaoCache={},this.transformFeedbackCache={},this.discard=!1,this.trackTimestamp=e.trackTimestamp===!0,this.extensions.get("EXT_color_buffer_float"),this.extensions.get("WEBGL_multi_draw"),this.disjoint=this.extensions.get("EXT_disjoint_timer_query_webgl2"),this.parallel=this.extensions.get("KHR_parallel_shader_compile"),this._currentContext=null}get coordinateSystem(){return bi}async getArrayBufferAsync(t){return await this.attributeUtils.getArrayBufferAsync(t)}initTimestampQuery(t){if(!this.disjoint||!this.trackTimestamp)return;const e=this.get(t);if(this.queryRunning){e.queryQueue||(e.queryQueue=[]),e.queryQueue.push(t);return}e.activeQuery&&(this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT),e.activeQuery=null),e.activeQuery=this.gl.createQuery(),e.activeQuery!==null&&(this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT,e.activeQuery),this.queryRunning=!0)}prepareTimestampBuffer(t){if(!this.disjoint||!this.trackTimestamp)return;const e=this.get(t);if(e.activeQuery&&(this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT),e.gpuQueries||(e.gpuQueries=[]),e.gpuQueries.push({query:e.activeQuery}),e.activeQuery=null,this.queryRunning=!1,e.queryQueue&&e.queryQueue.length>0)){const i=e.queryQueue.shift();this.initTimestampQuery(i)}}async resolveTimestampAsync(t,e="render"){if(!this.disjoint||!this.trackTimestamp)return;const i=this.get(t);i.gpuQueries||(i.gpuQueries=[]);for(let s=0;s<i.gpuQueries.length;s++){const n=i.gpuQueries[s],r=this.gl.getQueryParameter(n.query,this.gl.QUERY_RESULT_AVAILABLE),a=this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);if(r&&!a){const l=this.gl.getQueryParameter(n.query,this.gl.QUERY_RESULT),h=Number(l)/1e6;this.gl.deleteQuery(n.query),i.gpuQueries.splice(s,1),s--,this.renderer.info.updateTimestamp(e,h)}}}getContext(){return this.gl}beginRender(t){const{gl:e}=this,i=this.get(t);if(this.initTimestampQuery(t),i.previousContext=this._currentContext,this._currentContext=t,this._setFramebuffer(t),this.clear(t.clearColor,t.clearDepth,t.clearStencil,t,!1),t.viewport?this.updateViewport(t):e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),t.scissor){const{x:n,y:r,width:a,height:l}=t.scissorValue;e.scissor(n,r,a,l)}const s=t.occlusionQueryCount;s>0&&(i.currentOcclusionQueries=i.occlusionQueries,i.currentOcclusionQueryObjects=i.occlusionQueryObjects,i.lastOcclusionObject=null,i.occlusionQueries=new Array(s),i.occlusionQueryObjects=new Array(s),i.occlusionQueryIndex=0)}finishRender(t){const{gl:e,state:i}=this,n=this.get(t).previousContext,r=t.textures;if(r!==null)for(let l=0;l<r.length;l++){const h=r[l];h.generateMipmaps&&this.generateMipmaps(h)}if(this._currentContext=n,t.textures!==null&&t.renderTarget){const l=this.get(t.renderTarget),{samples:h}=t.renderTarget,u=l.framebuffer,c=e.COLOR_BUFFER_BIT;if(h>0){const d=l.msaaFrameBuffer,p=t.textures;i.bindFramebuffer(e.READ_FRAMEBUFFER,d),i.bindFramebuffer(e.DRAW_FRAMEBUFFER,u);for(let f=0;f<p.length;f++)e.blitFramebuffer(0,0,t.width,t.height,0,0,t.width,t.height,c,e.NEAREST),e.invalidateFramebuffer(e.READ_FRAMEBUFFER,l.invalidationArray)}}if(n!==null)if(this._setFramebuffer(n),n.viewport)this.updateViewport(n);else{const l=this.gl;l.viewport(0,0,l.drawingBufferWidth,l.drawingBufferHeight)}const a=t.occlusionQueryCount;if(a>0){const l=this.get(t);if(a>l.occlusionQueryIndex){const{gl:h}=this;h.endQuery(h.ANY_SAMPLES_PASSED)}this.resolveOccludedAsync(t)}this.prepareTimestampBuffer(t)}resolveOccludedAsync(t){const e=this.get(t),{currentOcclusionQueries:i,currentOcclusionQueryObjects:s}=e;if(i&&s){const n=new WeakSet,{gl:r}=this;e.currentOcclusionQueryObjects=null,e.currentOcclusionQueries=null;const a=()=>{let l=0;for(let h=0;h<i.length;h++){const u=i[h];u!==null&&r.getQueryParameter(u,r.QUERY_RESULT_AVAILABLE)&&(r.getQueryParameter(u,r.QUERY_RESULT)>0&&n.add(s[h]),i[h]=null,r.deleteQuery(u),l++)}l<i.length?requestAnimationFrame(a):e.occluded=n};a()}}isOccluded(t,e){const i=this.get(t);return i.occluded&&i.occluded.has(e)}updateViewport(t){const e=this.gl,{x:i,y:s,width:n,height:r}=t.viewportValue;e.viewport(i,s,n,r)}setScissorTest(t){const e=this.gl;t?e.enable(e.SCISSOR_TEST):e.disable(e.SCISSOR_TEST)}clear(t,e,i,s=null,n=!0){const{gl:r}=this;s===null&&(s={textures:null,clearColorValue:this.getClearColor()});let a=0;if(t&&(a|=r.COLOR_BUFFER_BIT),e&&(a|=r.DEPTH_BUFFER_BIT),i&&(a|=r.STENCIL_BUFFER_BIT),a!==0){const l=s.clearColorValue||this.getClearColor();if(e&&this.state.setDepthMask(!0),s.textures===null)r.clearColor(l.r,l.g,l.b,l.a),r.clear(a);else{if(n&&this._setFramebuffer(s),t)for(let h=0;h<s.textures.length;h++)r.clearBufferfv(r.COLOR,h,[l.r,l.g,l.b,l.a]);e&&i?r.clearBufferfi(r.DEPTH_STENCIL,0,1,0):e?r.clearBufferfv(r.DEPTH,0,[1]):i&&r.clearBufferiv(r.STENCIL,0,[0])}}}beginCompute(t){const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),this.initTimestampQuery(t)}compute(t,e,i,s){const n=this.gl;this.discard||(n.enable(n.RASTERIZER_DISCARD),this.discard=!0);const{programGPU:r,transformBuffers:a,attributes:l}=this.get(s),h=this._getVaoKey(null,l),u=this.vaoCache[h];u===void 0?this._createVao(null,l):n.bindVertexArray(u),n.useProgram(r),this._bindUniforms(i);const c=this._getTransformFeedback(a);n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,c),n.beginTransformFeedback(n.POINTS),l[0].isStorageInstancedBufferAttribute?n.drawArraysInstanced(n.POINTS,0,1,e.count):n.drawArrays(n.POINTS,0,e.count),n.endTransformFeedback(),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,null);for(let d=0;d<a.length;d++){const p=a[d];p.pbo&&this.textureUtils.copyBufferToTexture(p.transformBuffer,p.pbo),p.switchBuffers()}}finishCompute(t){const e=this.gl;this.discard=!1,e.disable(e.RASTERIZER_DISCARD),this.prepareTimestampBuffer(t)}draw(t){const{object:e,pipeline:i,material:s,context:n}=t,{programGPU:r}=this.get(i),{gl:a,state:l}=this,h=this.get(n);this._bindUniforms(t.getBindings());const u=e.isMesh&&e.matrixWorld.determinant()<0;l.setMaterial(s,u),a.useProgram(r);let c=t.staticVao;if(c===void 0){const _=this._getVaoKey(t.getIndex(),t.getAttributes());if(c=this.vaoCache[_],c===void 0){let v;({vaoGPU:c,staticVao:v}=this._createVao(t.getIndex(),t.getAttributes())),v&&(t.staticVao=c)}}a.bindVertexArray(c);const d=t.getIndex(),p=t.geometry,f=t.drawRange,m=f.start,g=h.lastOcclusionObject;if(g!==e&&g!==void 0){if(g!==null&&g.occlusionTest===!0&&(a.endQuery(a.ANY_SAMPLES_PASSED),h.occlusionQueryIndex++),e.occlusionTest===!0){const _=a.createQuery();a.beginQuery(a.ANY_SAMPLES_PASSED,_),h.occlusionQueries[h.occlusionQueryIndex]=_,h.occlusionQueryObjects[h.occlusionQueryIndex]=e}h.lastOcclusionObject=e}const y=this.bufferRenderer;e.isPoints?y.mode=a.POINTS:e.isLineSegments?y.mode=a.LINES:e.isLine?y.mode=a.LINE_STRIP:e.isLineLoop?y.mode=a.LINE_LOOP:s.wireframe===!0?(l.setLineWidth(s.wireframeLinewidth*this.renderer.getPixelRatio()),y.mode=a.LINES):y.mode=a.TRIANGLES;let x;if(y.object=e,d!==null){const _=this.get(d),v=f.count!==1/0?f.count:d.count;y.index=d.count,y.type=_.type,x=v}else y.index=0,x=f.count!==1/0?f.count:p.attributes.position.count;const M=this.getInstanceCount(t);e.isBatchedMesh?e._multiDrawInstances!==null?y.renderMultiDrawInstances(e._multiDrawStarts,e._multiDrawCounts,e._multiDrawCount,e._multiDrawInstances):this.hasFeature("WEBGL_multi_draw")?y.renderMultiDraw(e._multiDrawStarts,e._multiDrawCounts,e._multiDrawCount):Op("THREE.WebGLRenderer: WEBGL_multi_draw not supported."):M>1?y.renderInstances(m,x,M):y.render(m,x),a.bindVertexArray(null)}needsRenderUpdate(){return!1}getRenderCacheKey(t){return t.id}createDefaultTexture(t){this.textureUtils.createDefaultTexture(t)}createTexture(t,e){this.textureUtils.createTexture(t,e)}updateTexture(t,e){this.textureUtils.updateTexture(t,e)}generateMipmaps(t){this.textureUtils.generateMipmaps(t)}destroyTexture(t){this.textureUtils.destroyTexture(t)}copyTextureToBuffer(t,e,i,s,n){return this.textureUtils.copyTextureToBuffer(t,e,i,s,n)}createSampler(){}destroySampler(){}createNodeBuilder(t,e){return new JI(t,e)}createProgram(t){const e=this.gl,{stage:i,code:s}=t,n=i==="fragment"?e.createShader(e.FRAGMENT_SHADER):e.createShader(e.VERTEX_SHADER);e.shaderSource(n,s),e.compileShader(n),this.set(t,{shaderGPU:n})}destroyProgram(){console.warn("Abstract class.")}createRenderPipeline(t,e){const i=this.gl,s=t.pipeline,{fragmentProgram:n,vertexProgram:r}=s,a=i.createProgram(),l=this.get(n).shaderGPU,h=this.get(r).shaderGPU;if(i.attachShader(a,l),i.attachShader(a,h),i.linkProgram(a),this.set(s,{programGPU:a,fragmentShader:l,vertexShader:h}),e!==null&&this.parallel){const u=new Promise(c=>{const d=this.parallel,p=()=>{i.getProgramParameter(a,d.COMPLETION_STATUS_KHR)?(this._completeCompile(t,s),c()):requestAnimationFrame(p)};p()});e.push(u);return}this._completeCompile(t,s)}_handleSource(t,e){const i=t.split(`
`),s=[],n=Math.max(e-6,0),r=Math.min(e+6,i.length);for(let a=n;a<r;a++){const l=a+1;s.push(`${l===e?">":" "} ${l}: ${i[a]}`)}return s.join(`
`)}_getShaderErrors(t,e,i){const s=t.getShaderParameter(e,t.COMPILE_STATUS),n=t.getShaderInfoLog(e).trim();if(s&&n==="")return"";const r=/ERROR: 0:(\d+)/.exec(n);if(r){const a=parseInt(r[1]);return i.toUpperCase()+`

`+n+`

`+this._handleSource(t.getShaderSource(e),a)}else return n}_logProgramError(t,e,i){if(this.renderer.debug.checkShaderErrors){const s=this.gl,n=s.getProgramInfoLog(t).trim();if(s.getProgramParameter(t,s.LINK_STATUS)===!1)if(typeof this.renderer.debug.onShaderError=="function")this.renderer.debug.onShaderError(s,t,i,e);else{const r=this._getShaderErrors(s,i,"vertex"),a=this._getShaderErrors(s,e,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(t,s.VALIDATE_STATUS)+`

Program Info Log: `+n+`
`+r+`
`+a)}else n!==""&&console.warn("THREE.WebGLProgram: Program Info Log:",n)}}_completeCompile(t,e){const i=this.gl,s=this.get(e),{programGPU:n,fragmentShader:r,vertexShader:a}=s;i.getProgramParameter(n,i.LINK_STATUS)===!1&&this._logProgramError(n,r,a),i.useProgram(n);const l=t.getBindings();this._setupBindings(l,n),this.set(e,{programGPU:n})}createComputePipeline(t,e){const i=this.gl,s={stage:"fragment",code:`#version 300 es
precision highp float;
void main() {}`};this.createProgram(s);const{computeProgram:n}=t,r=i.createProgram(),a=this.get(s).shaderGPU,l=this.get(n).shaderGPU,h=n.transforms,u=[],c=[];for(let m=0;m<h.length;m++){const g=h[m];u.push(g.varyingName),c.push(g.attributeNode)}i.attachShader(r,a),i.attachShader(r,l),i.transformFeedbackVaryings(r,u,i.SEPARATE_ATTRIBS),i.linkProgram(r),i.getProgramParameter(r,i.LINK_STATUS)===!1&&this._logProgramError(r,a,l),i.useProgram(r),this.createBindings(null,e),this._setupBindings(e,r);const d=n.attributes,p=[],f=[];for(let m=0;m<d.length;m++){const g=d[m].node.attribute;p.push(g),this.has(g)||this.attributeUtils.createAttribute(g,i.ARRAY_BUFFER)}for(let m=0;m<c.length;m++){const g=c[m].attribute;this.has(g)||this.attributeUtils.createAttribute(g,i.ARRAY_BUFFER);const y=this.get(g);f.push(y)}this.set(t,{programGPU:r,transformBuffers:f,attributes:p})}createBindings(t,e){this.updateBindings(t,e)}updateBindings(t,e){const{gl:i}=this;let s=0,n=0;for(const r of e)for(const a of r.bindings)if(a.isUniformsGroup||a.isUniformBuffer){const l=i.createBuffer(),h=a.buffer;i.bindBuffer(i.UNIFORM_BUFFER,l),i.bufferData(i.UNIFORM_BUFFER,h,i.DYNAMIC_DRAW),i.bindBufferBase(i.UNIFORM_BUFFER,s,l),this.set(a,{index:s++,bufferGPU:l})}else if(a.isSampledTexture){const{textureGPU:l,glTextureType:h}=this.get(a.texture);this.set(a,{index:n++,textureGPU:l,glTextureType:h})}}updateBinding(t){const e=this.gl;if(t.isUniformsGroup||t.isUniformBuffer){const s=this.get(t).bufferGPU,n=t.buffer;e.bindBuffer(e.UNIFORM_BUFFER,s),e.bufferData(e.UNIFORM_BUFFER,n,e.DYNAMIC_DRAW)}}createIndexAttribute(t){const e=this.gl;this.attributeUtils.createAttribute(t,e.ELEMENT_ARRAY_BUFFER)}createAttribute(t){if(this.has(t))return;const e=this.gl;this.attributeUtils.createAttribute(t,e.ARRAY_BUFFER)}createStorageAttribute(t){if(this.has(t))return;const e=this.gl;this.attributeUtils.createAttribute(t,e.ARRAY_BUFFER)}updateAttribute(t){this.attributeUtils.updateAttribute(t)}destroyAttribute(t){this.attributeUtils.destroyAttribute(t)}updateSize(){}hasFeature(t){const e=Object.keys(qy).filter(s=>qy[s]===t),i=this.extensions;for(let s=0;s<e.length;s++)if(i.has(e[s]))return!0;return!1}getMaxAnisotropy(){return this.capabilities.getMaxAnisotropy()}copyTextureToTexture(t,e,i,s){this.textureUtils.copyTextureToTexture(t,e,i,s)}copyFramebufferToTexture(t,e){this.textureUtils.copyFramebufferToTexture(t,e)}_setFramebuffer(t){const{gl:e,state:i}=this;let s=null;if(t.textures!==null){const n=t.renderTarget,r=this.get(n),{samples:a,depthBuffer:l,stencilBuffer:h}=n,u=this.renderer._activeCubeFace,c=n.isWebGLCubeRenderTarget===!0;let d=r.msaaFrameBuffer,p=r.depthRenderbuffer,f;if(c?(r.cubeFramebuffers===void 0&&(r.cubeFramebuffers=[]),f=r.cubeFramebuffers[u]):f=r.framebuffer,f===void 0){f=e.createFramebuffer(),i.bindFramebuffer(e.FRAMEBUFFER,f);const m=t.textures;if(c){r.cubeFramebuffers[u]=f;const{textureGPU:g}=this.get(m[0]);e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+u,g,0)}else{for(let g=0;g<m.length;g++){const y=m[g],x=this.get(y);x.renderTarget=t.renderTarget;const M=e.COLOR_ATTACHMENT0+g;e.framebufferTexture2D(e.FRAMEBUFFER,M,e.TEXTURE_2D,x.textureGPU,0)}r.framebuffer=f,i.drawBuffers(t,f)}if(t.depthTexture!==null){const g=this.get(t.depthTexture),y=h?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;e.framebufferTexture2D(e.FRAMEBUFFER,y,e.TEXTURE_2D,g.textureGPU,0)}}if(a>0){if(d===void 0){const m=[];d=e.createFramebuffer(),i.bindFramebuffer(e.FRAMEBUFFER,d);const g=[],y=t.textures;for(let x=0;x<y.length;x++){if(g[x]=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,g[x]),m.push(e.COLOR_ATTACHMENT0+x),l){const v=h?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;m.push(v)}const M=t.textures[x],_=this.get(M);e.renderbufferStorageMultisample(e.RENDERBUFFER,a,_.glInternalFormat,t.width,t.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+x,e.RENDERBUFFER,g[x])}if(r.msaaFrameBuffer=d,r.msaaRenderbuffers=g,p===void 0){p=e.createRenderbuffer(),this.textureUtils.setupRenderBufferStorage(p,t),r.depthRenderbuffer=p;const x=h?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;m.push(x)}r.invalidationArray=m}s=r.msaaFrameBuffer}else s=f}i.bindFramebuffer(e.FRAMEBUFFER,s)}_getVaoKey(t,e){let i=[];if(t!==null){const s=this.get(t);i+=":"+s.id}for(let s=0;s<e.length;s++){const n=this.get(e[s]);i+=":"+n.id}return i}_createVao(t,e){const{gl:i}=this,s=i.createVertexArray();let n="",r=!0;if(i.bindVertexArray(s),t!==null){const a=this.get(t);i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,a.bufferGPU),n+=":"+a.id}for(let a=0;a<e.length;a++){const l=e[a],h=this.get(l);n+=":"+h.id,i.bindBuffer(i.ARRAY_BUFFER,h.bufferGPU),i.enableVertexAttribArray(a),(l.isStorageBufferAttribute||l.isStorageInstancedBufferAttribute)&&(r=!1);let u,c;l.isInterleavedBufferAttribute===!0?(u=l.data.stride*h.bytesPerElement,c=l.offset*h.bytesPerElement):(u=0,c=0),h.isInteger?i.vertexAttribIPointer(a,l.itemSize,h.type,u,c):i.vertexAttribPointer(a,l.itemSize,h.type,l.normalized,u,c),l.isInstancedBufferAttribute&&!l.isInterleavedBufferAttribute?i.vertexAttribDivisor(a,l.meshPerAttribute):l.isInterleavedBufferAttribute&&l.data.isInstancedInterleavedBuffer&&i.vertexAttribDivisor(a,l.data.meshPerAttribute)}return i.bindBuffer(i.ARRAY_BUFFER,null),this.vaoCache[n]=s,{vaoGPU:s,staticVao:r}}_getTransformFeedback(t){let e="";for(let n=0;n<t.length;n++)e+=":"+t[n].id;let i=this.transformFeedbackCache[e];if(i!==void 0)return i;const s=this.gl;i=s.createTransformFeedback(),s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,i);for(let n=0;n<t.length;n++){const r=t[n];s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER,n,r.transformBuffer)}return s.bindTransformFeedback(s.TRANSFORM_FEEDBACK,null),this.transformFeedbackCache[e]=i,i}_setupBindings(t,e){const i=this.gl;for(const s of t)for(const n of s.bindings){const a=this.get(n).index;if(n.isUniformsGroup||n.isUniformBuffer){const l=i.getUniformBlockIndex(e,n.name);i.uniformBlockBinding(e,l,a)}else if(n.isSampledTexture){const l=i.getUniformLocation(e,n.name);i.uniform1i(l,a)}}}_bindUniforms(t){const{gl:e,state:i}=this;for(const s of t)for(const n of s.bindings){const r=this.get(n),a=r.index;n.isUniformsGroup||n.isUniformBuffer?e.bindBufferBase(e.UNIFORM_BUFFER,a,r.bufferGPU):n.isSampledTexture&&i.bindTexture(r.glTextureType,r.textureGPU,e.TEXTURE0+a)}}}class lB extends Mf{constructor(t,e){super(t),this.texture=e,this.version=e?e.version:0,this.isSampler=!0}}class hB extends lB{constructor(t,e,i){super(t,e?e.value:null),this.textureNode=e,this.groupNode=i}update(){this.texture=this.textureNode.value}}class uB extends qv{constructor(t,e){super(t,e?e.array:null),this.attribute=e,this.isStorageBuffer=!0}}let cB=0;class dB extends uB{constructor(t,e){super("StorageBuffer_"+cB++,t?t.value:null),this.nodeUniform=t,this.access=t?t.access:ha.Storage,this.groupNode=e}get buffer(){return this.nodeUniform.value}}class pB{constructor(t){this.device=t;const e=`
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`,i=`
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`,s=`
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;this.mipmapSampler=t.createSampler({minFilter:Fh.Linear}),this.flipYSampler=t.createSampler({minFilter:Fh.Nearest}),this.transferPipelines={},this.flipYPipelines={},this.mipmapVertexShaderModule=t.createShaderModule({label:"mipmapVertex",code:e}),this.mipmapFragmentShaderModule=t.createShaderModule({label:"mipmapFragment",code:i}),this.flipYFragmentShaderModule=t.createShaderModule({label:"flipYFragment",code:s})}getTransferPipeline(t){let e=this.transferPipelines[t];return e===void 0&&(e=this.device.createRenderPipeline({vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.mipmapFragmentShaderModule,entryPoint:"main",targets:[{format:t}]},primitive:{topology:Ir.TriangleStrip,stripIndexFormat:Qr.Uint32},layout:"auto"}),this.transferPipelines[t]=e),e}getFlipYPipeline(t){let e=this.flipYPipelines[t];return e===void 0&&(e=this.device.createRenderPipeline({vertex:{module:this.mipmapVertexShaderModule,entryPoint:"main"},fragment:{module:this.flipYFragmentShaderModule,entryPoint:"main",targets:[{format:t}]},primitive:{topology:Ir.TriangleStrip,stripIndexFormat:Qr.Uint32},layout:"auto"}),this.flipYPipelines[t]=e),e}flipY(t,e,i=0){const s=e.format,{width:n,height:r}=e.size,a=this.getTransferPipeline(s),l=this.getFlipYPipeline(s),h=this.device.createTexture({size:{width:n,height:r,depthOrArrayLayers:1},format:s,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),u=t.createView({baseMipLevel:0,mipLevelCount:1,dimension:ri.TwoD,baseArrayLayer:i}),c=h.createView({baseMipLevel:0,mipLevelCount:1,dimension:ri.TwoD,baseArrayLayer:0}),d=this.device.createCommandEncoder({}),p=(f,m,g)=>{const y=f.getBindGroupLayout(0),x=this.device.createBindGroup({layout:y,entries:[{binding:0,resource:this.flipYSampler},{binding:1,resource:m}]}),M=d.beginRenderPass({colorAttachments:[{view:g,loadOp:Gt.Clear,storeOp:ne.Store,clearValue:[0,0,0,0]}]});M.setPipeline(f),M.setBindGroup(0,x),M.draw(4,1,0,0),M.end()};p(a,u,c),p(l,c,u),this.device.queue.submit([d.finish()]),h.destroy()}generateMipmaps(t,e,i=0){const s=this.getTransferPipeline(e.format),n=this.device.createCommandEncoder({}),r=s.getBindGroupLayout(0);let a=t.createView({baseMipLevel:0,mipLevelCount:1,dimension:ri.TwoD,baseArrayLayer:i});for(let l=1;l<e.mipLevelCount;l++){const h=this.device.createBindGroup({layout:r,entries:[{binding:0,resource:this.mipmapSampler},{binding:1,resource:a}]}),u=t.createView({baseMipLevel:l,mipLevelCount:1,dimension:ri.TwoD,baseArrayLayer:i}),c=n.beginRenderPass({colorAttachments:[{view:u,loadOp:Gt.Clear,storeOp:ne.Store,clearValue:[0,0,0,0]}]});c.setPipeline(s),c.setBindGroup(0,h),c.draw(4,1,0,0),c.end(),a=u}this.device.queue.submit([n.finish()])}}const fB={[F0]:"never",[Up]:"less",[I0]:"equal",[B0]:"less-equal",[L0]:"greater",[D0]:"greater-equal",[O0]:"always",[U0]:"not-equal"},mB=[0,1,3,2,4,5];class gB{constructor(t){this.backend=t,this._passUtils=null,this.defaultTexture={},this.defaultCubeTexture={},this.defaultVideoFrame=null,this.colorBuffer=null,this.depthTexture=new _a,this.depthTexture.name="depthBuffer"}createSampler(t){const e=this.backend,i=e.device,s=e.get(t),n={addressModeU:this._convertAddressMode(t.wrapS),addressModeV:this._convertAddressMode(t.wrapT),addressModeW:this._convertAddressMode(t.wrapR),magFilter:this._convertFilterMode(t.magFilter),minFilter:this._convertFilterMode(t.minFilter),mipmapFilter:this._convertFilterMode(t.minFilter),maxAnisotropy:t.anisotropy};t.isDepthTexture&&t.compareFunction!==null&&(n.compare=fB[t.compareFunction]),s.sampler=i.createSampler(n)}createDefaultTexture(t){let e;const i=op(t);t.isCubeTexture?e=this._getDefaultCubeTextureGPU(i):t.isVideoTexture?this.backend.get(t).externalTexture=this._getDefaultVideoFrame():e=this._getDefaultTextureGPU(i),this.backend.get(t).texture=e}createTexture(t,e={}){const i=this.backend,s=i.get(t);if(s.initialized)throw new Error("WebGPUTextureUtils: Texture already initialized.");e.needsMipmaps===void 0&&(e.needsMipmaps=!1),e.levels===void 0&&(e.levels=1),e.depth===void 0&&(e.depth=1);const{width:n,height:r,depth:a,levels:l}=e,h=this._getDimension(t),u=t.internalFormat||e.format||op(t,i.device);let c=e.sampleCount!==void 0?e.sampleCount:1;c=i.utils.getSampleCount(c);const d=t.isRenderTargetTexture&&!t.isMultisampleRenderTargetTexture?1:c;let p=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;t.isStorageTexture===!0&&(p|=GPUTextureUsage.STORAGE_BINDING),t.isCompressedTexture!==!0&&(p|=GPUTextureUsage.RENDER_ATTACHMENT);const f={label:t.name,size:{width:n,height:r,depthOrArrayLayers:a},mipLevelCount:l,sampleCount:d,dimension:h,format:u,usage:p};if(t.isVideoTexture){const m=t.source.data,g=new VideoFrame(m);f.size.width=g.displayWidth,f.size.height=g.displayHeight,g.close(),s.externalTexture=m}else{if(u===void 0)return console.warn("WebGPURenderer: Texture format not supported."),this.createDefaultTexture(t);s.texture=i.device.createTexture(f)}if(t.isRenderTargetTexture&&c>1&&!t.isMultisampleRenderTargetTexture){const m=Object.assign({},f);m.label=m.label+"-msaa",m.sampleCount=c,s.msaaTexture=i.device.createTexture(m)}s.initialized=!0,s.textureDescriptorGPU=f}destroyTexture(t){const e=this.backend,i=e.get(t);i.texture.destroy(),i.msaaTexture!==void 0&&i.msaaTexture.destroy(),e.delete(t)}destroySampler(t){const i=this.backend.get(t);delete i.sampler}generateMipmaps(t){const e=this.backend.get(t);if(t.isCubeTexture)for(let i=0;i<6;i++)this._generateMipmaps(e.texture,e.textureDescriptorGPU,i);else this._generateMipmaps(e.texture,e.textureDescriptorGPU)}getColorBuffer(){this.colorBuffer&&this.colorBuffer.destroy();const t=this.backend,{width:e,height:i}=t.getDrawingBufferSize();return this.colorBuffer=t.device.createTexture({label:"colorBuffer",size:{width:e,height:i,depthOrArrayLayers:1},sampleCount:t.utils.getSampleCount(t.renderer.samples),format:b.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),this.colorBuffer}getDepthBuffer(t=!0,e=!1){const i=this.backend,{width:s,height:n}=i.getDrawingBufferSize(),r=this.depthTexture,a=i.get(r).texture;let l,h;if(e?(l=qr,h=ma):t&&(l=yn,h=re),a!==void 0){if(r.image.width===s&&r.image.height===n&&r.format===l&&r.type===h)return a;this.destroyTexture(r)}return r.name="depthBuffer",r.format=l,r.type=h,r.image.width=s,r.image.height=n,this.createTexture(r,{sampleCount:i.utils.getSampleCount(i.renderer.samples),width:s,height:n}),i.get(r).texture}updateTexture(t,e){const i=this.backend.get(t),{textureDescriptorGPU:s}=i;if(!(t.isRenderTargetTexture||s===void 0)){if(t.isDataTexture)this._copyBufferToTexture(e.image,i.texture,s,0,t.flipY);else if(t.isDataArrayTexture||t.isData3DTexture)for(let n=0;n<e.image.depth;n++)this._copyBufferToTexture(e.image,i.texture,s,n,t.flipY,n);else if(t.isCompressedTexture)this._copyCompressedBufferToTexture(t.mipmaps,i.texture,s);else if(t.isCubeTexture)this._copyCubeMapToTexture(e.images,i.texture,s,t.flipY);else if(t.isVideoTexture){const n=t.source.data;i.externalTexture=n}else this._copyImageToTexture(e.image,i.texture,s,0,t.flipY);i.version=t.version,t.onUpdate&&t.onUpdate(t)}}async copyTextureToBuffer(t,e,i,s,n){const r=this.backend.device,a=this.backend.get(t),l=a.texture,h=a.textureDescriptorGPU.format,u=this._getBytesPerTexel(h);let c=s*u;c=Math.ceil(c/256)*256;const d=r.createBuffer({size:s*n*u,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),p=r.createCommandEncoder();p.copyTextureToBuffer({texture:l,origin:{x:e,y:i}},{buffer:d,bytesPerRow:c},{width:s,height:n});const f=this._getTypedArrayType(h);r.queue.submit([p.finish()]),await d.mapAsync(GPUMapMode.READ);const m=d.getMappedRange();return new f(m)}_isEnvironmentTexture(t){const e=t.mapping;return e===Np||e===Rp||e===Hr||e===ra}_getDefaultTextureGPU(t){let e=this.defaultTexture[t];if(e===void 0){const i=new Pe;i.minFilter=ce,i.magFilter=ce,this.createTexture(i,{width:1,height:1,format:t}),this.defaultTexture[t]=e=i}return this.backend.get(e).texture}_getDefaultCubeTextureGPU(t){let e=this.defaultTexture[t];if(e===void 0){const i=new Z0;i.minFilter=ce,i.magFilter=ce,this.createTexture(i,{width:1,height:1,depth:6}),this.defaultCubeTexture[t]=e=i}return this.backend.get(e).texture}_getDefaultVideoFrame(){let t=this.defaultVideoFrame;if(t===null){const e={timestamp:0,codedWidth:1,codedHeight:1,format:"RGBA"};this.defaultVideoFrame=t=new VideoFrame(new Uint8Array([0,0,0,255]),e)}return t}_copyCubeMapToTexture(t,e,i,s){for(let n=0;n<6;n++){const r=t[n],a=s===!0?mB[n]:n;r.isDataTexture?this._copyBufferToTexture(r.image,e,i,a,s):this._copyImageToTexture(r,e,i,a,s)}}_copyImageToTexture(t,e,i,s,n){this.backend.device.queue.copyExternalImageToTexture({source:t},{texture:e,mipLevel:0,origin:{x:0,y:0,z:s}},{width:t.width,height:t.height,depthOrArrayLayers:1}),n===!0&&this._flipY(e,i,s)}_getPassUtils(){let t=this._passUtils;return t===null&&(this._passUtils=t=new pB(this.backend.device)),t}_generateMipmaps(t,e,i=0){this._getPassUtils().generateMipmaps(t,e,i)}_flipY(t,e,i=0){this._getPassUtils().flipY(t,e,i)}_copyBufferToTexture(t,e,i,s,n,r=0){const a=this.backend.device,l=t.data,h=this._getBytesPerTexel(i.format),u=t.width*h;a.queue.writeTexture({texture:e,mipLevel:0,origin:{x:0,y:0,z:s}},l,{offset:t.width*t.height*h*r,bytesPerRow:u},{width:t.width,height:t.height,depthOrArrayLayers:1}),n===!0&&this._flipY(e,i,s)}_copyCompressedBufferToTexture(t,e,i){const s=this.backend.device,n=this._getBlockData(i.format);for(let r=0;r<t.length;r++){const a=t[r],l=a.width,h=a.height,u=Math.ceil(l/n.width)*n.byteLength;s.queue.writeTexture({texture:e,mipLevel:r},a.data,{offset:0,bytesPerRow:u},{width:Math.ceil(l/n.width)*n.width,height:Math.ceil(h/n.width)*n.width,depthOrArrayLayers:1})}}_getBlockData(t){if(t===b.BC1RGBAUnorm||t===b.BC1RGBAUnormSRGB)return{byteLength:8,width:4,height:4};if(t===b.BC2RGBAUnorm||t===b.BC2RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(t===b.BC3RGBAUnorm||t===b.BC3RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(t===b.BC4RUnorm||t===b.BC4RSNorm)return{byteLength:8,width:4,height:4};if(t===b.BC5RGUnorm||t===b.BC5RGSnorm)return{byteLength:16,width:4,height:4};if(t===b.BC6HRGBUFloat||t===b.BC6HRGBFloat)return{byteLength:16,width:4,height:4};if(t===b.BC7RGBAUnorm||t===b.BC7RGBAUnormSRGB)return{byteLength:16,width:4,height:4};if(t===b.ETC2RGB8Unorm||t===b.ETC2RGB8UnormSRGB)return{byteLength:8,width:4,height:4};if(t===b.ETC2RGB8A1Unorm||t===b.ETC2RGB8A1UnormSRGB)return{byteLength:8,width:4,height:4};if(t===b.ETC2RGBA8Unorm||t===b.ETC2RGBA8UnormSRGB)return{byteLength:16,width:4,height:4};if(t===b.EACR11Unorm)return{byteLength:8,width:4,height:4};if(t===b.EACR11Snorm)return{byteLength:8,width:4,height:4};if(t===b.EACRG11Unorm)return{byteLength:16,width:4,height:4};if(t===b.EACRG11Snorm)return{byteLength:16,width:4,height:4};if(t===b.ASTC4x4Unorm||t===b.ASTC4x4UnormSRGB)return{byteLength:16,width:4,height:4};if(t===b.ASTC5x4Unorm||t===b.ASTC5x4UnormSRGB)return{byteLength:16,width:5,height:4};if(t===b.ASTC5x5Unorm||t===b.ASTC5x5UnormSRGB)return{byteLength:16,width:5,height:5};if(t===b.ASTC6x5Unorm||t===b.ASTC6x5UnormSRGB)return{byteLength:16,width:6,height:5};if(t===b.ASTC6x6Unorm||t===b.ASTC6x6UnormSRGB)return{byteLength:16,width:6,height:6};if(t===b.ASTC8x5Unorm||t===b.ASTC8x5UnormSRGB)return{byteLength:16,width:8,height:5};if(t===b.ASTC8x6Unorm||t===b.ASTC8x6UnormSRGB)return{byteLength:16,width:8,height:6};if(t===b.ASTC8x8Unorm||t===b.ASTC8x8UnormSRGB)return{byteLength:16,width:8,height:8};if(t===b.ASTC10x5Unorm||t===b.ASTC10x5UnormSRGB)return{byteLength:16,width:10,height:5};if(t===b.ASTC10x6Unorm||t===b.ASTC10x6UnormSRGB)return{byteLength:16,width:10,height:6};if(t===b.ASTC10x8Unorm||t===b.ASTC10x8UnormSRGB)return{byteLength:16,width:10,height:8};if(t===b.ASTC10x10Unorm||t===b.ASTC10x10UnormSRGB)return{byteLength:16,width:10,height:10};if(t===b.ASTC12x10Unorm||t===b.ASTC12x10UnormSRGB)return{byteLength:16,width:12,height:10};if(t===b.ASTC12x12Unorm||t===b.ASTC12x12UnormSRGB)return{byteLength:16,width:12,height:12}}_convertAddressMode(t){let e=Pc.ClampToEdge;return t===$r?e=Pc.Repeat:t===mh&&(e=Pc.MirrorRepeat),e}_convertFilterMode(t){let e=Fh.Linear;return(t===ce||t===fd||t===Lr)&&(e=Fh.Nearest),e}_getBytesPerTexel(t){if(t===b.R8Unorm||t===b.R8Snorm||t===b.R8Uint||t===b.R8Sint)return 1;if(t===b.R16Uint||t===b.R16Sint||t===b.R16Float||t===b.RG8Unorm||t===b.RG8Snorm||t===b.RG8Uint||t===b.RG8Sint)return 2;if(t===b.R32Uint||t===b.R32Sint||t===b.R32Float||t===b.RG16Uint||t===b.RG16Sint||t===b.RG16Float||t===b.RGBA8Unorm||t===b.RGBA8UnormSRGB||t===b.RGBA8Snorm||t===b.RGBA8Uint||t===b.RGBA8Sint||t===b.BGRA8Unorm||t===b.BGRA8UnormSRGB||t===b.RGB9E5UFloat||t===b.RGB10A2Unorm||t===b.RG11B10UFloat||t===b.Depth32Float||t===b.Depth24Plus||t===b.Depth24PlusStencil8||t===b.Depth32FloatStencil8)return 4;if(t===b.RG32Uint||t===b.RG32Sint||t===b.RG32Float||t===b.RGBA16Uint||t===b.RGBA16Sint||t===b.RGBA16Float)return 8;if(t===b.RGBA32Uint||t===b.RGBA32Sint||t===b.RGBA32Float)return 16}_getTypedArrayType(t){if(t===b.R8Uint)return Uint8Array;if(t===b.R8Sint)return Int8Array;if(t===b.R8Unorm)return Uint8Array;if(t===b.R8Snorm)return Int8Array;if(t===b.RG8Uint)return Uint8Array;if(t===b.RG8Sint)return Int8Array;if(t===b.RG8Unorm)return Uint8Array;if(t===b.RG8Snorm)return Int8Array;if(t===b.RGBA8Uint)return Uint8Array;if(t===b.RGBA8Sint)return Int8Array;if(t===b.RGBA8Unorm)return Uint8Array;if(t===b.RGBA8Snorm)return Int8Array;if(t===b.R16Uint)return Uint16Array;if(t===b.R16Sint)return Int16Array;if(t===b.RG16Uint)return Uint16Array;if(t===b.RG16Sint)return Int16Array;if(t===b.RGBA16Uint)return Uint16Array;if(t===b.RGBA16Sint)return Int16Array;if(t===b.R16Float||t===b.RG16Float||t===b.RGBA16Float)return Float32Array;if(t===b.R32Uint)return Uint32Array;if(t===b.R32Sint)return Int32Array;if(t===b.R32Float)return Float32Array;if(t===b.RG32Uint)return Uint32Array;if(t===b.RG32Sint)return Int32Array;if(t===b.RG32Float)return Float32Array;if(t===b.RGBA32Uint)return Uint32Array;if(t===b.RGBA32Sint)return Int32Array;if(t===b.RGBA32Float)return Float32Array;if(t===b.BGRA8Unorm||t===b.BGRA8UnormSRGB)return Uint8Array;if(t===b.RGB10A2Unorm||t===b.RGB9E5UFloat||t===b.RG11B10UFloat)return Uint32Array;if(t===b.Depth32Float)return Float32Array;if(t===b.Depth24Plus||t===b.Depth24PlusStencil8)return Uint32Array;if(t===b.Depth32FloatStencil8)return Float32Array}_getDimension(t){let e;return t.isData3DTexture?e=vy.ThreeD:e=vy.TwoD,e}}function op(o,t=null){const e=o.format,i=o.type,s=o.colorSpace;let n;if(o.isFramebufferTexture===!0&&o.type===rs)n=b.BGRA8Unorm;else if(o.isCompressedTexture===!0)switch(e){case $l:n=s===j?b.BC1RGBAUnormSRGB:b.BC1RGBAUnorm;break;case ql:n=s===j?b.BC2RGBAUnormSRGB:b.BC2RGBAUnorm;break;case jl:n=s===j?b.BC3RGBAUnormSRGB:b.BC3RGBAUnorm;break;case gd:n=s===j?b.ETC2RGB8UnormSRGB:b.ETC2RGB8Unorm;break;case yd:n=s===j?b.ETC2RGBA8UnormSRGB:b.ETC2RGBA8Unorm;break;case xd:n=s===j?b.ASTC4x4UnormSRGB:b.ASTC4x4Unorm;break;case _d:n=s===j?b.ASTC5x4UnormSRGB:b.ASTC5x4Unorm;break;case Md:n=s===j?b.ASTC5x5UnormSRGB:b.ASTC5x5Unorm;break;case vd:n=s===j?b.ASTC6x5UnormSRGB:b.ASTC6x5Unorm;break;case Td:n=s===j?b.ASTC6x6UnormSRGB:b.ASTC6x6Unorm;break;case bd:n=s===j?b.ASTC8x5UnormSRGB:b.ASTC8x5Unorm;break;case Sd:n=s===j?b.ASTC8x6UnormSRGB:b.ASTC8x6Unorm;break;case wd:n=s===j?b.ASTC8x8UnormSRGB:b.ASTC8x8Unorm;break;case Ad:n=s===j?b.ASTC10x5UnormSRGB:b.ASTC10x5Unorm;break;case Nd:n=s===j?b.ASTC10x6UnormSRGB:b.ASTC10x6Unorm;break;case Rd:n=s===j?b.ASTC10x8UnormSRGB:b.ASTC10x8Unorm;break;case Ed:n=s===j?b.ASTC10x10UnormSRGB:b.ASTC10x10Unorm;break;case Cd:n=s===j?b.ASTC12x10UnormSRGB:b.ASTC12x10Unorm;break;case Pd:n=s===j?b.ASTC12x12UnormSRGB:b.ASTC12x12Unorm;break;default:console.error("WebGPURenderer: Unsupported texture format.",e)}else switch(e){case io:switch(i){case $o:n=b.RGBA8Snorm;break;case qo:n=b.RGBA16Sint;break;case Sr:n=b.RGBA16Uint;break;case re:n=b.RGBA32Uint;break;case Ne:n=b.RGBA32Sint;break;case rs:n=s===j?b.RGBA8UnormSRGB:b.RGBA8Unorm;break;case wi:n=b.RGBA16Float;break;case qe:n=b.RGBA32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.",i)}break;case Ep:switch(i){case R0:n=b.RGB9E5UFloat;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBFormat.",i)}break;case Cp:switch(i){case $o:n=b.R8Snorm;break;case qo:n=b.R16Sint;break;case Sr:n=b.R16Uint;break;case re:n=b.R32Uint;break;case Ne:n=b.R32Sint;break;case rs:n=b.R8Unorm;break;case wi:n=b.R16Float;break;case qe:n=b.R32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RedFormat.",i)}break;case Fp:switch(i){case $o:n=b.RG8Snorm;break;case qo:n=b.RG16Sint;break;case Sr:n=b.RG16Uint;break;case re:n=b.RG32Uint;break;case Ne:n=b.RG32Sint;break;case rs:n=b.RG8Unorm;break;case wi:n=b.RG16Float;break;case qe:n=b.RG32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with RGFormat.",i)}break;case yn:switch(i){case Sr:n=b.Depth16Unorm;break;case re:n=b.Depth24Plus;break;case qe:n=b.Depth32Float;break;default:console.error("WebGPURenderer: Unsupported texture type with DepthFormat.",i)}break;case qr:switch(i){case ma:n=b.Depth24PlusStencil8;break;case qe:t&&t.features.has(ko.Depth32FloatStencil8)===!1&&console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'),n=b.Depth32FloatStencil8;break;default:console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.",i)}break;case Pp:switch(i){case Ne:n=b.R32Sint;break;case re:n=b.R32Uint;break;default:console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.",i)}break;case Ip:switch(i){case Ne:n=b.RG32Sint;break;case re:n=b.RG32Uint;break;default:console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.",i)}break;case Bp:switch(i){case Ne:n=b.RGBA32Sint;break;case re:n=b.RGBA32Uint;break;default:console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.",i)}break;default:console.error("WebGPURenderer: Unsupported texture format.",e)}return n}const yB=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,xB=/([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig,Xy={f32:"float",i32:"int",u32:"uint",bool:"bool","vec2<f32>":"vec2","vec2<i32>":"ivec2","vec2<u32>":"uvec2","vec2<bool>":"bvec2",vec2f:"vec2",vec2i:"ivec2",vec2u:"uvec2",vec2b:"bvec2","vec3<f32>":"vec3","vec3<i32>":"ivec3","vec3<u32>":"uvec3","vec3<bool>":"bvec3",vec3f:"vec3",vec3i:"ivec3",vec3u:"uvec3",vec3b:"bvec3","vec4<f32>":"vec4","vec4<i32>":"ivec4","vec4<u32>":"uvec4","vec4<bool>":"bvec4",vec4f:"vec4",vec4i:"ivec4",vec4u:"uvec4",vec4b:"bvec4","mat2x2<f32>":"mat2",mat2x2f:"mat2","mat3x3<f32>":"mat3",mat3x3f:"mat3","mat4x4<f32>":"mat4",mat4x4f:"mat4",sampler:"sampler",texture_1d:"texture",texture_2d:"texture",texture_2d_array:"texture",texture_multisampled_2d:"cubeTexture",texture_depth_2d:"depthTexture",texture_3d:"texture3D",texture_cube:"cubeTexture",texture_cube_array:"cubeTexture",texture_storage_1d:"storageTexture",texture_storage_2d:"storageTexture",texture_storage_2d_array:"storageTexture",texture_storage_3d:"storageTexture"},_B=o=>{o=o.trim();const t=o.match(yB);if(t!==null&&t.length===4){const e=t[2],i=[];let s=null;for(;(s=xB.exec(e))!==null;)i.push({name:s[1],type:s[2]});const n=[];for(let u=0;u<i.length;u++){const{name:c,type:d}=i[u];let p=d;p.startsWith("texture")&&(p=d.split("<")[0]),p=Xy[p]||p,n.push(new pf(p,c))}const r=o.substring(t[0].length),a=t[3]||"void",l=t[1]!==void 0?t[1]:"";return{type:Xy[a]||a,inputs:n,name:l,inputsCode:e,blockCode:r,outputType:a}}else throw new Error("FunctionNode: Function is not a WGSL code.")};class MB extends xf{constructor(t){const{type:e,inputs:i,name:s,inputsCode:n,blockCode:r,outputType:a}=_B(t);super(e,i,s),this.inputsCode=n,this.blockCode=r,this.outputType=a}getCode(t=this.name){const e=this.outputType!=="void"?"-> "+this.outputType:"";return`fn ${t} ( ${this.inputsCode.trim()} ) ${e}`+this.blockCode}}class vB extends $v{parseFunction(t){return new MB(t)}}const fr=self.GPUShaderStage,Ul={vertex:fr?fr.VERTEX:1,fragment:fr?fr.FRAGMENT:2,compute:fr?fr.COMPUTE:4},Yy={instance:!0,swizzleAssign:!1,storageBuffer:!0},TB={"^^":"threejs_xor"},bB={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",imat2:"mat2x2<i32>",umat2:"mat2x2<u32>",bmat2:"mat2x2<bool>",mat3:"mat3x3<f32>",imat3:"mat3x3<i32>",umat3:"mat3x3<u32>",bmat3:"mat3x3<bool>",mat4:"mat4x4<f32>",imat4:"mat4x4<i32>",umat4:"mat4x4<u32>",bmat4:"mat4x4<bool>"},SB={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"threejs_mod_float",mod_vec2:"threejs_mod_vec2",mod_vec3:"threejs_mod_vec3",mod_vec4:"threejs_mod_vec4",equals_bool:"threejs_equals_bool",equals_bvec2:"threejs_equals_bvec2",equals_bvec3:"threejs_equals_bvec3",equals_bvec4:"threejs_equals_bvec4",lessThanEqual:"threejs_lessThanEqual",greaterThan:"threejs_greaterThan",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>"},Zy={threejs_xor:new _e(`
fn threejs_xor( a : bool, b : bool ) -> bool {

	return ( a || b ) && !( a && b );

}
`),lessThanEqual:new _e(`
fn threejs_lessThanEqual( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x <= b.x, a.y <= b.y, a.z <= b.z );

}
`),greaterThan:new _e(`
fn threejs_greaterThan( a : vec3<f32>, b : vec3<f32> ) -> vec3<bool> {

	return vec3<bool>( a.x > b.x, a.y > b.y, a.z > b.z );

}
`),mod_float:new _e("fn threejs_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new _e("fn threejs_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new _e("fn threejs_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new _e("fn threejs_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new _e("fn threejs_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new _e("fn threejs_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new _e("fn threejs_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new _e("fn threejs_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping:new _e(`
fn threejs_repeatWrapping( uv : vec2<f32>, dimension : vec2<u32> ) -> vec2<u32> {

	let uvScaled = vec2<u32>( uv * vec2<f32>( dimension ) );

	return ( ( uvScaled % dimension ) + dimension ) % dimension;

}
`),biquadraticTexture:new _e(`
fn threejs_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, level : i32 ) -> vec4f {

	let res = vec2f( textureDimensions( map, level ) );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2i( iuv + vec2( 0.5, 0.5 ) ), level );
	let rg2 = textureLoad( map, vec2i( iuv + vec2( 1.5, 0.5 ) ), level );
	let rg3 = textureLoad( map, vec2i( iuv + vec2( 0.5, 1.5 ) ), level );
	let rg4 = textureLoad( map, vec2i( iuv + vec2( 1.5, 1.5 ) ), level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`)};class wB extends BM{constructor(t,e){super(t,e,new vB),this.uniformGroups={},this.builtins={},this.directives={}}needsColorSpaceToLinear(t){return t.isVideoTexture===!0&&t.colorSpace!==ga}_generateTextureSample(t,e,i,s,n=this.shaderStage){return n==="fragment"?s?`textureSample( ${e}, ${e}_sampler, ${i}, ${s} )`:`textureSample( ${e}, ${e}_sampler, ${i} )`:this.isFilteredTexture(t)?this.generateFilteredTexture(t,e,i):this.generateTextureLod(t,e,i,"0")}_generateVideoSample(t,e,i=this.shaderStage){if(i==="fragment")return`textureSampleBaseClampToEdge( ${t}, ${t}_sampler, vec2<f32>( ${e}.x, 1.0 - ${e}.y ) )`;console.error(`WebGPURenderer: THREE.VideoTexture does not support ${i} shader.`)}_generateTextureSampleLevel(t,e,i,s,n,r=this.shaderStage){return r==="fragment"&&this.isUnfilterable(t)===!1?`textureSampleLevel( ${e}, ${e}_sampler, ${i}, ${s} )`:this.isFilteredTexture(t)?this.generateFilteredTexture(t,e,i,s):this.generateTextureLod(t,e,i,s)}generateFilteredTexture(t,e,i,s="0"){return this._include("biquadraticTexture"),`threejs_biquadraticTexture( ${e}, ${i}, i32( ${s} ) )`}generateTextureLod(t,e,i,s="0"){this._include("repeatWrapping");const n=t.isMultisampleRenderTargetTexture===!0?`textureDimensions( ${e} )`:`textureDimensions( ${e}, 0 )`;return`textureLoad( ${e}, threejs_repeatWrapping( ${i}, ${n} ), i32( ${s} ) )`}generateTextureLoad(t,e,i,s,n="0u"){return s?`textureLoad( ${e}, ${i}, ${s}, ${n} )`:`textureLoad( ${e}, ${i}, ${n} )`}generateTextureStore(t,e,i,s){return`textureStore( ${e}, ${i}, ${s} )`}isUnfilterable(t){return this.getComponentTypeFromTexture(t)!=="float"||t.isDataTexture===!0&&t.type===qe||t.isMultisampleRenderTargetTexture===!0}generateTexture(t,e,i,s,n=this.shaderStage){let r=null;return t.isVideoTexture===!0?r=this._generateVideoSample(e,i,n):this.isUnfilterable(t)?r=this.generateTextureLod(t,e,i,"0",s,n):r=this._generateTextureSample(t,e,i,s,n),r}generateTextureGrad(t,e,i,s,n,r=this.shaderStage){if(r==="fragment")return`textureSampleGrad( ${e}, ${e}_sampler, ${i},  ${s[0]}, ${s[1]} )`;console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${r} shader.`)}generateTextureCompare(t,e,i,s,n,r=this.shaderStage){if(r==="fragment")return`textureSampleCompare( ${e}, ${e}_sampler, ${i}, ${s} )`;console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${r} shader.`)}generateTextureLevel(t,e,i,s,n,r=this.shaderStage){let a=null;return t.isVideoTexture===!0?a=this._generateVideoSample(e,i,r):a=this._generateTextureSampleLevel(t,e,i,s,n,r),a}generateTextureBias(t,e,i,s,n,r=this.shaderStage){if(r==="fragment")return`textureSampleBias( ${e}, ${e}_sampler, ${i}, ${s} )`;console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${r} shader.`)}getPropertyName(t,e=this.shaderStage){if(t.isNodeVarying===!0&&t.needsInterpolation===!0){if(e==="vertex")return`varyings.${t.name}`}else if(t.isNodeUniform===!0){const i=t.name,s=t.type;return s==="texture"||s==="cubeTexture"||s==="storageTexture"||s==="texture3D"?i:s==="buffer"||s==="storageBuffer"?`NodeBuffer_${t.id}.${i}`:t.groupNode.name+"."+i}return super.getPropertyName(t)}getOutputStructName(){return"output"}_getUniformGroupCount(t){return Object.keys(this.uniforms[t]).length}getFunctionOperator(t){const e=TB[t];return e!==void 0?(this._include(e),e):null}getStorageAccess(t){if(t.isStorageTextureNode)switch(t.access){case Qo.ReadOnly:return"read";case Qo.WriteOnly:return"write";default:return"read_write"}else switch(t.access){case ha.Storage:return"read_write";case ha.ReadOnlyStorage:return"read";default:return"write"}}getUniformFromNode(t,e,i,s=null){const n=super.getUniformFromNode(t,e,i,s),r=this.getDataFromNode(t,i,this.globalCache);if(r.uniformGPU===void 0){let a;const l=t.groupNode,h=l.name,u=this.getBindGroupArray(h,i);if(e==="texture"||e==="cubeTexture"||e==="storageTexture"||e==="texture3D"){let c=null;if(e==="texture"||e==="storageTexture"?c=new lu(n.name,n.node,l,t.access?t.access:null):e==="cubeTexture"?c=new Zv(n.name,n.node,l,t.access?t.access:null):e==="texture3D"&&(c=new Qv(n.name,n.node,l,t.access?t.access:null)),c.store=t.isStorageTextureNode===!0,c.setVisibility(Ul[i]),i==="fragment"&&this.isUnfilterable(t.value)===!1&&c.store===!1){const d=new hB(`${n.name}_sampler`,n.node,l);d.setVisibility(Ul[i]),u.push(d,c),a=[d,c]}else u.push(c),a=[c]}else if(e==="buffer"||e==="storageBuffer"){const c=e==="storageBuffer"?dB:Xv,d=new c(t,l);d.setVisibility(Ul[i]),u.push(d),a=d}else{const c=this.uniformGroups[i]||(this.uniformGroups[i]={});let d=c[h];d===void 0&&(d=new Yv(h,l),d.setVisibility(Ul[i]),c[h]=d,u.push(d)),a=this.getNodeUniform(n,e),d.addUniform(a)}r.uniformGPU=a}return n}getBuiltin(t,e,i,s=this.shaderStage){const n=this.builtins[s]||(this.builtins[s]=new Map);return n.has(t)===!1&&n.set(t,{name:t,property:e,type:i}),e}getVertexIndex(){return this.shaderStage==="vertex"?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(t){const e=t.layout,i=this.flowShaderNode(t),s=[];for(const r of e.inputs)s.push(r.name+" : "+this.getType(r.type));return`fn ${e.name}( ${s.join(", ")} ) -> ${this.getType(e.type)} {
${i.vars}
${i.code}
	return ${i.result};

}`}getInstanceIndex(){return this.shaderStage==="vertex"?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getDrawIndex(){return null}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xyz"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}isFlipY(){return!1}enableDirective(t,e=this.shaderStage){(this.directives[e]||(this.directives[e]=[])).push(t)}getDirectives(t){const e=[],i=this.directives[t];if(i!==void 0)for(const s of i)e.push(`enable ${s}`);return e.join(`
`)}enableClipDistances(){this.enableDirective("clip_distances")}enableShaderF16(){this.enableDirective("f16")}enableDualSourceBlending(){this.enableDirective("dual_source_blending")}getBuiltins(t){const e=[],i=this.builtins[t];if(i!==void 0)for(const{name:s,property:n,type:r}of i.values())e.push(`@builtin( ${s} ) ${n} : ${r}`);return e.join(`,
	`)}getAttributes(t){const e=[];if(t==="compute"&&(this.getBuiltin("global_invocation_id","id","vec3<u32>","attribute"),this.getBuiltin("workgroup_id","workgroupId","vec3<u32>","attribute"),this.getBuiltin("local_invocation_id","localId","vec3<u32>","attribute"),this.getBuiltin("num_workgroups","numWorkgroups","vec3<u32>","attribute")),t==="vertex"||t==="compute"){const i=this.getBuiltins("attribute");i&&e.push(i);const s=this.getAttributesArray();for(let n=0,r=s.length;n<r;n++){const a=s[n],l=a.name,h=this.getType(a.type);e.push(`@location( ${n} ) ${l} : ${h}`)}}return e.join(`,
	`)}getStructMembers(t){const e=[],i=t.getMemberTypes();for(let n=0;n<i.length;n++){const r=i[n];e.push(`	@location( ${n} ) m${n} : ${r}<f32>`)}const s=this.getBuiltins("output");return s&&e.push(s),e.join(`,
`)}getStructs(t){const e=[],i=this.structs[t];for(let s=0,n=i.length;s<n;s++){const r=i[s],a=r.name;let l=`struct ${a} {
`;l+=this.getStructMembers(r),l+=`
}`,e.push(l),e.push(`
var<private> output : ${a};

`)}return e.join(`

`)}getVar(t,e){return`var ${e} : ${this.getType(t)}`}getVars(t){const e=[],i=this.vars[t];if(i!==void 0)for(const s of i)e.push(`	${this.getVar(s.type,s.name)};`);return`
${e.join(`
`)}
`}getVaryings(t){const e=[];if(t==="vertex"&&this.getBuiltin("position","Vertex","vec4<f32>","vertex"),t==="vertex"||t==="fragment"){const n=this.varyings,r=this.vars[t];for(let a=0;a<n.length;a++){const l=n[a];if(l.needsInterpolation){let h=`@location( ${a} )`;/^(int|uint|ivec|uvec)/.test(l.type)&&(h+=" @interpolate( flat )"),e.push(`${h} ${l.name} : ${this.getType(l.type)}`)}else t==="vertex"&&r.includes(l)===!1&&r.push(l)}}const i=this.getBuiltins(t);i&&e.push(i);const s=e.join(`,
	`);return t==="vertex"?this._getWGSLStruct("VaryingsStruct","	"+s):s}getUniforms(t){const e=this.uniforms[t],i=[],s=[],n=[],r={};for(const l of e){const h=l.groupNode.name,u=this.bindingsIndexes[h];if(l.type==="texture"||l.type==="cubeTexture"||l.type==="storageTexture"||l.type==="texture3D"){const c=l.node.value;t==="fragment"&&this.isUnfilterable(c)===!1&&l.node.isStorageTextureNode!==!0&&(c.isDepthTexture===!0&&c.compareFunction!==null?i.push(`@binding( ${u.binding++} ) @group( ${u.group} ) var ${l.name}_sampler : sampler_comparison;`):i.push(`@binding( ${u.binding++} ) @group( ${u.group} ) var ${l.name}_sampler : sampler;`));let d,p="";if(c.isMultisampleRenderTargetTexture===!0&&(p="_multisampled"),c.isCubeTexture===!0)d="texture_cube<f32>";else if(c.isDataArrayTexture===!0)d="texture_2d_array<f32>";else if(c.isDepthTexture===!0)d=`texture_depth${p}_2d`;else if(c.isVideoTexture===!0)d="texture_external";else if(c.isData3DTexture===!0)d="texture_3d<f32>";else if(l.node.isStorageTextureNode===!0){const f=op(c),m=this.getStorageAccess(l.node);d=`texture_storage_2d<${f}, ${m}>`}else{const f=this.getComponentTypeFromTexture(c).charAt(0);d=`texture${p}_2d<${f}32>`}i.push(`@binding( ${u.binding++} ) @group( ${u.group} ) var ${l.name} : ${d};`)}else if(l.type==="buffer"||l.type==="storageBuffer"){const c=l.node,d=this.getType(c.bufferType),p=c.bufferCount,f=p>0?", "+p:"",m=`	${l.name} : array< ${d}${f} >
`,g=c.isStorageBufferNode?`storage, ${this.getStorageAccess(c)}`:"uniform";s.push(this._getWGSLStructBinding("NodeBuffer_"+c.id,m,g,u.binding++,u.group))}else{const c=this.getType(this.getVectorType(l.type)),d=l.groupNode.name;(r[d]||(r[d]={index:u.binding++,id:u.group,snippets:[]})).snippets.push(`	${l.name} : ${c}`)}}for(const l in r){const h=r[l];n.push(this._getWGSLStructBinding(l,h.snippets.join(`,
`),"uniform",h.index,h.id))}let a=i.join(`
`);return a+=s.join(`
`),a+=n.join(`
`),a}buildCode(){const t=this.material!==null?{fragment:{},vertex:{}}:{compute:{}};for(const e in t){const i=t[e];i.uniforms=this.getUniforms(e),i.attributes=this.getAttributes(e),i.varyings=this.getVaryings(e),i.structs=this.getStructs(e),i.vars=this.getVars(e),i.codes=this.getCodes(e),i.directives=this.getDirectives(e);let s=`// code

`;s+=this.flowCode[e];const n=this.flowNodes[e],r=n[n.length-1],a=r.outputNode,l=a!==void 0&&a.isOutputStructNode===!0;for(const h of n){const u=this.getFlowData(h),c=h.name;if(c&&(s.length>0&&(s+=`
`),s+=`	// flow -> ${c}
	`),s+=`${u.code}
	`,h===r&&e!=="compute"){if(s+=`// result

	`,e==="vertex")s+=`varyings.Vertex = ${u.result};`;else if(e==="fragment")if(l)i.returnType=a.nodeType,s+=`return ${u.result};`;else{let d="	@location(0) color: vec4<f32>";const p=this.getBuiltins("output");p&&(d+=`,
	`+p),i.returnType="OutputStruct",i.structs+=this._getWGSLStruct("OutputStruct",d),i.structs+=`
var<private> output : OutputStruct;

`,s+=`output.color = ${u.result};

	return output;`}}}i.flow=s}this.material!==null?(this.vertexShader=this._getWGSLVertexCode(t.vertex),this.fragmentShader=this._getWGSLFragmentCode(t.fragment)):this.computeShader=this._getWGSLComputeCode(t.compute,(this.object.workgroupSize||[64]).join(", "))}getMethod(t,e=null){let i;return e!==null&&(i=this._getWGSLMethod(t+"_"+e)),i===void 0&&(i=this._getWGSLMethod(t)),i||t}getType(t){return bB[t]||t}isAvailable(t){let e=Yy[t];return e===void 0&&(t==="float32Filterable"&&(e=this.renderer.hasFeature("float32-filterable")),Yy[t]=e),e}_getWGSLMethod(t){return Zy[t]!==void 0&&this._include(t),SB[t]}_include(t){const e=Zy[t];return e.build(this),this.currentFunctionNode!==null&&this.currentFunctionNode.includes.push(e),e}_getWGSLVertexCode(t){return`${this.getSignature()}
// directives
${t.directives};

// uniforms
${t.uniforms}

// varyings
${t.varyings}
var<private> varyings : VaryingsStruct;

// codes
${t.codes}

@vertex
fn main( ${t.attributes} ) -> VaryingsStruct {

	// vars
	${t.vars}

	// flow
	${t.flow}

	return varyings;

}
`}_getWGSLFragmentCode(t){return`${this.getSignature()}

diagnostic( off, derivative_uniformity );

// uniforms
${t.uniforms}

// structs
${t.structs}

// codes
${t.codes}

@fragment
fn main( ${t.varyings} ) -> ${t.returnType} {

	// vars
	${t.vars}

	// flow
	${t.flow}

}
`}_getWGSLComputeCode(t,e){return`${this.getSignature()}
// directives
${t.directives}

// system
var<private> instanceIndex : u32;

// uniforms
${t.uniforms}

// codes
${t.codes}

@compute @workgroup_size( ${e} )
fn main( ${t.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${e}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${e});

	// vars
	${t.vars}

	// flow
	${t.flow}

}
`}_getWGSLStruct(t,e){return`
struct ${t} {
${e}
};`}_getWGSLStructBinding(t,e,i,s=0,n=0){const r=t+"Struct";return`${this._getWGSLStruct(r,e)}
@binding( ${s} ) @group( ${n} )
var<${i}> ${t} : ${r};`}}class AB{constructor(t){this.backend=t}getCurrentDepthStencilFormat(t){let e;return t.depthTexture!==null?e=this.getTextureFormatGPU(t.depthTexture):t.depth&&t.stencil?e=b.Depth24PlusStencil8:t.depth&&(e=b.Depth24Plus),e}getTextureFormatGPU(t){return this.backend.get(t).texture.format}getCurrentColorFormat(t){let e;return t.textures!==null?e=this.getTextureFormatGPU(t.textures[0]):e=b.BGRA8Unorm,e}getCurrentColorSpace(t){return t.textures!==null?t.textures[0].colorSpace:this.backend.renderer.outputColorSpace}getPrimitiveTopology(t,e){if(t.isPoints)return Ir.PointList;if(t.isLineSegments||t.isMesh&&e.wireframe===!0)return Ir.LineList;if(t.isLine)return Ir.LineStrip;if(t.isMesh)return Ir.TriangleList}getSampleCount(t){let e=1;return t>1&&(e=Math.pow(2,Math.floor(Math.log2(t))),e===2&&(e=4)),e}getSampleCountRenderContext(t){return t.textures!==null?this.getSampleCount(t.sampleCount):this.getSampleCount(this.backend.renderer.samples)}}const NB=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]),RB=new Map([[q0,["float16"]]]),EB=new Map([[Int32Array,"sint32"],[Int16Array,"sint32"],[Uint32Array,"uint32"],[Uint16Array,"uint32"],[Float32Array,"float32"]]);class CB{constructor(t){this.backend=t}createAttribute(t,e){const i=this._getBufferAttribute(t),s=this.backend,n=s.get(i);let r=n.buffer;if(r===void 0){const a=s.device;let l=i.array;if(t.normalized===!1&&(l.constructor===Int16Array||l.constructor===Uint16Array)){const u=new Uint32Array(l.length);for(let c=0;c<l.length;c++)u[c]=l[c];l=u}if(i.array=l,(i.isStorageBufferAttribute||i.isStorageInstancedBufferAttribute)&&i.itemSize===3){l=new l.constructor(i.count*4);for(let u=0;u<i.count;u++)l.set(i.array.subarray(u*3,u*3+3),u*4);i.itemSize=4,i.array=l}const h=l.byteLength+(4-l.byteLength%4)%4;r=a.createBuffer({label:i.name,size:h,usage:e,mappedAtCreation:!0}),new l.constructor(r.getMappedRange()).set(l),r.unmap(),n.buffer=r}}updateAttribute(t){const e=this._getBufferAttribute(t),i=this.backend,s=i.device,n=i.get(e).buffer,r=e.array,a=e.updateRanges;if(a.length===0)s.queue.writeBuffer(n,0,r,0);else{for(let l=0,h=a.length;l<h;l++){const u=a[l];s.queue.writeBuffer(n,0,r,u.start*r.BYTES_PER_ELEMENT,u.count*r.BYTES_PER_ELEMENT)}e.clearUpdateRanges()}}createShaderVertexBuffers(t){const e=t.getAttributes(),i=new Map;for(let s=0;s<e.length;s++){const n=e[s],r=n.array.BYTES_PER_ELEMENT,a=this._getBufferAttribute(n);let l=i.get(a);if(l===void 0){let c,d;n.isInterleavedBufferAttribute===!0?(c=n.data.stride*r,d=n.data.isInstancedInterleavedBuffer?Cl.Instance:Cl.Vertex):(c=n.itemSize*r,d=n.isInstancedBufferAttribute?Cl.Instance:Cl.Vertex),n.normalized===!1&&(n.array.constructor===Int16Array||n.array.constructor===Uint16Array)&&(c=4),l={arrayStride:c,attributes:[],stepMode:d},i.set(a,l)}const h=this._getVertexFormat(n),u=n.isInterleavedBufferAttribute===!0?n.offset*r:0;l.attributes.push({shaderLocation:s,offset:u,format:h})}return Array.from(i.values())}destroyAttribute(t){const e=this.backend;e.get(this._getBufferAttribute(t)).buffer.destroy(),e.delete(t)}async getArrayBufferAsync(t){const e=this.backend,i=e.device,s=e.get(this._getBufferAttribute(t)),n=s.buffer,r=n.size;let a=s.readBuffer,l=!0;a===void 0&&(a=i.createBuffer({label:t.name,size:r,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),l=!1,s.readBuffer=a);const h=i.createCommandEncoder({});h.copyBufferToBuffer(n,0,a,0,r),l&&a.unmap();const u=h.finish();return i.queue.submit([u]),await a.mapAsync(GPUMapMode.READ),a.getMappedRange()}_getVertexFormat(t){const{itemSize:e,normalized:i}=t,s=t.array.constructor,n=t.constructor;let r;if(e==1)r=EB.get(s);else{const l=(RB.get(n)||NB.get(s))[i?1:0];if(l){const h=s.BYTES_PER_ELEMENT*e,c=Math.floor((h+3)/4)*4/s.BYTES_PER_ELEMENT;if(c%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");r=`${l}x${c}`}}return r||console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."),r}_getBufferAttribute(t){return t.isInterleavedBufferAttribute&&(t=t.data),t}}class PB{constructor(t){this.backend=t}createBindingsLayout(t){const i=this.backend.device,s=[];let n=0;for(const r of t.bindings){const a={binding:n++,visibility:r.visibility};if(r.isUniformBuffer||r.isStorageBuffer){const l={};r.isStorageBuffer&&(l.type=r.access),a.buffer=l}else if(r.isSampler){const l={};r.texture.isDepthTexture&&r.texture.compareFunction!==null&&(l.type="comparison"),a.sampler=l}else if(r.isSampledTexture&&r.texture.isVideoTexture)a.externalTexture={};else if(r.isSampledTexture&&r.store){const l=this.backend.get(r.texture).texture.format,h=r.access;a.storageTexture={format:l,access:h}}else if(r.isSampledTexture){const l={};if(r.texture.isMultisampleRenderTargetTexture===!0&&(l.multisampled=!0),r.texture.isDepthTexture)l.sampleType=El.Depth;else if(r.texture.isDataTexture||r.texture.isDataArrayTexture||r.texture.isData3DTexture){const h=r.texture.type;h===Ne?l.sampleType=El.SInt:h===re?l.sampleType=El.UInt:h===qe&&(l.sampleType=El.UnfilterableFloat)}r.isSampledCubeTexture?l.viewDimension=ri.Cube:r.texture.isDataArrayTexture?l.viewDimension=ri.TwoDArray:r.isSampledTexture3D&&(l.viewDimension=ri.ThreeD),a.texture=l}else console.error(`WebGPUBindingUtils: Unsupported binding "${r}".`);s.push(a)}return i.createBindGroupLayout({entries:s})}createBindings(t){const i=this.backend.get(t),s=this.createBindingsLayout(t),n=this.createBindGroup(t,s);i.layout=s,i.group=n}updateBinding(t){const e=this.backend,i=e.device,s=t.buffer,n=e.get(t).buffer;i.queue.writeBuffer(n,0,s,0)}createBindGroup(t,e){const i=this.backend,s=i.device;let n=0;const r=[];for(const a of t.bindings){if(a.isUniformBuffer){const l=i.get(a);if(l.buffer===void 0){const h=a.byteLength,u=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,c=s.createBuffer({label:"bindingBuffer_"+a.name,size:h,usage:u});l.buffer=c}r.push({binding:n,resource:{buffer:l.buffer}})}else if(a.isStorageBuffer){const l=i.get(a);if(l.buffer===void 0){const h=a.attribute;l.buffer=i.get(h).buffer}r.push({binding:n,resource:{buffer:l.buffer}})}else if(a.isSampler){const l=i.get(a.texture);r.push({binding:n,resource:l.sampler})}else if(a.isSampledTexture){const l=i.get(a.texture);let h;a.isSampledCubeTexture?h=ri.Cube:a.isSampledTexture3D?h=ri.ThreeD:a.texture.isDataArrayTexture?h=ri.TwoDArray:h=ri.TwoD;let u;if(l.externalTexture!==void 0)u=s.importExternalTexture({source:l.externalTexture});else{const c=UC.All;u=l.texture.createView({aspect:c,dimension:h,mipLevelCount:a.store?1:l.mipLevelCount})}r.push({binding:n,resource:u})}n++}return s.createBindGroup({label:"bindGroup_"+t.name,layout:e,entries:r})}}class FB{constructor(t){this.backend=t}_getSampleCount(t){return this.backend.utils.getSampleCountRenderContext(t)}createRenderPipeline(t,e){const{object:i,material:s,geometry:n,pipeline:r}=t,{vertexProgram:a,fragmentProgram:l}=r,h=this.backend,u=h.device,c=h.utils,d=h.get(r),p=[];for(const D of t.getBindings()){const V=h.get(D);p.push(V.layout)}const f=h.attributeUtils.createShaderVertexBuffers(t);let m;s.transparent===!0&&s.blending!==Wr&&(m=this._getBlending(s));let g={};s.stencilWrite===!0&&(g={compare:this._getStencilCompare(s),failOp:this._getStencilOperation(s.stencilFail),depthFailOp:this._getStencilOperation(s.stencilZFail),passOp:this._getStencilOperation(s.stencilZPass)});const y=this._getColorWriteMask(s),x=[];if(t.context.textures!==null){const D=t.context.textures;for(let V=0;V<D.length;V++){const W=c.getTextureFormatGPU(D[V]);x.push({format:W,blend:m,writeMask:y})}}else{const D=c.getCurrentColorFormat(t.context);x.push({format:D,blend:m,writeMask:y})}const M=h.get(a).module,_=h.get(l).module,v=this._getPrimitiveState(i,n,s),A=this._getDepthCompare(s),T=c.getCurrentDepthStencilFormat(t.context),w=this._getSampleCount(t.context),U={label:"renderPipeline",vertex:Object.assign({},M,{buffers:f}),fragment:Object.assign({},_,{targets:x}),primitive:v,depthStencil:{format:T,depthWriteEnabled:s.depthWrite,depthCompare:A,stencilFront:g,stencilBack:{},stencilReadMask:s.stencilFuncMask,stencilWriteMask:s.stencilWriteMask},multisample:{count:w,alphaToCoverageEnabled:s.alphaToCoverage},layout:u.createPipelineLayout({bindGroupLayouts:p})};if(e===null)d.pipeline=u.createRenderPipeline(U);else{const D=new Promise(V=>{u.createRenderPipelineAsync(U).then(W=>{d.pipeline=W,V()})});e.push(D)}}createBundleEncoder(t,e){const i=this.backend,{utils:s,device:n}=i,r=i.get(t),a=i.get(e),l=s.getCurrentDepthStencilFormat(t),h=s.getCurrentColorFormat(t),u=this._getSampleCount(e.context),c={label:"renderBundleEncoder",colorFormats:[h],depthStencilFormat:l,sampleCount:u},d=n.createRenderBundleEncoder(c);return a.bundleEncoder=d,r.currentSets={attributes:{}},r._renderBundleViewport=t.width+"_"+t.height,d}createComputePipeline(t,e){const i=this.backend,s=i.device,n=i.get(t.computeProgram).module,r=i.get(t),a=[];for(const l of e){const h=i.get(l);a.push(h.layout)}r.pipeline=s.createComputePipeline({compute:n,layout:s.createPipelineLayout({bindGroupLayouts:a})})}_getBlending(t){let e,i;const s=t.blending,n=t.blendSrc,r=t.blendDst,a=t.blendEquation;if(s===l0){const l=t.blendSrcAlpha!==null?t.blendSrcAlpha:n,h=t.blendDstAlpha!==null?t.blendDstAlpha:r,u=t.blendEquationAlpha!==null?t.blendEquationAlpha:a;e={srcFactor:this._getBlendFactor(n),dstFactor:this._getBlendFactor(r),operation:this._getBlendOperation(a)},i={srcFactor:this._getBlendFactor(l),dstFactor:this._getBlendFactor(h),operation:this._getBlendOperation(u)}}else{const l=t.premultipliedAlpha,h=(u,c,d,p)=>{e={srcFactor:u,dstFactor:c,operation:sn.Add},i={srcFactor:d,dstFactor:p,operation:sn.Add}};if(l)switch(s){case os:h(Q.SrcAlpha,Q.OneMinusSrcAlpha,Q.One,Q.OneMinusSrcAlpha);break;case hh:h(Q.SrcAlpha,Q.One,Q.One,Q.One);break;case uh:h(Q.Zero,Q.OneMinusSrc,Q.Zero,Q.One);break;case ch:h(Q.Zero,Q.Src,Q.Zero,Q.SrcAlpha);break}else switch(s){case os:h(Q.SrcAlpha,Q.OneMinusSrcAlpha,Q.One,Q.OneMinusSrcAlpha);break;case hh:h(Q.SrcAlpha,Q.One,Q.SrcAlpha,Q.One);break;case uh:h(Q.Zero,Q.OneMinusSrc,Q.Zero,Q.One);break;case ch:h(Q.Zero,Q.Src,Q.Zero,Q.Src);break}}if(e!==void 0&&i!==void 0)return{color:e,alpha:i};console.error("THREE.WebGPURenderer: Invalid blending: ",s)}_getBlendFactor(t){let e;switch(t){case c0:e=Q.Zero;break;case d0:e=Q.One;break;case p0:e=Q.Src;break;case f0:e=Q.OneMinusSrc;break;case dh:e=Q.SrcAlpha;break;case ph:e=Q.OneMinusSrcAlpha;break;case y0:e=Q.Dst;break;case x0:e=Q.OneMinusDstColor;break;case m0:e=Q.DstAlpha;break;case g0:e=Q.OneMinusDstAlpha;break;case _0:e=Q.SrcAlphaSaturated;break;case vA:e=Q.Constant;break;case TA:e=Q.OneMinusConstant;break;default:console.error("THREE.WebGPURenderer: Blend factor not supported.",t)}return e}_getStencilCompare(t){let e;const i=t.stencilFunc;switch(i){case Dw:e=se.Never;break;case Bd:e=se.Always;break;case Ow:e=se.Less;break;case Vw:e=se.LessEqual;break;case zw:e=se.Equal;break;case Ww:e=se.GreaterEqual;break;case kw:e=se.Greater;break;case Gw:e=se.NotEqual;break;default:console.error("THREE.WebGPURenderer: Invalid stencil function.",i)}return e}_getStencilOperation(t){let e;switch(t){case un:e=Cs.Keep;break;case Cw:e=Cs.Zero;break;case Pw:e=Cs.Replace;break;case Uw:e=Cs.Invert;break;case Fw:e=Cs.IncrementClamp;break;case Iw:e=Cs.DecrementClamp;break;case Bw:e=Cs.IncrementWrap;break;case Lw:e=Cs.DecrementWrap;break;default:console.error("THREE.WebGPURenderer: Invalid stencil operation.",e)}return e}_getBlendOperation(t){let e;switch(t){case Bs:e=sn.Add;break;case h0:e=sn.Subtract;break;case u0:e=sn.ReverseSubtract;break;case lw:e=sn.Min;break;case hw:e=sn.Max;break;default:console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.",t)}return e}_getPrimitiveState(t,e,i){const s={},n=this.backend.utils;switch(s.topology=n.getPrimitiveTopology(t,i),e.index!==null&&t.isLine===!0&&t.isLineSegments!==!0&&(s.stripIndexFormat=e.index.array instanceof Uint16Array?Qr.Uint16:Qr.Uint32),i.side){case na:s.frontFace=Ec.CCW,s.cullMode=Cc.Back;break;case ms:s.frontFace=Ec.CCW,s.cullMode=Cc.Front;break;case lh:s.frontFace=Ec.CCW,s.cullMode=Cc.None;break;default:console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.",i.side);break}return s}_getColorWriteMask(t){return t.colorWrite===!0?My.All:My.None}_getDepthCompare(t){let e;if(t.depthTest===!1)e=se.Always;else{const i=t.depthFunc;switch(i){case M0:e=se.Never;break;case v0:e=se.Always;break;case T0:e=se.Less;break;case fh:e=se.LessEqual;break;case b0:e=se.Equal;break;case S0:e=se.GreaterEqual;break;case w0:e=se.Greater;break;case A0:e=se.NotEqual;break;default:console.error("THREE.WebGPUPipelineUtils: Invalid depth function.",i)}}return e}}class IB extends Jv{constructor(t={}){super(t),this.isWebGPUBackend=!0,this.parameters.alpha=t.alpha===void 0?!0:t.alpha,this.parameters.requiredLimits=t.requiredLimits===void 0?{}:t.requiredLimits,this.trackTimestamp=t.trackTimestamp===!0,this.device=null,this.context=null,this.colorBuffer=null,this.defaultRenderPassdescriptor=null,this.utils=new AB(this),this.attributeUtils=new CB(this),this.bindingUtils=new PB(this),this.pipelineUtils=new FB(this),this.textureUtils=new gB(this),this.occludedResolveCache=new Map}async init(t){await super.init(t);const e=this.parameters;let i;if(e.device===void 0){const r={powerPreference:e.powerPreference},a=await navigator.gpu.requestAdapter(r);if(a===null)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const l=Object.values(ko),h=[];for(const c of l)a.features.has(c)&&h.push(c);const u={requiredFeatures:h,requiredLimits:e.requiredLimits};i=await a.requestDevice(u)}else i=e.device;const s=e.context!==void 0?e.context:t.domElement.getContext("webgpu");this.device=i,this.context=s;const n=e.alpha?"premultiplied":"opaque";this.context.configure({device:this.device,format:b.BGRA8Unorm,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:n}),this.updateSize()}get coordinateSystem(){return bn}async getArrayBufferAsync(t){return await this.attributeUtils.getArrayBufferAsync(t)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){let t=this.defaultRenderPassdescriptor;if(t===null){const i=this.renderer;t={colorAttachments:[{view:null}],depthStencilAttachment:{view:this.textureUtils.getDepthBuffer(i.depth,i.stencil).createView()}};const s=t.colorAttachments[0];this.renderer.samples>0?s.view=this.colorBuffer.createView():s.resolveTarget=void 0,this.defaultRenderPassdescriptor=t}const e=t.colorAttachments[0];return this.renderer.samples>0?e.resolveTarget=this.context.getCurrentTexture().createView():e.view=this.context.getCurrentTexture().createView(),t}_getRenderPassDescriptor(t){const e=t.renderTarget,i=this.get(e);let s=i.descriptors;if(s===void 0&&(s=[],i.descriptors=s),i.width!==e.width||i.height!==e.height||i.activeMipmapLevel!==e.activeMipmapLevel||i.samples!==e.samples||s.length!==e.textures.length){s.length=0;const r=()=>{e.removeEventListener("dispose",r),this.delete(e)};e.addEventListener("dispose",r)}let n=s[t.activeCubeFace];if(n===void 0){const r=t.textures,a=[];for(let u=0;u<r.length;u++){const c=this.get(r[u]),d=c.texture.createView({baseMipLevel:t.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:t.activeCubeFace,dimension:ri.TwoD});let p,f;c.msaaTexture!==void 0?(p=c.msaaTexture.createView(),f=d):(p=d,f=void 0),a.push({view:p,resolveTarget:f,loadOp:Gt.Load,storeOp:ne.Store})}const h={view:this.get(t.depthTexture).texture.createView()};n={colorAttachments:a,depthStencilAttachment:h},s[t.activeCubeFace]=n,i.width=e.width,i.height=e.height,i.samples=e.samples,i.activeMipmapLevel=e.activeMipmapLevel}return n}beginRender(t){const e=this.get(t),i=this.device,s=t.occlusionQueryCount;let n;s>0&&(e.currentOcclusionQuerySet&&e.currentOcclusionQuerySet.destroy(),e.currentOcclusionQueryBuffer&&e.currentOcclusionQueryBuffer.destroy(),e.currentOcclusionQuerySet=e.occlusionQuerySet,e.currentOcclusionQueryBuffer=e.occlusionQueryBuffer,e.currentOcclusionQueryObjects=e.occlusionQueryObjects,n=i.createQuerySet({type:"occlusion",count:s}),e.occlusionQuerySet=n,e.occlusionQueryIndex=0,e.occlusionQueryObjects=new Array(s),e.lastOcclusionObject=null);let r;t.textures===null?r=this._getDefaultRenderPassDescriptor():r=this._getRenderPassDescriptor(t),this.initTimestampQuery(t,r),r.occlusionQuerySet=n;const a=r.depthStencilAttachment;if(t.textures!==null){const u=r.colorAttachments;for(let c=0;c<u.length;c++){const d=u[c];t.clearColor?(d.clearValue=t.clearColorValue,d.loadOp=Gt.Clear,d.storeOp=ne.Store):(d.loadOp=Gt.Load,d.storeOp=ne.Store)}}else{const u=r.colorAttachments[0];t.clearColor?(u.clearValue=t.clearColorValue,u.loadOp=Gt.Clear,u.storeOp=ne.Store):(u.loadOp=Gt.Load,u.storeOp=ne.Store)}t.depth&&(t.clearDepth?(a.depthClearValue=t.clearDepthValue,a.depthLoadOp=Gt.Clear,a.depthStoreOp=ne.Store):(a.depthLoadOp=Gt.Load,a.depthStoreOp=ne.Store)),t.stencil&&(t.clearStencil?(a.stencilClearValue=t.clearStencilValue,a.stencilLoadOp=Gt.Clear,a.stencilStoreOp=ne.Store):(a.stencilLoadOp=Gt.Load,a.stencilStoreOp=ne.Store));const l=i.createCommandEncoder({label:"renderContext_"+t.id}),h=l.beginRenderPass(r);if(e.descriptor=r,e.encoder=l,e.currentPass=h,e.currentSets={attributes:{}},t.viewport&&this.updateViewport(t),t.scissor){const{x:u,y:c,width:d,height:p}=t.scissorValue;h.setScissorRect(u,t.height-p-c,d,p)}}finishRender(t){const e=this.get(t),i=t.occlusionQueryCount;if(e.renderBundles!==void 0&&e.renderBundles.length>0&&(e.registerBundlesPhase=!1,e.currentPass.executeBundles(e.renderBundles)),i>e.occlusionQueryIndex&&e.currentPass.endOcclusionQuery(),e.currentPass.end(),i>0){const s=i*8;let n=this.occludedResolveCache.get(s);n===void 0&&(n=this.device.createBuffer({size:s,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(s,n));const r=this.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});e.encoder.resolveQuerySet(e.occlusionQuerySet,0,i,n,0),e.encoder.copyBufferToBuffer(n,0,r,0,s),e.occlusionQueryBuffer=r,this.resolveOccludedAsync(t)}if(this.prepareTimestampBuffer(t,e.encoder),this.device.queue.submit([e.encoder.finish()]),t.textures!==null){const s=t.textures;for(let n=0;n<s.length;n++){const r=s[n];r.generateMipmaps===!0&&this.textureUtils.generateMipmaps(r)}}}isOccluded(t,e){const i=this.get(t);return i.occluded&&i.occluded.has(e)}async resolveOccludedAsync(t){const e=this.get(t),{currentOcclusionQueryBuffer:i,currentOcclusionQueryObjects:s}=e;if(i&&s){const n=new WeakSet;e.currentOcclusionQueryObjects=null,e.currentOcclusionQueryBuffer=null,await i.mapAsync(GPUMapMode.READ);const r=i.getMappedRange(),a=new BigUint64Array(r);for(let l=0;l<s.length;l++)a[l]!==BigInt(0)&&n.add(s[l]);i.destroy(),e.occluded=n}}updateViewport(t){const{currentPass:e}=this.get(t),{x:i,y:s,width:n,height:r,minDepth:a,maxDepth:l}=t.viewportValue;e.setViewport(i,t.height-r-s,n,r,a,l)}clear(t,e,i,s=null){const n=this.device,r=this.renderer;let a=[],l,h,u,c;if(t){const f=this.getClearColor();h={r:f.r,g:f.g,b:f.b,a:f.a}}if(s===null){u=r.depth,c=r.stencil;const f=this._getDefaultRenderPassDescriptor();if(t){a=f.colorAttachments;const m=a[0];m.clearValue=h,m.loadOp=Gt.Clear,m.storeOp=ne.Store}(u||c)&&(l=f.depthStencilAttachment)}else{if(u=s.depth,c=s.stencil,t)for(const f of s.textures){const m=this.get(f),g=m.texture.createView();let y,x;m.msaaTexture!==void 0?(y=m.msaaTexture.createView(),x=g):(y=g,x=void 0),a.push({view:y,resolveTarget:x,clearValue:h,loadOp:Gt.Clear,storeOp:ne.Store})}(u||c)&&(l={view:this.get(s.depthTexture).texture.createView()})}u&&(e?(l.depthLoadOp=Gt.Clear,l.depthClearValue=r.getClearDepth(),l.depthStoreOp=ne.Store):(l.depthLoadOp=Gt.Load,l.depthStoreOp=ne.Store)),c&&(i?(l.stencilLoadOp=Gt.Clear,l.stencilClearValue=r.getClearStencil(),l.stencilStoreOp=ne.Store):(l.stencilLoadOp=Gt.Load,l.stencilStoreOp=ne.Store));const d=n.createCommandEncoder({});d.beginRenderPass({colorAttachments:a,depthStencilAttachment:l}).end(),n.queue.submit([d.finish()])}beginCompute(t){const e=this.get(t),i={};this.initTimestampQuery(t,i),e.cmdEncoderGPU=this.device.createCommandEncoder(),e.passEncoderGPU=e.cmdEncoderGPU.beginComputePass(i)}compute(t,e,i,s){const{passEncoderGPU:n}=this.get(t),r=this.get(s).pipeline;n.setPipeline(r);for(let u=0,c=i.length;u<c;u++){const d=i[u],p=this.get(d);n.setBindGroup(u,p.group)}const a=this.device.limits.maxComputeWorkgroupsPerDimension,l=this.get(e);l.dispatchSize===void 0&&(l.dispatchSize={x:0,y:1,z:1});const{dispatchSize:h}=l;e.dispatchCount>a?(h.x=Math.min(e.dispatchCount,a),h.y=Math.ceil(e.dispatchCount/a)):h.x=e.dispatchCount,n.dispatchWorkgroups(h.x,h.y,h.z)}finishCompute(t){const e=this.get(t);e.passEncoderGPU.end(),this.prepareTimestampBuffer(t,e.cmdEncoderGPU),this.device.queue.submit([e.cmdEncoderGPU.finish()])}draw(t,e){const{object:i,geometry:s,context:n,pipeline:r}=t,a=t.getBindings(),l=this.get(n),h=this.get(r).pipeline,u=l.currentSets,c=this.get(t),{bundleEncoder:d,renderBundle:p,lastPipelineGPU:f}=c,m=this.get(n);if(m.registerBundlesPhase===!0&&d!==void 0&&f===h){m.renderBundles.push(p);return}const g=this.renderer._currentRenderBundle?this.createBundleEncoder(n,t):l.currentPass;u.pipeline!==h&&(g.setPipeline(h),u.pipeline=h);for(let T=0,w=a.length;T<w;T++){const U=a[T],D=this.get(U);g.setBindGroup(T,D.group)}const y=t.getIndex(),x=y!==null;if(x===!0&&u.index!==y){const T=this.get(y).buffer,w=y.array instanceof Uint16Array?Qr.Uint16:Qr.Uint32;g.setIndexBuffer(T,w),u.index=y}const M=t.getVertexBuffers();for(let T=0,w=M.length;T<w;T++){const U=M[T];if(u.attributes[T]!==U){const D=this.get(U).buffer;g.setVertexBuffer(T,D),u.attributes[T]=U}}if(l.occlusionQuerySet!==void 0){const T=l.lastOcclusionObject;T!==i&&(T!==null&&T.occlusionTest===!0&&(g.endOcclusionQuery(),l.occlusionQueryIndex++),i.occlusionTest===!0&&(g.beginOcclusionQuery(l.occlusionQueryIndex),l.occlusionQueryObjects[l.occlusionQueryIndex]=i),l.lastOcclusionObject=i)}const _=t.drawRange,v=_.start,A=this.getInstanceCount(t);if(A!==0){if(i.isBatchedMesh===!0){const T=i._multiDrawStarts,w=i._multiDrawCounts,U=i._multiDrawCount,D=i._multiDrawInstances,V=y.bytesPerElement||1;for(let W=0;W<U;W++){const $=D?D[W]:1,at=$>1?0:W;g.drawIndexed(w[W]/V,$,T[W]/4,0,at)}}else if(x===!0){const T=_.count!==1/0?_.count:y.count;g.drawIndexed(T,A,v,0,0),e.update(i,T,A)}else{const T=s.attributes.position,w=_.count!==1/0?_.count:T.count;g.draw(w,A,v,0),e.update(i,w,A)}if(this.renderer._currentRenderBundle){const T=g.finish();c.lastPipelineGPU=h,c.renderBundle=T,c.bundleEncoder=g}}}needsRenderUpdate(t){const e=this.get(t),{object:i,material:s}=t,n=this.utils,r=n.getSampleCountRenderContext(t.context),a=n.getCurrentColorSpace(t.context),l=n.getCurrentColorFormat(t.context),h=n.getCurrentDepthStencilFormat(t.context),u=n.getPrimitiveTopology(i,s);let c=!1;return(e.material!==s||e.materialVersion!==s.version||e.transparent!==s.transparent||e.blending!==s.blending||e.premultipliedAlpha!==s.premultipliedAlpha||e.blendSrc!==s.blendSrc||e.blendDst!==s.blendDst||e.blendEquation!==s.blendEquation||e.blendSrcAlpha!==s.blendSrcAlpha||e.blendDstAlpha!==s.blendDstAlpha||e.blendEquationAlpha!==s.blendEquationAlpha||e.colorWrite!==s.colorWrite||e.depthWrite!==s.depthWrite||e.depthTest!==s.depthTest||e.depthFunc!==s.depthFunc||e.stencilWrite!==s.stencilWrite||e.stencilFunc!==s.stencilFunc||e.stencilFail!==s.stencilFail||e.stencilZFail!==s.stencilZFail||e.stencilZPass!==s.stencilZPass||e.stencilFuncMask!==s.stencilFuncMask||e.stencilWriteMask!==s.stencilWriteMask||e.side!==s.side||e.alphaToCoverage!==s.alphaToCoverage||e.sampleCount!==r||e.colorSpace!==a||e.colorFormat!==l||e.depthStencilFormat!==h||e.primitiveTopology!==u||e.clippingContextVersion!==t.clippingContextVersion)&&(e.material=s,e.materialVersion=s.version,e.transparent=s.transparent,e.blending=s.blending,e.premultipliedAlpha=s.premultipliedAlpha,e.blendSrc=s.blendSrc,e.blendDst=s.blendDst,e.blendEquation=s.blendEquation,e.blendSrcAlpha=s.blendSrcAlpha,e.blendDstAlpha=s.blendDstAlpha,e.blendEquationAlpha=s.blendEquationAlpha,e.colorWrite=s.colorWrite,e.depthWrite=s.depthWrite,e.depthTest=s.depthTest,e.depthFunc=s.depthFunc,e.stencilWrite=s.stencilWrite,e.stencilFunc=s.stencilFunc,e.stencilFail=s.stencilFail,e.stencilZFail=s.stencilZFail,e.stencilZPass=s.stencilZPass,e.stencilFuncMask=s.stencilFuncMask,e.stencilWriteMask=s.stencilWriteMask,e.side=s.side,e.alphaToCoverage=s.alphaToCoverage,e.sampleCount=r,e.colorSpace=a,e.colorFormat=l,e.depthStencilFormat=h,e.primitiveTopology=u,e.clippingContextVersion=t.clippingContextVersion,c=!0),c}getRenderCacheKey(t){const{object:e,material:i}=t,s=this.utils,n=t.context;return[i.transparent,i.blending,i.premultipliedAlpha,i.blendSrc,i.blendDst,i.blendEquation,i.blendSrcAlpha,i.blendDstAlpha,i.blendEquationAlpha,i.colorWrite,i.depthWrite,i.depthTest,i.depthFunc,i.stencilWrite,i.stencilFunc,i.stencilFail,i.stencilZFail,i.stencilZPass,i.stencilFuncMask,i.stencilWriteMask,i.side,s.getSampleCountRenderContext(n),s.getCurrentColorSpace(n),s.getCurrentColorFormat(n),s.getCurrentDepthStencilFormat(n),s.getPrimitiveTopology(e,i),t.clippingContextVersion].join()}createSampler(t){this.textureUtils.createSampler(t)}destroySampler(t){this.textureUtils.destroySampler(t)}createDefaultTexture(t){this.textureUtils.createDefaultTexture(t)}createTexture(t,e){this.textureUtils.createTexture(t,e)}updateTexture(t,e){this.textureUtils.updateTexture(t,e)}generateMipmaps(t){this.textureUtils.generateMipmaps(t)}destroyTexture(t){this.textureUtils.destroyTexture(t)}copyTextureToBuffer(t,e,i,s,n){return this.textureUtils.copyTextureToBuffer(t,e,i,s,n)}initTimestampQuery(t,e){if(!this.hasFeature(ko.TimestampQuery)||!this.trackTimestamp)return;const i=this.get(t);if(!i.timeStampQuerySet){const s=this.device.createQuerySet({type:"timestamp",count:2});Object.assign(e,{timestampWrites:{querySet:s,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}}),i.timeStampQuerySet=s}}prepareTimestampBuffer(t,e){if(!this.hasFeature(ko.TimestampQuery)||!this.trackTimestamp)return;const i=this.get(t),s=2*BigInt64Array.BYTES_PER_ELEMENT;i.currentTimestampQueryBuffers===void 0&&(i.currentTimestampQueryBuffers={resolveBuffer:this.device.createBuffer({label:"timestamp resolve buffer",size:s,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),resultBuffer:this.device.createBuffer({label:"timestamp result buffer",size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),isMappingPending:!1});const{resolveBuffer:n,resultBuffer:r,isMappingPending:a}=i.currentTimestampQueryBuffers;a!==!0&&(e.resolveQuerySet(i.timeStampQuerySet,0,2,n,0),e.copyBufferToBuffer(n,0,r,0,s))}async resolveTimestampAsync(t,e="render"){if(!this.hasFeature(ko.TimestampQuery)||!this.trackTimestamp)return;const i=this.get(t);if(i.currentTimestampQueryBuffers===void 0)return;const{resultBuffer:s,isMappingPending:n}=i.currentTimestampQueryBuffers;n!==!0&&(i.currentTimestampQueryBuffers.isMappingPending=!0,s.mapAsync(GPUMapMode.READ).then(()=>{const r=new BigUint64Array(s.getMappedRange()),a=Number(r[1]-r[0])/1e6;this.renderer.info.updateTimestamp(e,a),s.unmap(),i.currentTimestampQueryBuffers.isMappingPending=!1}))}createNodeBuilder(t,e){return new wB(t,e)}createProgram(t){const e=this.get(t);e.module={module:this.device.createShaderModule({code:t.code,label:t.stage}),entryPoint:"main"}}destroyProgram(t){this.delete(t)}createRenderPipeline(t,e){this.pipelineUtils.createRenderPipeline(t,e)}createComputePipeline(t,e){this.pipelineUtils.createComputePipeline(t,e)}createBundleEncoder(t,e){return this.pipelineUtils.createBundleEncoder(t,e)}createBindings(t){this.bindingUtils.createBindings(t)}updateBindings(t){this.bindingUtils.createBindings(t)}updateBinding(t){this.bindingUtils.updateBinding(t)}createIndexAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(t){this.attributeUtils.createAttribute(t,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(t){this.attributeUtils.updateAttribute(t)}destroyAttribute(t){this.attributeUtils.destroyAttribute(t)}updateSize(){this.colorBuffer=this.textureUtils.getColorBuffer(),this.defaultRenderPassdescriptor=null}getMaxAnisotropy(){return 16}hasFeature(t){return this.device.features.has(t)}copyTextureToTexture(t,e,i=null,s=null,n=0){let r=0,a=0,l=0,h=0,u=t.image.width,c=t.image.height;i!==null&&(l=i.x,h=i.y,u=i.width,c=i.height),s!==null&&(r=s.x,a=s.y);const d=this.device.createCommandEncoder({label:"copyTextureToTexture_"+t.id+"_"+e.id}),p=this.get(t).texture,f=this.get(e).texture;d.copyTextureToTexture({texture:p,mipLevel:n,origin:{x:l,y:h,z:0}},{texture:f,mipLevel:n,origin:{x:r,y:a,z:0}},[u,c]),this.device.queue.submit([d.finish()])}copyFramebufferToTexture(t,e){const i=this.get(e),{encoder:s,descriptor:n}=i;let r=null;e.renderTarget?t.isDepthTexture?r=this.get(e.depthTexture).texture:r=this.get(e.textures[0]).texture:t.isDepthTexture?r=this.textureUtils.getDepthBuffer(e.depth,e.stencil):r=this.context.getCurrentTexture();const a=this.get(t).texture;if(r.format!==a.format){console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",r.format,a.format);return}i.currentPass.end(),s.copyTextureToTexture({texture:r,origin:{x:0,y:0,z:0}},{texture:a},[t.image.width,t.image.height]),t.generateMipmaps&&this.textureUtils.generateMipmaps(t);for(let l=0;l<n.colorAttachments.length;l++)n.colorAttachments[l].loadOp=Gt.Load;e.depth&&(n.depthStencilAttachment.depthLoadOp=Gt.Load),e.stencil&&(n.depthStencilAttachment.stencilLoadOp=Gt.Load),i.currentPass=s.beginRenderPass(n),i.currentSets={attributes:{}}}}class KD extends kI{constructor(t={}){let e;t.forceWebGL?e=jy:mA.isAvailable()?e=IB:(e=jy,console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."));const i=new e(t);super(i,t),this.isWebGPURenderer=!0}}const BB=new Dt,Dl=new gs(BB);class tO{constructor(t,e=G(0,0,1,1)){this.renderer=t,this.outputNode=e,this.outputColorTransform=!0,this.needsUpdate=!0}render(){this.update();const t=this.renderer,e=t.toneMapping,i=t.outputColorSpace;t.toneMapping=Tn,t.outputColorSpace=Qe,Dl.render(t),t.toneMapping=e,t.outputColorSpace=i}update(){if(this.needsUpdate===!0){const t=this.renderer,e=t.toneMapping,i=t.outputColorSpace;Dl.material.fragmentNode=this.outputColorTransform===!0?fv(this.outputNode,e,i):this.outputNode.context({toneMapping:e,outputColorSpace:i}),Dl.material.needsUpdate=!0,this.needsUpdate=!1}}async renderAsync(){this.update();const t=this.renderer,e=t.toneMapping,i=t.outputColorSpace;t.toneMapping=Tn,t.outputColorSpace=Qe,await Dl.renderAsync(t),t.toneMapping=e,t.outputColorSpace=i}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:vn}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=vn);/*!
 * @pixiv/three-vrm-materials-mtoon v3.4.1
 * MToon (toon material) module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */var Qy=parseInt(Ni,10);Qy<167&&console.warn(`MToonNodeMaterial requires Three.js r167 or higher (You are using r${Qy}). This would not work correctly.`);var LB=ct("color","color"),UB=ct("map","texture"),DB=ct("normalMap","texture"),OB=ct("normalScale","vec2"),zB=ct("emissive","color"),VB=ct("emissiveIntensity","float"),kB=ct("emissiveMap","texture"),GB=ct("shadeColorFactor","color"),WB=ct("shadingShiftFactor","float"),Jy=ct("shadeMultiplyTexture","texture"),HB=ct("shadeMultiplyTextureScale","float"),$B=ct("shadingToonyFactor","float"),qB=ct("rimLightingMixFactor","float"),jB=ct("rimMultiplyTexture","texture"),XB=ct("matcapFactor","color"),YB=ct("matcapTexture","texture"),ZB=ct("parametricRimColorFactor","color"),QB=ct("parametricRimLiftFactor","float"),JB=ct("parametricRimFresnelPowerFactor","float"),KB=ct("outlineWidthMultiplyTexture","texture"),t2=ct("outlineWidthFactor","float"),Ky=ct("outlineColorFactor","color"),e2=ct("outlineLightingMixFactor","float"),i2=ct("uvAnimationMaskTexture","texture"),s2=ct("uvAnimationScrollXOffset","float"),n2=ct("uvAnimationScrollYOffset","float"),r2=ct("uvAnimationRotationPhase","float"),o2=class extends st{constructor(o){super("vec2"),this.hasMaskTexture=o}setup(){let o=1;this.hasMaskTexture&&(o=G(i2).context({getUV:()=>Nt()}).r);let t=Nt();const e=r2.mul(o),i=$e(e),s=he(e);t=t.sub(F(.5,.5)),t=t.mul(va(i,s,s.negate(),i)),t=t.add(F(.5,.5));const n=F(s2,n2).mul(o);return t=t.add(n),t.toVar("AnimatedUV")}},Kv=k(ot,"vec3").toVar("ShadeColor"),tT=k(ot,"float").toVar("ShadingShift"),eT=k(ot,"float").toVar("ShadingToony"),ap=k(ot,"float").toVar("RimLightingMix"),lp=k(ot,"vec3").toVar("RimMultiply"),hp=k(ot,"vec3").toVar("matcap"),up=k(ot,"vec3").toVar("ParametricRim"),hu=o=>parseInt(vn,10)>=168?(void 0)(o):z(o),a2=hu(({a:o,b:t,t:e})=>{const i=e.sub(o),s=t.sub(o);return i.div(s).clamp()}),l2=hu(({dotNL:o})=>{const e=C(1).sub(eT);let i=o.add(tT);return i=a2({a:e.negate(),b:e,t:i}),i=i.mul(1),i}),h2=hu(({shading:o,lightColor:t})=>{const e=K(Kv,pt,o);return t.mul(cs({diffuseColor:e}))}),u2=class extends Ta{constructor(){super()}direct({lightDirection:o,lightColor:t,reflectedLight:e}){const i=Ct.dot(o).clamp(-1,1),s=l2({dotNL:i});e.directDiffuse.addAssign(h2({shading:s,lightColor:t})),e.directSpecular.addAssign(up.add(hp).mul(lp).mul(K(P(0),cs({diffuseColor:t}),ap)))}indirect(o){const t="context"in o?o.context:o;this.indirectDiffuse(t),this.indirectSpecular(t)}indirectDiffuse(o){const{irradiance:t,reflectedLight:e}=o;e.indirectDiffuse.addAssign(t.mul(cs({diffuseColor:pt})))}indirectSpecular(o){const{reflectedLight:t}=o;t.indirectSpecular.addAssign(up.add(hp).mul(lp).mul(K(P(1),P(0),ap)))}},Lo={None:"none",WorldCoordinates:"worldCoordinates",ScreenCoordinates:"screenCoordinates"},c2=hu(({parametricRimLift:o,parametricRimFresnelPower:t,parametricRimColor:e})=>{const i=IR.normalize(),s=Ct.dot(i.negate());return C(1).sub(s).add(o).clamp().pow(t).mul(e)}),eO=class extends Dt{customProgramCacheKey(){let o=super.customProgramCacheKey();return o+=`isOutline:${this.isOutline},`,o}get isMToonNodeMaterial(){return!0}constructor(o={}){super(),o.transparentWithZWrite&&(o.depthWrite=!0),delete o.transparentWithZWrite,delete o.giEqualizationFactor,delete o.v0CompatShade,delete o.debugMode,this.emissiveNode=null,this.lights=!0,this.color=new nt(1,1,1),this.map=null,this.emissive=new nt(0,0,0),this.emissiveIntensity=1,this.emissiveMap=null,this.normalMap=null,this.normalScale=new q(1,1),this.shadeColorFactor=new nt(0,0,0),this.shadeMultiplyTexture=null,this.shadingShiftFactor=0,this.shadingShiftTexture=null,this.shadingShiftTextureScale=1,this.shadingToonyFactor=.9,this.rimLightingMixFactor=1,this.rimMultiplyTexture=null,this.matcapFactor=new nt(1,1,1),this.matcapTexture=null,this.parametricRimColorFactor=new nt(0,0,0),this.parametricRimLiftFactor=0,this.parametricRimFresnelPowerFactor=5,this.outlineWidthMode=Lo.None,this.outlineWidthMultiplyTexture=null,this.outlineWidthFactor=0,this.outlineColorFactor=new nt(0,0,0),this.outlineLightingMixFactor=1,this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.uvAnimationMaskTexture=null,this.shadeColorNode=null,this.shadingShiftNode=null,this.shadingToonyNode=null,this.rimLightingMixNode=null,this.rimMultiplyNode=null,this.matcapNode=null,this.parametricRimColorNode=null,this.parametricRimLiftNode=null,this.parametricRimFresnelPowerNode=null,this.uvAnimationScrollXOffset=0,this.uvAnimationScrollYOffset=0,this.uvAnimationRotationPhase=0,this.isOutline=!1,this._animatedUVNode=null,this.setValues(o)}setupLightingModel(){return new u2}setup(o){var t;this._animatedUVNode=new o2((t=this.uvAnimationMaskTexture&&this.uvAnimationMaskTexture.isTexture===!0)!=null?t:!1),super.setup(o)}setupDiffuseColor(o){let t=null;if(this.colorNode==null){if(t=LB,this.map&&this.map.isTexture===!0){const e=UB.context({getUV:()=>this._animatedUVNode});t=t.mul(e)}this.colorNode=t}this.vertexColors===!0&&o.geometry.hasAttribute("color")&&(console.warn("MToonNodeMaterial: MToon ignores vertex colors. Consider using a model without vertex colors instead."),this.vertexColors=!1),super.setupDiffuseColor(o),parseInt(vn,10)<166&&this.transparent===!1&&this.blending===os&&this.alphaToCoverage===!1&&pt.a.assign(1),this.colorNode===t&&(this.colorNode=null)}setupVariants(){Kv.assign(this._setupShadeColorNode()),tT.assign(this._setupShadingShiftNode()),eT.assign(this._setupShadingToonyNode()),ap.assign(this._setupRimLightingMixNode()),lp.assign(this._setupRimMultiplyNode()),hp.assign(this._setupMatcapNode()),up.assign(this._setupParametricRimNode())}setupNormal(o){const t=this.normalNode;if(this.normalNode==null){if(this.normalNode=nM,this.normalMap&&this.normalMap.isTexture===!0){const i=DB.context({getUV:()=>this._animatedUVNode});this.normalNode=lv(i,OB)}this.isOutline&&(this.normalNode=this.normalNode.negate())}if(parseInt(vn,10)>=168){const i=this.normalNode;return this.normalNode=t,i}else{super.setupNormal(o),this.normalNode=t;return}}setupLighting(o){let t=null;if(this.emissiveNode==null){if(t=zB.mul(VB),this.emissiveMap&&this.emissiveMap.isTexture===!0){const i=kB.context({getUV:()=>this._animatedUVNode});t=t.mul(i)}this.emissiveNode=t}const e=super.setupLighting(o);return this.emissiveNode===t&&(this.emissiveNode=null),e}setupOutput(o,t){return this.isOutline&&this.outlineWidthMode!==Lo.None&&(t=G(K(Ky,t.xyz.mul(Ky),e2),t.w)),super.setupOutput(o,t)}setupPosition(o){var t,e;const i=this.positionNode;if(this.isOutline&&this.outlineWidthMode!==Lo.None){(t=this.positionNode)!=null||(this.positionNode=Ht);const n=li.normalize();let r=t2;if(this.outlineWidthMultiplyTexture&&this.outlineWidthMultiplyTexture.isTexture===!0){const h=KB.context({getUV:()=>this._animatedUVNode});r=r.mul(h)}const a=_n(rf.mul(n)),l=r.mul(a).mul(n);if(this.outlineWidthMode===Lo.WorldCoordinates)this.positionNode=this.positionNode.add(l);else if(this.outlineWidthMode===Lo.ScreenCoordinates){const h=vi.element(1).element(1),u=ks.mul(Ht);this.positionNode=this.positionNode.add(l.div(h).mul(u.z.negate()))}(e=this.positionNode)!=null||(this.positionNode=Ht)}const s=super.setupPosition(o);return s.z.add(s.w.mul(1e-6)),this.positionNode=i,s}copy(o){var t,e,i,s,n,r,a,l,h,u,c,d,p,f,m,g,y,x,M;return this.color.copy(o.color),this.map=(t=o.map)!=null?t:null,this.emissive.copy(o.emissive),this.emissiveIntensity=o.emissiveIntensity,this.emissiveMap=(e=o.emissiveMap)!=null?e:null,this.normalMap=(i=o.normalMap)!=null?i:null,this.normalScale.copy(o.normalScale),this.shadeColorFactor.copy(o.shadeColorFactor),this.shadeMultiplyTexture=(s=o.shadeMultiplyTexture)!=null?s:null,this.shadingShiftFactor=o.shadingShiftFactor,this.shadingShiftTexture=(n=o.shadingShiftTexture)!=null?n:null,this.shadingShiftTextureScale=o.shadingShiftTextureScale,this.shadingToonyFactor=o.shadingToonyFactor,this.rimLightingMixFactor=o.rimLightingMixFactor,this.rimMultiplyTexture=(r=o.rimMultiplyTexture)!=null?r:null,this.matcapFactor.copy(o.matcapFactor),this.matcapTexture=(a=o.matcapTexture)!=null?a:null,this.parametricRimColorFactor.copy(o.parametricRimColorFactor),this.parametricRimLiftFactor=o.parametricRimLiftFactor,this.parametricRimFresnelPowerFactor=o.parametricRimFresnelPowerFactor,this.outlineWidthMode=o.outlineWidthMode,this.outlineWidthMultiplyTexture=(l=o.outlineWidthMultiplyTexture)!=null?l:null,this.outlineWidthFactor=o.outlineWidthFactor,this.outlineColorFactor.copy(o.outlineColorFactor),this.outlineLightingMixFactor=o.outlineLightingMixFactor,this.uvAnimationScrollXSpeedFactor=o.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=o.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=o.uvAnimationRotationSpeedFactor,this.uvAnimationMaskTexture=(h=o.uvAnimationMaskTexture)!=null?h:null,this.shadeColorNode=(u=o.shadeColorNode)!=null?u:null,this.shadingShiftNode=(c=o.shadingShiftNode)!=null?c:null,this.shadingToonyNode=(d=o.shadingToonyNode)!=null?d:null,this.rimLightingMixNode=(p=o.rimLightingMixNode)!=null?p:null,this.rimMultiplyNode=(f=o.rimMultiplyNode)!=null?f:null,this.matcapNode=(m=o.matcapNode)!=null?m:null,this.parametricRimColorNode=(g=o.parametricRimColorNode)!=null?g:null,this.parametricRimLiftNode=(y=o.parametricRimLiftNode)!=null?y:null,this.parametricRimFresnelPowerNode=(x=o.parametricRimFresnelPowerNode)!=null?x:null,this.isOutline=(M=o.isOutline)!=null?M:null,super.copy(o)}update(o){this.uvAnimationScrollXOffset+=o*this.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYOffset+=o*this.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationPhase+=o*this.uvAnimationRotationSpeedFactor}_setupShadeColorNode(){if(this.shadeColorNode!=null)return P(this.shadeColorNode);let o=GB;if(this.shadeMultiplyTexture&&this.shadeMultiplyTexture.isTexture===!0){const t=Jy.context({getUV:()=>this._animatedUVNode});o=o.mul(t)}return o}_setupShadingShiftNode(){if(this.shadingShiftNode!=null)return C(this.shadingShiftNode);let o=WB;if(this.shadingShiftTexture&&this.shadingShiftTexture.isTexture===!0){const t=Jy.context({getUV:()=>this._animatedUVNode});o=o.add(t.mul(HB))}return o}_setupShadingToonyNode(){return this.shadingToonyNode!=null?C(this.shadingToonyNode):$B}_setupRimLightingMixNode(){return this.rimLightingMixNode!=null?C(this.rimLightingMixNode):qB}_setupRimMultiplyNode(){return this.rimMultiplyNode!=null?P(this.rimMultiplyNode):this.rimMultiplyTexture&&this.rimMultiplyTexture.isTexture===!0?jB.context({getUV:()=>this._animatedUVNode}):P(1)}_setupMatcapNode(){return this.matcapNode!=null?P(this.matcapNode):this.matcapTexture&&this.matcapTexture.isTexture===!0?YB.context({getUV:()=>GM.mul(1,-1).add(0,1)}).mul(XB):P(0)}_setupParametricRimNode(){const o=this.parametricRimColorNode!=null?P(this.parametricRimColorNode):ZB,t=this.parametricRimLiftNode!=null?C(this.parametricRimLiftNode):QB,e=this.parametricRimFresnelPowerNode!=null?C(this.parametricRimFresnelPowerNode):JB;return c2({parametricRimLift:t,parametricRimFresnelPower:e,parametricRimColor:o})}};/*!
 * @pixiv/three-vrm v3.4.1
 * VRM file loader for three.js.
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */var Ol=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),ft=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),tx=class extends Xt{constructor(o){super(),this.weight=0,this.isBinary=!1,this.overrideBlink="none",this.overrideLookAt="none",this.overrideMouth="none",this._binds=[],this.name=`VRMExpression_${o}`,this.expressionName=o,this.type="VRMExpression",this.visible=!1}get binds(){return this._binds}get overrideBlinkAmount(){return this.overrideBlink==="block"?0<this.outputWeight?1:0:this.overrideBlink==="blend"?this.outputWeight:0}get overrideLookAtAmount(){return this.overrideLookAt==="block"?0<this.outputWeight?1:0:this.overrideLookAt==="blend"?this.outputWeight:0}get overrideMouthAmount(){return this.overrideMouth==="block"?0<this.outputWeight?1:0:this.overrideMouth==="blend"?this.outputWeight:0}get outputWeight(){return this.isBinary?this.weight>.5?1:0:this.weight}addBind(o){this._binds.push(o)}deleteBind(o){const t=this._binds.indexOf(o);t>=0&&this._binds.splice(t,1)}applyWeight(o){var t;let e=this.outputWeight;e*=(t=o?.multiplier)!=null?t:1,this.isBinary&&e<1&&(e=0),this._binds.forEach(i=>i.applyWeight(e))}clearAppliedWeight(){this._binds.forEach(o=>o.clearAppliedWeight())}};function iT(o,t,e){var i,s;const n=o.parser.json,r=(i=n.nodes)==null?void 0:i[t];if(r==null)return console.warn(`extractPrimitivesInternal: Attempt to use nodes[${t}] of glTF but the node doesn't exist`),null;const a=r.mesh;if(a==null)return null;const l=(s=n.meshes)==null?void 0:s[a];if(l==null)return console.warn(`extractPrimitivesInternal: Attempt to use meshes[${a}] of glTF but the mesh doesn't exist`),null;const h=l.primitives.length,u=[];return e.traverse(c=>{u.length<h&&c.isMesh&&u.push(c)}),u}function ex(o,t){return ft(this,null,function*(){const e=yield o.parser.getDependency("node",t);return iT(o,t,e)})}function ix(o){return ft(this,null,function*(){const t=yield o.parser.getDependencies("node"),e=new Map;return t.forEach((i,s)=>{const n=iT(o,s,i);n!=null&&e.set(s,n)}),e})}var cp={Aa:"aa",Ih:"ih",Ou:"ou",Ee:"ee",Oh:"oh",Blink:"blink",Happy:"happy",Angry:"angry",Sad:"sad",Relaxed:"relaxed",LookUp:"lookUp",Surprised:"surprised",LookDown:"lookDown",LookLeft:"lookLeft",LookRight:"lookRight",BlinkLeft:"blinkLeft",BlinkRight:"blinkRight",Neutral:"neutral"};function sT(o){return Math.max(Math.min(o,1),0)}var sx=class nT{constructor(){this.blinkExpressionNames=["blink","blinkLeft","blinkRight"],this.lookAtExpressionNames=["lookLeft","lookRight","lookUp","lookDown"],this.mouthExpressionNames=["aa","ee","ih","oh","ou"],this._expressions=[],this._expressionMap={}}get expressions(){return this._expressions.concat()}get expressionMap(){return Object.assign({},this._expressionMap)}get presetExpressionMap(){const t={},e=new Set(Object.values(cp));return Object.entries(this._expressionMap).forEach(([i,s])=>{e.has(i)&&(t[i]=s)}),t}get customExpressionMap(){const t={},e=new Set(Object.values(cp));return Object.entries(this._expressionMap).forEach(([i,s])=>{e.has(i)||(t[i]=s)}),t}copy(t){return this._expressions.concat().forEach(i=>{this.unregisterExpression(i)}),t._expressions.forEach(i=>{this.registerExpression(i)}),this.blinkExpressionNames=t.blinkExpressionNames.concat(),this.lookAtExpressionNames=t.lookAtExpressionNames.concat(),this.mouthExpressionNames=t.mouthExpressionNames.concat(),this}clone(){return new nT().copy(this)}getExpression(t){var e;return(e=this._expressionMap[t])!=null?e:null}registerExpression(t){this._expressions.push(t),this._expressionMap[t.expressionName]=t}unregisterExpression(t){const e=this._expressions.indexOf(t);e===-1&&console.warn("VRMExpressionManager: The specified expressions is not registered"),this._expressions.splice(e,1),delete this._expressionMap[t.expressionName]}getValue(t){var e;const i=this.getExpression(t);return(e=i?.weight)!=null?e:null}setValue(t,e){const i=this.getExpression(t);i&&(i.weight=sT(e))}resetValues(){this._expressions.forEach(t=>{t.weight=0})}getExpressionTrackName(t){const e=this.getExpression(t);return e?`${e.name}.weight`:null}update(){const t=this._calculateWeightMultipliers();this._expressions.forEach(e=>{e.clearAppliedWeight()}),this._expressions.forEach(e=>{let i=1;const s=e.expressionName;this.blinkExpressionNames.indexOf(s)!==-1&&(i*=t.blink),this.lookAtExpressionNames.indexOf(s)!==-1&&(i*=t.lookAt),this.mouthExpressionNames.indexOf(s)!==-1&&(i*=t.mouth),e.applyWeight({multiplier:i})})}_calculateWeightMultipliers(){let t=1,e=1,i=1;return this._expressions.forEach(s=>{t-=s.overrideBlinkAmount,e-=s.overrideLookAtAmount,i-=s.overrideMouthAmount}),t=Math.max(0,t),e=Math.max(0,e),i=Math.max(0,i),{blink:t,lookAt:e,mouth:i}}},Uo={Color:"color",EmissionColor:"emissionColor",ShadeColor:"shadeColor",RimColor:"rimColor",OutlineColor:"outlineColor"},d2={_Color:Uo.Color,_EmissionColor:Uo.EmissionColor,_ShadeColor:Uo.ShadeColor,_RimColor:Uo.RimColor,_OutlineColor:Uo.OutlineColor},p2=new lt,rT=class oT{constructor({material:t,type:e,targetValue:i,targetAlpha:s}){this.material=t,this.type=e,this.targetValue=i,this.targetAlpha=s??1;const n=this._initColorBindState(),r=this._initAlphaBindState();this._state={color:n,alpha:r}}applyWeight(t){const{color:e,alpha:i}=this._state;if(e!=null){const{propertyName:s,deltaValue:n}=e,r=this.material[s];r?.add(p2.copy(n).multiplyScalar(t))}if(i!=null){const{propertyName:s,deltaValue:n}=i;this.material[s]!=null&&(this.material[s]+=n*t)}}clearAppliedWeight(){const{color:t,alpha:e}=this._state;if(t!=null){const{propertyName:i,initialValue:s}=t,n=this.material[i];n?.copy(s)}if(e!=null){const{propertyName:i,initialValue:s}=e;this.material[i]!=null&&(this.material[i]=s)}}_initColorBindState(){var t,e,i;const{material:s,type:n,targetValue:r}=this,a=this._getPropertyNameMap(),l=(e=(t=a?.[n])==null?void 0:t[0])!=null?e:null;if(l==null)return console.warn(`Tried to add a material color bind to the material ${(i=s.name)!=null?i:"(no name)"}, the type ${n} but the material or the type is not supported.`),null;const u=s[l].clone(),c=new lt(r.r-u.r,r.g-u.g,r.b-u.b);return{propertyName:l,initialValue:u,deltaValue:c}}_initAlphaBindState(){var t,e,i;const{material:s,type:n,targetAlpha:r}=this,a=this._getPropertyNameMap(),l=(e=(t=a?.[n])==null?void 0:t[1])!=null?e:null;if(l==null&&r!==1)return console.warn(`Tried to add a material alpha bind to the material ${(i=s.name)!=null?i:"(no name)"}, the type ${n} but the material or the type does not support alpha.`),null;if(l==null)return null;const h=s[l],u=r-h;return{propertyName:l,initialValue:h,deltaValue:u}}_getPropertyNameMap(){var t,e;return(e=(t=Object.entries(oT._propertyNameMapMap).find(([i])=>this.material[i]===!0))==null?void 0:t[1])!=null?e:null}};rT._propertyNameMapMap={isMeshStandardMaterial:{color:["color","opacity"],emissionColor:["emissive",null]},isMeshBasicMaterial:{color:["color","opacity"]},isMToonMaterial:{color:["color","opacity"],emissionColor:["emissive",null],outlineColor:["outlineColorFactor",null],matcapColor:["matcapFactor",null],rimColor:["parametricRimColorFactor",null],shadeColor:["shadeColorFactor",null]}};var nx=rT,Bh=class{constructor({primitives:o,index:t,weight:e}){this.primitives=o,this.index=t,this.weight=e}applyWeight(o){this.primitives.forEach(t=>{var e;((e=t.morphTargetInfluences)==null?void 0:e[this.index])!=null&&(t.morphTargetInfluences[this.index]+=this.weight*o)})}clearAppliedWeight(){this.primitives.forEach(o=>{var t;((t=o.morphTargetInfluences)==null?void 0:t[this.index])!=null&&(o.morphTargetInfluences[this.index]=0)})}},rx=new wt,aT=class lT{constructor({material:t,scale:e,offset:i}){var s,n;this.material=t,this.scale=e,this.offset=i;const r=(s=Object.entries(lT._propertyNamesMap).find(([a])=>t[a]===!0))==null?void 0:s[1];r==null?(console.warn(`Tried to add a texture transform bind to the material ${(n=t.name)!=null?n:"(no name)"} but the material is not supported.`),this._properties=[]):(this._properties=[],r.forEach(a=>{var l;const h=(l=t[a])==null?void 0:l.clone();if(!h)return null;t[a]=h;const u=h.offset.clone(),c=h.repeat.clone(),d=i.clone().sub(u),p=e.clone().sub(c);this._properties.push({name:a,initialOffset:u,deltaOffset:d,initialScale:c,deltaScale:p})}))}applyWeight(t){this._properties.forEach(e=>{const i=this.material[e.name];i!==void 0&&(i.offset.add(rx.copy(e.deltaOffset).multiplyScalar(t)),i.repeat.add(rx.copy(e.deltaScale).multiplyScalar(t)))})}clearAppliedWeight(){this._properties.forEach(t=>{const e=this.material[t.name];e!==void 0&&(e.offset.copy(t.initialOffset),e.repeat.copy(t.initialScale))})}};aT._propertyNamesMap={isMeshStandardMaterial:["map","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap"],isMeshBasicMaterial:["map","specularMap","alphaMap"],isMToonMaterial:["map","normalMap","emissiveMap","shadeMultiplyTexture","rimMultiplyTexture","outlineWidthMultiplyTexture","uvAnimationMaskTexture"]};var ox=aT,f2=new Set(["1.0","1.0-beta"]),hT=class uT{get name(){return"VRMExpressionLoaderPlugin"}constructor(t){this.parser=t}afterRoot(t){return ft(this,null,function*(){t.userData.vrmExpressionManager=yield this._import(t)})}_import(t){return ft(this,null,function*(){const e=yield this._v1Import(t);if(e)return e;const i=yield this._v0Import(t);return i||null})}_v1Import(t){return ft(this,null,function*(){var e,i;const s=this.parser.json;if(!(((e=s.extensionsUsed)==null?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;const r=(i=s.extensions)==null?void 0:i.VRMC_vrm;if(!r)return null;const a=r.specVersion;if(!f2.has(a))return console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),null;const l=r.expressions;if(!l)return null;const h=new Set(Object.values(cp)),u=new Map;l.preset!=null&&Object.entries(l.preset).forEach(([d,p])=>{if(p!=null){if(!h.has(d)){console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${d}" detected. Ignoring the expression`);return}u.set(d,p)}}),l.custom!=null&&Object.entries(l.custom).forEach(([d,p])=>{if(h.has(d)){console.warn(`VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${d}". Ignoring the expression`);return}u.set(d,p)});const c=new sx;return yield Promise.all(Array.from(u.entries()).map(d=>ft(this,[d],function*([p,f]){var m,g,y,x,M,_,v;const A=new tx(p);if(t.scene.add(A),A.isBinary=(m=f.isBinary)!=null?m:!1,A.overrideBlink=(g=f.overrideBlink)!=null?g:"none",A.overrideLookAt=(y=f.overrideLookAt)!=null?y:"none",A.overrideMouth=(x=f.overrideMouth)!=null?x:"none",(M=f.morphTargetBinds)==null||M.forEach(T=>ft(this,null,function*(){var w;if(T.node===void 0||T.index===void 0)return;const U=yield ex(t,T.node),D=T.index;if(!U.every(V=>Array.isArray(V.morphTargetInfluences)&&D<V.morphTargetInfluences.length)){console.warn(`VRMExpressionLoaderPlugin: ${f.name} attempts to index morph #${D} but not found.`);return}A.addBind(new Bh({primitives:U,index:D,weight:(w=T.weight)!=null?w:1}))})),f.materialColorBinds||f.textureTransformBinds){const T=[];t.scene.traverse(w=>{const U=w.material;U&&(Array.isArray(U)?T.push(...U):T.push(U))}),(_=f.materialColorBinds)==null||_.forEach(w=>ft(this,null,function*(){T.filter(D=>{var V;const W=(V=this.parser.associations.get(D))==null?void 0:V.materials;return w.material===W}).forEach(D=>{A.addBind(new nx({material:D,type:w.type,targetValue:new lt().fromArray(w.targetValue),targetAlpha:w.targetValue[3]}))})})),(v=f.textureTransformBinds)==null||v.forEach(w=>ft(this,null,function*(){T.filter(D=>{var V;const W=(V=this.parser.associations.get(D))==null?void 0:V.materials;return w.material===W}).forEach(D=>{var V,W;A.addBind(new ox({material:D,offset:new wt().fromArray((V=w.offset)!=null?V:[0,0]),scale:new wt().fromArray((W=w.scale)!=null?W:[1,1])}))})}))}c.registerExpression(A)}))),c})}_v0Import(t){return ft(this,null,function*(){var e;const i=this.parser.json,s=(e=i.extensions)==null?void 0:e.VRM;if(!s)return null;const n=s.blendShapeMaster;if(!n)return null;const r=new sx,a=n.blendShapeGroups;if(!a)return r;const l=new Set;return yield Promise.all(a.map(h=>ft(this,null,function*(){var u;const c=h.presetName,d=c!=null&&uT.v0v1PresetNameMap[c]||null,p=d??h.name;if(p==null){console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");return}if(l.has(p)){console.warn(`VRMExpressionLoaderPlugin: An expression preset ${c} has duplicated entries. Ignoring the expression`);return}l.add(p);const f=new tx(p);t.scene.add(f),f.isBinary=(u=h.isBinary)!=null?u:!1,h.binds&&h.binds.forEach(g=>ft(this,null,function*(){var y;if(g.mesh===void 0||g.index===void 0)return;const x=[];(y=i.nodes)==null||y.forEach((_,v)=>{_.mesh===g.mesh&&x.push(v)});const M=g.index;yield Promise.all(x.map(_=>ft(this,null,function*(){var v;const A=yield ex(t,_);if(!A.every(T=>Array.isArray(T.morphTargetInfluences)&&M<T.morphTargetInfluences.length)){console.warn(`VRMExpressionLoaderPlugin: ${h.name} attempts to index ${M}th morph but not found.`);return}f.addBind(new Bh({primitives:A,index:M,weight:.01*((v=g.weight)!=null?v:100)}))})))}));const m=h.materialValues;m&&m.length!==0&&m.forEach(g=>{if(g.materialName===void 0||g.propertyName===void 0||g.targetValue===void 0)return;const y=[];t.scene.traverse(M=>{if(M.material){const _=M.material;Array.isArray(_)?y.push(..._.filter(v=>(v.name===g.materialName||v.name===g.materialName+" (Outline)")&&y.indexOf(v)===-1)):_.name===g.materialName&&y.indexOf(_)===-1&&y.push(_)}});const x=g.propertyName;y.forEach(M=>{if(x==="_MainTex_ST"){const v=new wt(g.targetValue[0],g.targetValue[1]),A=new wt(g.targetValue[2],g.targetValue[3]);A.y=1-A.y-v.y,f.addBind(new ox({material:M,scale:v,offset:A}));return}const _=d2[x];if(_){f.addBind(new nx({material:M,type:_,targetValue:new lt().fromArray(g.targetValue),targetAlpha:g.targetValue[3]}));return}console.warn(x+" is not supported")})}),r.registerExpression(f)}))),r})}};hT.v0v1PresetNameMap={a:"aa",e:"ee",i:"ih",o:"oh",u:"ou",blink:"blink",joy:"happy",angry:"angry",sorrow:"sad",fun:"relaxed",lookup:"lookUp",lookdown:"lookDown",lookleft:"lookLeft",lookright:"lookRight",blink_l:"blinkLeft",blink_r:"blinkRight",neutral:"neutral"};var m2=hT,vf=class Mr{constructor(t,e){this._firstPersonOnlyLayer=Mr.DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=Mr.DEFAULT_THIRDPERSON_ONLY_LAYER,this._initializedLayers=!1,this.humanoid=t,this.meshAnnotations=e}copy(t){if(this.humanoid!==t.humanoid)throw new Error("VRMFirstPerson: humanoid must be same in order to copy");return this.meshAnnotations=t.meshAnnotations.map(e=>({meshes:e.meshes.concat(),type:e.type})),this}clone(){return new Mr(this.humanoid,this.meshAnnotations).copy(this)}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}setup({firstPersonOnlyLayer:t=Mr.DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:e=Mr.DEFAULT_THIRDPERSON_ONLY_LAYER}={}){this._initializedLayers||(this._firstPersonOnlyLayer=t,this._thirdPersonOnlyLayer=e,this.meshAnnotations.forEach(i=>{i.meshes.forEach(s=>{i.type==="firstPersonOnly"?(s.layers.set(this._firstPersonOnlyLayer),s.traverse(n=>n.layers.set(this._firstPersonOnlyLayer))):i.type==="thirdPersonOnly"?(s.layers.set(this._thirdPersonOnlyLayer),s.traverse(n=>n.layers.set(this._thirdPersonOnlyLayer))):i.type==="auto"&&this._createHeadlessModel(s)})}),this._initializedLayers=!0)}_excludeTriangles(t,e,i,s){let n=0;if(e!=null&&e.length>0)for(let r=0;r<t.length;r+=3){const a=t[r],l=t[r+1],h=t[r+2],u=e[a],c=i[a];if(u[0]>0&&s.includes(c[0])||u[1]>0&&s.includes(c[1])||u[2]>0&&s.includes(c[2])||u[3]>0&&s.includes(c[3]))continue;const d=e[l],p=i[l];if(d[0]>0&&s.includes(p[0])||d[1]>0&&s.includes(p[1])||d[2]>0&&s.includes(p[2])||d[3]>0&&s.includes(p[3]))continue;const f=e[h],m=i[h];f[0]>0&&s.includes(m[0])||f[1]>0&&s.includes(m[1])||f[2]>0&&s.includes(m[2])||f[3]>0&&s.includes(m[3])||(t[n++]=a,t[n++]=l,t[n++]=h)}return n}_createErasedMesh(t,e){const i=new Kb(t.geometry.clone(),t.material);i.name=`${t.name}(erase)`,i.frustumCulled=t.frustumCulled,i.layers.set(this._firstPersonOnlyLayer);const s=i.geometry,n=s.getAttribute("skinIndex"),r=n instanceof Zm?[]:n.array,a=[];for(let m=0;m<r.length;m+=4)a.push([r[m],r[m+1],r[m+2],r[m+3]]);const l=s.getAttribute("skinWeight"),h=l instanceof Zm?[]:l.array,u=[];for(let m=0;m<h.length;m+=4)u.push([h[m],h[m+1],h[m+2],h[m+3]]);const c=s.getIndex();if(!c)throw new Error("The geometry doesn't have an index buffer");const d=Array.from(c.array),p=this._excludeTriangles(d,u,a,e),f=[];for(let m=0;m<p;m++)f[m]=d[m];return s.setIndex(f),t.onBeforeRender&&(i.onBeforeRender=t.onBeforeRender),i.bind(new pa(t.skeleton.bones,t.skeleton.boneInverses),new ht),i}_createHeadlessModelForSkinnedMesh(t,e){const i=[];if(e.skeleton.bones.forEach((n,r)=>{this._isEraseTarget(n)&&i.push(r)}),!i.length){e.layers.enable(this._thirdPersonOnlyLayer),e.layers.enable(this._firstPersonOnlyLayer);return}e.layers.set(this._thirdPersonOnlyLayer);const s=this._createErasedMesh(e,i);t.add(s)}_createHeadlessModel(t){if(t.type==="Group")if(t.layers.set(this._thirdPersonOnlyLayer),this._isEraseTarget(t))t.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer));else{const e=new Jr;e.name=`_headless_${t.name}`,e.layers.set(this._firstPersonOnlyLayer),t.parent.add(e),t.children.filter(i=>i.type==="SkinnedMesh").forEach(i=>{const s=i;this._createHeadlessModelForSkinnedMesh(e,s)})}else if(t.type==="SkinnedMesh"){const e=t;this._createHeadlessModelForSkinnedMesh(t.parent,e)}else this._isEraseTarget(t)&&(t.layers.set(this._thirdPersonOnlyLayer),t.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer)))}_isEraseTarget(t){return t===this.humanoid.getRawBoneNode("head")?!0:t.parent?this._isEraseTarget(t.parent):!1}};vf.DEFAULT_FIRSTPERSON_ONLY_LAYER=9;vf.DEFAULT_THIRDPERSON_ONLY_LAYER=10;var ax=vf,g2=new Set(["1.0","1.0-beta"]),y2=class{get name(){return"VRMFirstPersonLoaderPlugin"}constructor(o){this.parser=o}afterRoot(o){return ft(this,null,function*(){const t=o.userData.vrmHumanoid;if(t!==null){if(t===void 0)throw new Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");o.userData.vrmFirstPerson=yield this._import(o,t)}})}_import(o,t){return ft(this,null,function*(){if(t==null)return null;const e=yield this._v1Import(o,t);if(e)return e;const i=yield this._v0Import(o,t);return i||null})}_v1Import(o,t){return ft(this,null,function*(){var e,i;const s=this.parser.json;if(!(((e=s.extensionsUsed)==null?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;const r=(i=s.extensions)==null?void 0:i.VRMC_vrm;if(!r)return null;const a=r.specVersion;if(!g2.has(a))return console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),null;const l=r.firstPerson,h=[],u=yield ix(o);return Array.from(u.entries()).forEach(([c,d])=>{var p,f;const m=(p=l?.meshAnnotations)==null?void 0:p.find(g=>g.node===c);h.push({meshes:d,type:(f=m?.type)!=null?f:"auto"})}),new ax(t,h)})}_v0Import(o,t){return ft(this,null,function*(){var e;const i=this.parser.json,s=(e=i.extensions)==null?void 0:e.VRM;if(!s)return null;const n=s.firstPerson;if(!n)return null;const r=[],a=yield ix(o);return Array.from(a.entries()).forEach(([l,h])=>{const u=i.nodes[l],c=n.meshAnnotations?n.meshAnnotations.find(d=>d.mesh===u.mesh):void 0;r.push({meshes:h,type:this._convertV0FlagToV1Type(c?.firstPersonFlag)})}),new ax(t,r)})}_convertV0FlagToV1Type(o){return o==="FirstPersonOnly"?"firstPersonOnly":o==="ThirdPersonOnly"?"thirdPersonOnly":o==="Both"?"both":"auto"}},lx=new S,hx=new S,x2=new rt,ux=class extends Jr{constructor(o){super(),this.vrmHumanoid=o,this._boneAxesMap=new Map,Object.values(o.humanBones).forEach(t=>{const e=new $S(1);e.matrixAutoUpdate=!1,e.material.depthTest=!1,e.material.depthWrite=!1,this.add(e),this._boneAxesMap.set(t,e)})}dispose(){Array.from(this._boneAxesMap.values()).forEach(o=>{o.geometry.dispose(),o.material.dispose()})}updateMatrixWorld(o){Array.from(this._boneAxesMap.entries()).forEach(([t,e])=>{t.node.updateWorldMatrix(!0,!1),t.node.matrixWorld.decompose(lx,x2,hx);const i=lx.set(.1,.1,.1).divide(hx);e.matrix.copy(t.node.matrixWorld).scale(i)}),super.updateMatrixWorld(o)}},Hc=["hips","spine","chest","upperChest","neck","head","leftEye","rightEye","jaw","leftUpperLeg","leftLowerLeg","leftFoot","leftToes","rightUpperLeg","rightLowerLeg","rightFoot","rightToes","leftShoulder","leftUpperArm","leftLowerArm","leftHand","rightShoulder","rightUpperArm","rightLowerArm","rightHand","leftThumbMetacarpal","leftThumbProximal","leftThumbDistal","leftIndexProximal","leftIndexIntermediate","leftIndexDistal","leftMiddleProximal","leftMiddleIntermediate","leftMiddleDistal","leftRingProximal","leftRingIntermediate","leftRingDistal","leftLittleProximal","leftLittleIntermediate","leftLittleDistal","rightThumbMetacarpal","rightThumbProximal","rightThumbDistal","rightIndexProximal","rightIndexIntermediate","rightIndexDistal","rightMiddleProximal","rightMiddleIntermediate","rightMiddleDistal","rightRingProximal","rightRingIntermediate","rightRingDistal","rightLittleProximal","rightLittleIntermediate","rightLittleDistal"],_2={hips:null,spine:"hips",chest:"spine",upperChest:"chest",neck:"upperChest",head:"neck",leftEye:"head",rightEye:"head",jaw:"head",leftUpperLeg:"hips",leftLowerLeg:"leftUpperLeg",leftFoot:"leftLowerLeg",leftToes:"leftFoot",rightUpperLeg:"hips",rightLowerLeg:"rightUpperLeg",rightFoot:"rightLowerLeg",rightToes:"rightFoot",leftShoulder:"upperChest",leftUpperArm:"leftShoulder",leftLowerArm:"leftUpperArm",leftHand:"leftLowerArm",rightShoulder:"upperChest",rightUpperArm:"rightShoulder",rightLowerArm:"rightUpperArm",rightHand:"rightLowerArm",leftThumbMetacarpal:"leftHand",leftThumbProximal:"leftThumbMetacarpal",leftThumbDistal:"leftThumbProximal",leftIndexProximal:"leftHand",leftIndexIntermediate:"leftIndexProximal",leftIndexDistal:"leftIndexIntermediate",leftMiddleProximal:"leftHand",leftMiddleIntermediate:"leftMiddleProximal",leftMiddleDistal:"leftMiddleIntermediate",leftRingProximal:"leftHand",leftRingIntermediate:"leftRingProximal",leftRingDistal:"leftRingIntermediate",leftLittleProximal:"leftHand",leftLittleIntermediate:"leftLittleProximal",leftLittleDistal:"leftLittleIntermediate",rightThumbMetacarpal:"rightHand",rightThumbProximal:"rightThumbMetacarpal",rightThumbDistal:"rightThumbProximal",rightIndexProximal:"rightHand",rightIndexIntermediate:"rightIndexProximal",rightIndexDistal:"rightIndexIntermediate",rightMiddleProximal:"rightHand",rightMiddleIntermediate:"rightMiddleProximal",rightMiddleDistal:"rightMiddleIntermediate",rightRingProximal:"rightHand",rightRingIntermediate:"rightRingProximal",rightRingDistal:"rightRingIntermediate",rightLittleProximal:"rightHand",rightLittleIntermediate:"rightLittleProximal",rightLittleDistal:"rightLittleIntermediate"};function cT(o){return o.invert?o.invert():o.inverse(),o}var an=new S,ln=new rt,dp=class{constructor(o){this.humanBones=o,this.restPose=this.getAbsolutePose()}getAbsolutePose(){const o={};return Object.keys(this.humanBones).forEach(t=>{const e=t,i=this.getBoneNode(e);i&&(an.copy(i.position),ln.copy(i.quaternion),o[e]={position:an.toArray(),rotation:ln.toArray()})}),o}getPose(){const o={};return Object.keys(this.humanBones).forEach(t=>{const e=t,i=this.getBoneNode(e);if(!i)return;an.set(0,0,0),ln.identity();const s=this.restPose[e];s?.position&&an.fromArray(s.position).negate(),s?.rotation&&cT(ln.fromArray(s.rotation)),an.add(i.position),ln.premultiply(i.quaternion),o[e]={position:an.toArray(),rotation:ln.toArray()}}),o}setPose(o){Object.entries(o).forEach(([t,e])=>{const i=t,s=this.getBoneNode(i);if(!s)return;const n=this.restPose[i];n&&(e?.position&&(s.position.fromArray(e.position),n.position&&s.position.add(an.fromArray(n.position))),e?.rotation&&(s.quaternion.fromArray(e.rotation),n.rotation&&s.quaternion.multiply(ln.fromArray(n.rotation))))})}resetPose(){Object.entries(this.restPose).forEach(([o,t])=>{const e=this.getBoneNode(o);e&&(t?.position&&e.position.fromArray(t.position),t?.rotation&&e.quaternion.fromArray(t.rotation))})}getBone(o){var t;return(t=this.humanBones[o])!=null?t:void 0}getBoneNode(o){var t,e;return(e=(t=this.humanBones[o])==null?void 0:t.node)!=null?e:null}},$c=new S,M2=new rt,v2=new S,cx=class dT extends dp{static _setupTransforms(t){const e=new Xt;e.name="VRMHumanoidRig";const i={},s={},n={};Hc.forEach(a=>{var l;const h=t.getBoneNode(a);if(h){const u=new S,c=new rt;h.updateWorldMatrix(!0,!1),h.matrixWorld.decompose(u,c,$c),i[a]=u,s[a]=h.quaternion.clone();const d=new rt;(l=h.parent)==null||l.matrixWorld.decompose($c,d,$c),n[a]=d}});const r={};return Hc.forEach(a=>{var l;const h=t.getBoneNode(a);if(h){const u=i[a];let c=a,d;for(;d==null&&(c=_2[c],c!=null);)d=i[c];const p=new Xt;p.name="Normalized_"+h.name,(c?(l=r[c])==null?void 0:l.node:e).add(p),p.position.copy(u),d&&p.position.sub(d),r[a]={node:p}}}),{rigBones:r,root:e,parentWorldRotations:n,boneRotations:s}}constructor(t){const{rigBones:e,root:i,parentWorldRotations:s,boneRotations:n}=dT._setupTransforms(t);super(e),this.original=t,this.root=i,this._parentWorldRotations=s,this._boneRotations=n}update(){Hc.forEach(t=>{const e=this.original.getBoneNode(t);if(e!=null){const i=this.getBoneNode(t),s=this._parentWorldRotations[t],n=M2.copy(s).invert(),r=this._boneRotations[t];if(e.quaternion.copy(i.quaternion).multiply(s).premultiply(n).multiply(r),t==="hips"){const a=i.getWorldPosition(v2);e.parent.updateWorldMatrix(!0,!1);const l=e.parent.matrixWorld,h=a.applyMatrix4(l.invert());e.position.copy(h)}}})}},dx=class pT{get restPose(){return console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead."),this.rawRestPose}get rawRestPose(){return this._rawHumanBones.restPose}get normalizedRestPose(){return this._normalizedHumanBones.restPose}get humanBones(){return this._rawHumanBones.humanBones}get rawHumanBones(){return this._rawHumanBones.humanBones}get normalizedHumanBones(){return this._normalizedHumanBones.humanBones}get normalizedHumanBonesRoot(){return this._normalizedHumanBones.root}constructor(t,e){var i;this.autoUpdateHumanBones=(i=e?.autoUpdateHumanBones)!=null?i:!0,this._rawHumanBones=new dp(t),this._normalizedHumanBones=new cx(this._rawHumanBones)}copy(t){return this.autoUpdateHumanBones=t.autoUpdateHumanBones,this._rawHumanBones=new dp(t.humanBones),this._normalizedHumanBones=new cx(this._rawHumanBones),this}clone(){return new pT(this.humanBones,{autoUpdateHumanBones:this.autoUpdateHumanBones}).copy(this)}getAbsolutePose(){return console.warn("VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."),this.getRawAbsolutePose()}getRawAbsolutePose(){return this._rawHumanBones.getAbsolutePose()}getNormalizedAbsolutePose(){return this._normalizedHumanBones.getAbsolutePose()}getPose(){return console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead."),this.getRawPose()}getRawPose(){return this._rawHumanBones.getPose()}getNormalizedPose(){return this._normalizedHumanBones.getPose()}setPose(t){return console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead."),this.setRawPose(t)}setRawPose(t){return this._rawHumanBones.setPose(t)}setNormalizedPose(t){return this._normalizedHumanBones.setPose(t)}resetPose(){return console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead."),this.resetRawPose()}resetRawPose(){return this._rawHumanBones.resetPose()}resetNormalizedPose(){return this._normalizedHumanBones.resetPose()}getBone(t){return console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead."),this.getRawBone(t)}getRawBone(t){return this._rawHumanBones.getBone(t)}getNormalizedBone(t){return this._normalizedHumanBones.getBone(t)}getBoneNode(t){return console.warn("VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."),this.getRawBoneNode(t)}getRawBoneNode(t){return this._rawHumanBones.getBoneNode(t)}getNormalizedBoneNode(t){return this._normalizedHumanBones.getBoneNode(t)}update(){this.autoUpdateHumanBones&&this._normalizedHumanBones.update()}},T2={Hips:"hips",Spine:"spine",Head:"head",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand"},b2=new Set(["1.0","1.0-beta"]),px={leftThumbProximal:"leftThumbMetacarpal",leftThumbIntermediate:"leftThumbProximal",rightThumbProximal:"rightThumbMetacarpal",rightThumbIntermediate:"rightThumbProximal"},S2=class{get name(){return"VRMHumanoidLoaderPlugin"}constructor(o,t){this.parser=o,this.helperRoot=t?.helperRoot,this.autoUpdateHumanBones=t?.autoUpdateHumanBones}afterRoot(o){return ft(this,null,function*(){o.userData.vrmHumanoid=yield this._import(o)})}_import(o){return ft(this,null,function*(){const t=yield this._v1Import(o);if(t)return t;const e=yield this._v0Import(o);return e||null})}_v1Import(o){return ft(this,null,function*(){var t,e;const i=this.parser.json;if(!(((t=i.extensionsUsed)==null?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;const n=(e=i.extensions)==null?void 0:e.VRMC_vrm;if(!n)return null;const r=n.specVersion;if(!b2.has(r))return console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${r}"`),null;const a=n.humanoid;if(!a)return null;const l=a.humanBones.leftThumbIntermediate!=null||a.humanBones.rightThumbIntermediate!=null,h={};a.humanBones!=null&&(yield Promise.all(Object.entries(a.humanBones).map(c=>ft(this,[c],function*([d,p]){let f=d;const m=p.node;if(l){const y=px[f];y!=null&&(f=y)}const g=yield this.parser.getDependency("node",m);if(g==null){console.warn(`A glTF node bound to the humanoid bone ${f} (index = ${m}) does not exist`);return}h[f]={node:g}}))));const u=new dx(this._ensureRequiredBonesExist(h),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(o.scene.add(u.normalizedHumanBonesRoot),this.helperRoot){const c=new ux(u);this.helperRoot.add(c),c.renderOrder=this.helperRoot.renderOrder}return u})}_v0Import(o){return ft(this,null,function*(){var t;const i=(t=this.parser.json.extensions)==null?void 0:t.VRM;if(!i)return null;const s=i.humanoid;if(!s)return null;const n={};s.humanBones!=null&&(yield Promise.all(s.humanBones.map(a=>ft(this,null,function*(){const l=a.bone,h=a.node;if(l==null||h==null)return;const u=yield this.parser.getDependency("node",h);if(u==null){console.warn(`A glTF node bound to the humanoid bone ${l} (index = ${h}) does not exist`);return}const c=px[l],d=c??l;if(n[d]!=null){console.warn(`Multiple bone entries for ${d} detected (index = ${h}), ignoring duplicated entries.`);return}n[d]={node:u}}))));const r=new dx(this._ensureRequiredBonesExist(n),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(o.scene.add(r.normalizedHumanBonesRoot),this.helperRoot){const a=new ux(r);this.helperRoot.add(a),a.renderOrder=this.helperRoot.renderOrder}return r})}_ensureRequiredBonesExist(o){const t=Object.values(T2).filter(e=>o[e]==null);if(t.length>0)throw new Error(`VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${t.join(", ")}`);return o}},fx=class extends Ke{constructor(){super(),this._currentTheta=0,this._currentRadius=0,this.theta=0,this.radius=0,this._currentTheta=0,this._currentRadius=0,this._attrPos=new It(new Float32Array(65*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new It(new Uint16Array(3*63),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let o=!1;this._currentTheta!==this.theta&&(this._currentTheta=this.theta,o=!0),this._currentRadius!==this.radius&&(this._currentRadius=this.radius,o=!0),o&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,0,0,0);for(let o=0;o<64;o++){const t=o/63*this._currentTheta;this._attrPos.setXYZ(o+1,this._currentRadius*Math.sin(t),0,this._currentRadius*Math.cos(t))}this._attrPos.needsUpdate=!0}_buildIndex(){for(let o=0;o<63;o++)this._attrIndex.setXYZ(o*3,0,o+1,o+2);this._attrIndex.needsUpdate=!0}},w2=class extends Ke{constructor(){super(),this.radius=0,this._currentRadius=0,this.tail=new S,this._currentTail=new S,this._attrPos=new It(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new It(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let o=!1;this._currentRadius!==this.radius&&(this._currentRadius=this.radius,o=!0),this._currentTail.equals(this.tail)||(this._currentTail.copy(this.tail),o=!0),o&&this._buildPosition()}_buildPosition(){for(let o=0;o<32;o++){const t=o/16*Math.PI;this._attrPos.setXYZ(o,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+o,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+o,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let o=0;o<32;o++){const t=(o+1)%32;this._attrIndex.setXY(o*2,o,t),this._attrIndex.setXY(64+o*2,32+o,32+t),this._attrIndex.setXY(128+o*2,64+o,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}},zl=new rt,mx=new rt,Do=new S,gx=new S,yx=Math.sqrt(2)/2,A2=new rt(0,0,-yx,yx),N2=new S(0,1,0),R2=class extends Jr{constructor(o){super(),this.matrixAutoUpdate=!1,this.vrmLookAt=o;{const t=new fx;t.radius=.5;const e=new ud({color:65280,transparent:!0,opacity:.5,side:$f,depthTest:!1,depthWrite:!1});this._meshPitch=new ta(t,e),this.add(this._meshPitch)}{const t=new fx;t.radius=.5;const e=new ud({color:16711680,transparent:!0,opacity:.5,side:$f,depthTest:!1,depthWrite:!1});this._meshYaw=new ta(t,e),this.add(this._meshYaw)}{const t=new w2;t.radius=.1;const e=new Kr({color:16777215,depthTest:!1,depthWrite:!1});this._lineTarget=new zh(t,e),this._lineTarget.frustumCulled=!1,this.add(this._lineTarget)}}dispose(){this._meshYaw.geometry.dispose(),this._meshYaw.material.dispose(),this._meshPitch.geometry.dispose(),this._meshPitch.material.dispose(),this._lineTarget.geometry.dispose(),this._lineTarget.material.dispose()}updateMatrixWorld(o){const t=zt.DEG2RAD*this.vrmLookAt.yaw;this._meshYaw.geometry.theta=t,this._meshYaw.geometry.update();const e=zt.DEG2RAD*this.vrmLookAt.pitch;this._meshPitch.geometry.theta=e,this._meshPitch.geometry.update(),this.vrmLookAt.getLookAtWorldPosition(Do),this.vrmLookAt.getLookAtWorldQuaternion(zl),zl.multiply(this.vrmLookAt.getFaceFrontQuaternion(mx)),this._meshYaw.position.copy(Do),this._meshYaw.quaternion.copy(zl),this._meshPitch.position.copy(Do),this._meshPitch.quaternion.copy(zl),this._meshPitch.quaternion.multiply(mx.setFromAxisAngle(N2,t)),this._meshPitch.quaternion.multiply(A2);const{target:i,autoUpdate:s}=this.vrmLookAt;i!=null&&s&&(i.getWorldPosition(gx).sub(Do),this._lineTarget.geometry.tail.copy(gx),this._lineTarget.geometry.update(),this._lineTarget.position.copy(Do)),super.updateMatrixWorld(o)}},E2=new S,C2=new S;function pp(o,t){return o.matrixWorld.decompose(E2,t,C2),t}function th(o){return[Math.atan2(-o.z,o.x),Math.atan2(o.y,Math.sqrt(o.x*o.x+o.z*o.z))]}function xx(o){const t=Math.round(o/2/Math.PI);return o-2*Math.PI*t}var _x=new S(0,0,1),P2=new S,F2=new S,I2=new S,B2=new rt,qc=new rt,Mx=new rt,L2=new rt,jc=new ps,fT=class mT{constructor(t,e){this.offsetFromHeadBone=new S,this.autoUpdate=!0,this.faceFront=new S(0,0,1),this.humanoid=t,this.applier=e,this._yaw=0,this._pitch=0,this._needsUpdate=!0,this._restHeadWorldQuaternion=this.getLookAtWorldQuaternion(new rt)}get yaw(){return this._yaw}set yaw(t){this._yaw=t,this._needsUpdate=!0}get pitch(){return this._pitch}set pitch(t){this._pitch=t,this._needsUpdate=!0}get euler(){return console.warn("VRMLookAt: euler is deprecated. use getEuler() instead."),this.getEuler(new ps)}getEuler(t){return t.set(zt.DEG2RAD*this._pitch,zt.DEG2RAD*this._yaw,0,"YXZ")}copy(t){if(this.humanoid!==t.humanoid)throw new Error("VRMLookAt: humanoid must be same in order to copy");return this.offsetFromHeadBone.copy(t.offsetFromHeadBone),this.applier=t.applier,this.autoUpdate=t.autoUpdate,this.target=t.target,this.faceFront.copy(t.faceFront),this}clone(){return new mT(this.humanoid,this.applier).copy(this)}reset(){this._yaw=0,this._pitch=0,this._needsUpdate=!0}getLookAtWorldPosition(t){const e=this.humanoid.getRawBoneNode("head");return t.copy(this.offsetFromHeadBone).applyMatrix4(e.matrixWorld)}getLookAtWorldQuaternion(t){const e=this.humanoid.getRawBoneNode("head");return pp(e,t)}getFaceFrontQuaternion(t){if(this.faceFront.distanceToSquared(_x)<.01)return t.copy(this._restHeadWorldQuaternion).invert();const[e,i]=th(this.faceFront);return jc.set(0,.5*Math.PI+e,i,"YZX"),t.setFromEuler(jc).premultiply(L2.copy(this._restHeadWorldQuaternion).invert())}getLookAtWorldDirection(t){return this.getLookAtWorldQuaternion(qc),this.getFaceFrontQuaternion(Mx),t.copy(_x).applyQuaternion(qc).applyQuaternion(Mx).applyEuler(this.getEuler(jc))}lookAt(t){const e=B2.copy(this._restHeadWorldQuaternion).multiply(cT(this.getLookAtWorldQuaternion(qc))),i=this.getLookAtWorldPosition(F2),s=I2.copy(t).sub(i).applyQuaternion(e).normalize(),[n,r]=th(this.faceFront),[a,l]=th(s),h=xx(a-n),u=xx(r-l);this._yaw=zt.RAD2DEG*h,this._pitch=zt.RAD2DEG*u,this._needsUpdate=!0}update(t){this.target!=null&&this.autoUpdate&&this.lookAt(this.target.getWorldPosition(P2)),this._needsUpdate&&(this._needsUpdate=!1,this.applier.applyYawPitch(this._yaw,this._pitch))}};fT.EULER_ORDER="YXZ";var U2=fT,D2=new S(0,0,1),Ri=new rt,mr=new rt,si=new ps(0,0,0,"YXZ"),eh=class{constructor(o,t,e,i,s){this.humanoid=o,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=e,this.rangeMapVerticalDown=i,this.rangeMapVerticalUp=s,this.faceFront=new S(0,0,1),this._restQuatLeftEye=new rt,this._restQuatRightEye=new rt,this._restLeftEyeParentWorldQuat=new rt,this._restRightEyeParentWorldQuat=new rt;const n=this.humanoid.getRawBoneNode("leftEye"),r=this.humanoid.getRawBoneNode("rightEye");n&&(this._restQuatLeftEye.copy(n.quaternion),pp(n.parent,this._restLeftEyeParentWorldQuat)),r&&(this._restQuatRightEye.copy(r.quaternion),pp(r.parent,this._restRightEyeParentWorldQuat))}applyYawPitch(o,t){const e=this.humanoid.getRawBoneNode("leftEye"),i=this.humanoid.getRawBoneNode("rightEye"),s=this.humanoid.getNormalizedBoneNode("leftEye"),n=this.humanoid.getNormalizedBoneNode("rightEye");e&&(t<0?si.x=-zt.DEG2RAD*this.rangeMapVerticalDown.map(-t):si.x=zt.DEG2RAD*this.rangeMapVerticalUp.map(t),o<0?si.y=-zt.DEG2RAD*this.rangeMapHorizontalInner.map(-o):si.y=zt.DEG2RAD*this.rangeMapHorizontalOuter.map(o),Ri.setFromEuler(si),this._getWorldFaceFrontQuat(mr),s.quaternion.copy(mr).multiply(Ri).multiply(mr.invert()),Ri.copy(this._restLeftEyeParentWorldQuat),e.quaternion.copy(s.quaternion).multiply(Ri).premultiply(Ri.invert()).multiply(this._restQuatLeftEye)),i&&(t<0?si.x=-zt.DEG2RAD*this.rangeMapVerticalDown.map(-t):si.x=zt.DEG2RAD*this.rangeMapVerticalUp.map(t),o<0?si.y=-zt.DEG2RAD*this.rangeMapHorizontalOuter.map(-o):si.y=zt.DEG2RAD*this.rangeMapHorizontalInner.map(o),Ri.setFromEuler(si),this._getWorldFaceFrontQuat(mr),n.quaternion.copy(mr).multiply(Ri).multiply(mr.invert()),Ri.copy(this._restRightEyeParentWorldQuat),i.quaternion.copy(n.quaternion).multiply(Ri).premultiply(Ri.invert()).multiply(this._restQuatRightEye))}lookAt(o){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const t=zt.RAD2DEG*o.y,e=zt.RAD2DEG*o.x;this.applyYawPitch(t,e)}_getWorldFaceFrontQuat(o){if(this.faceFront.distanceToSquared(D2)<.01)return o.identity();const[t,e]=th(this.faceFront);return si.set(0,.5*Math.PI+t,e,"YZX"),o.setFromEuler(si)}};eh.type="bone";var fp=class{constructor(o,t,e,i,s){this.expressions=o,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=e,this.rangeMapVerticalDown=i,this.rangeMapVerticalUp=s}applyYawPitch(o,t){t<0?(this.expressions.setValue("lookDown",0),this.expressions.setValue("lookUp",this.rangeMapVerticalUp.map(-t))):(this.expressions.setValue("lookUp",0),this.expressions.setValue("lookDown",this.rangeMapVerticalDown.map(t))),o<0?(this.expressions.setValue("lookLeft",0),this.expressions.setValue("lookRight",this.rangeMapHorizontalOuter.map(-o))):(this.expressions.setValue("lookRight",0),this.expressions.setValue("lookLeft",this.rangeMapHorizontalOuter.map(o)))}lookAt(o){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");const t=zt.RAD2DEG*o.y,e=zt.RAD2DEG*o.x;this.applyYawPitch(t,e)}};fp.type="expression";var vx=class{constructor(o,t){this.inputMaxValue=o,this.outputScale=t}map(o){return this.outputScale*sT(o/this.inputMaxValue)}},O2=new Set(["1.0","1.0-beta"]),Vl=.01,z2=class{get name(){return"VRMLookAtLoaderPlugin"}constructor(o,t){this.parser=o,this.helperRoot=t?.helperRoot}afterRoot(o){return ft(this,null,function*(){const t=o.userData.vrmHumanoid;if(t===null)return;if(t===void 0)throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");const e=o.userData.vrmExpressionManager;if(e!==null){if(e===void 0)throw new Error("VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");o.userData.vrmLookAt=yield this._import(o,t,e)}})}_import(o,t,e){return ft(this,null,function*(){if(t==null||e==null)return null;const i=yield this._v1Import(o,t,e);if(i)return i;const s=yield this._v0Import(o,t,e);return s||null})}_v1Import(o,t,e){return ft(this,null,function*(){var i,s,n;const r=this.parser.json;if(!(((i=r.extensionsUsed)==null?void 0:i.indexOf("VRMC_vrm"))!==-1))return null;const l=(s=r.extensions)==null?void 0:s.VRMC_vrm;if(!l)return null;const h=l.specVersion;if(!O2.has(h))return console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${h}"`),null;const u=l.lookAt;if(!u)return null;const c=u.type==="expression"?1:10,d=this._v1ImportRangeMap(u.rangeMapHorizontalInner,c),p=this._v1ImportRangeMap(u.rangeMapHorizontalOuter,c),f=this._v1ImportRangeMap(u.rangeMapVerticalDown,c),m=this._v1ImportRangeMap(u.rangeMapVerticalUp,c);let g;u.type==="expression"?g=new fp(e,d,p,f,m):g=new eh(t,d,p,f,m);const y=this._importLookAt(t,g);return y.offsetFromHeadBone.fromArray((n=u.offsetFromHeadBone)!=null?n:[0,.06,0]),y})}_v1ImportRangeMap(o,t){var e,i;let s=(e=o?.inputMaxValue)!=null?e:90;const n=(i=o?.outputScale)!=null?i:t;return s<Vl&&(console.warn("VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"),s=Vl),new vx(s,n)}_v0Import(o,t,e){return ft(this,null,function*(){var i,s,n,r;const l=(i=this.parser.json.extensions)==null?void 0:i.VRM;if(!l)return null;const h=l.firstPerson;if(!h)return null;const u=h.lookAtTypeName==="BlendShape"?1:10,c=this._v0ImportDegreeMap(h.lookAtHorizontalInner,u),d=this._v0ImportDegreeMap(h.lookAtHorizontalOuter,u),p=this._v0ImportDegreeMap(h.lookAtVerticalDown,u),f=this._v0ImportDegreeMap(h.lookAtVerticalUp,u);let m;h.lookAtTypeName==="BlendShape"?m=new fp(e,c,d,p,f):m=new eh(t,c,d,p,f);const g=this._importLookAt(t,m);return h.firstPersonBoneOffset?g.offsetFromHeadBone.set((s=h.firstPersonBoneOffset.x)!=null?s:0,(n=h.firstPersonBoneOffset.y)!=null?n:.06,-((r=h.firstPersonBoneOffset.z)!=null?r:0)):g.offsetFromHeadBone.set(0,.06,0),g.faceFront.set(0,0,-1),m instanceof eh&&m.faceFront.set(0,0,-1),g})}_v0ImportDegreeMap(o,t){var e,i;const s=o?.curve;JSON.stringify(s)!=="[0,0,0,1,1,1,1,0]"&&console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");let n=(e=o?.xRange)!=null?e:90;const r=(i=o?.yRange)!=null?i:t;return n<Vl&&(console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!"),n=Vl),new vx(n,r)}_importLookAt(o,t){const e=new U2(o,t);if(this.helperRoot){const i=new R2(e);this.helperRoot.add(i),i.renderOrder=this.helperRoot.renderOrder}return e}};function V2(o,t){return typeof o!="string"||o===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(o)&&(t=t.replace(/(^https?:\/\/[^/]+).*/i,"$1")),/^(https?:)?\/\//i.test(o)||/^data:.*,.*$/i.test(o)||/^blob:.*$/i.test(o)?o:t+o)}var k2=new Set(["1.0","1.0-beta"]),G2=class{get name(){return"VRMMetaLoaderPlugin"}constructor(o,t){var e,i,s;this.parser=o,this.needThumbnailImage=(e=t?.needThumbnailImage)!=null?e:!1,this.acceptLicenseUrls=(i=t?.acceptLicenseUrls)!=null?i:["https://vrm.dev/licenses/1.0/"],this.acceptV0Meta=(s=t?.acceptV0Meta)!=null?s:!0}afterRoot(o){return ft(this,null,function*(){o.userData.vrmMeta=yield this._import(o)})}_import(o){return ft(this,null,function*(){const t=yield this._v1Import(o);if(t!=null)return t;const e=yield this._v0Import(o);return e??null})}_v1Import(o){return ft(this,null,function*(){var t,e,i;const s=this.parser.json;if(!(((t=s.extensionsUsed)==null?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;const r=(e=s.extensions)==null?void 0:e.VRMC_vrm;if(r==null)return null;const a=r.specVersion;if(!k2.has(a))return console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${a}"`),null;const l=r.meta;if(!l)return null;const h=l.licenseUrl;if(!new Set(this.acceptLicenseUrls).has(h))throw new Error(`VRMMetaLoaderPlugin: The license url "${h}" is not accepted`);let c;return this.needThumbnailImage&&l.thumbnailImage!=null&&(c=(i=yield this._extractGLTFImage(l.thumbnailImage))!=null?i:void 0),{metaVersion:"1",name:l.name,version:l.version,authors:l.authors,copyrightInformation:l.copyrightInformation,contactInformation:l.contactInformation,references:l.references,thirdPartyLicenses:l.thirdPartyLicenses,thumbnailImage:c,licenseUrl:l.licenseUrl,avatarPermission:l.avatarPermission,allowExcessivelyViolentUsage:l.allowExcessivelyViolentUsage,allowExcessivelySexualUsage:l.allowExcessivelySexualUsage,commercialUsage:l.commercialUsage,allowPoliticalOrReligiousUsage:l.allowPoliticalOrReligiousUsage,allowAntisocialOrHateUsage:l.allowAntisocialOrHateUsage,creditNotation:l.creditNotation,allowRedistribution:l.allowRedistribution,modification:l.modification,otherLicenseUrl:l.otherLicenseUrl}})}_v0Import(o){return ft(this,null,function*(){var t;const i=(t=this.parser.json.extensions)==null?void 0:t.VRM;if(!i)return null;const s=i.meta;if(!s)return null;if(!this.acceptV0Meta)throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");let n;return this.needThumbnailImage&&s.texture!=null&&s.texture!==-1&&(n=yield this.parser.getDependency("texture",s.texture)),{metaVersion:"0",allowedUserName:s.allowedUserName,author:s.author,commercialUssageName:s.commercialUssageName,contactInformation:s.contactInformation,licenseName:s.licenseName,otherLicenseUrl:s.otherLicenseUrl,otherPermissionUrl:s.otherPermissionUrl,reference:s.reference,sexualUssageName:s.sexualUssageName,texture:n??void 0,title:s.title,version:s.version,violentUssageName:s.violentUssageName}})}_extractGLTFImage(o){return ft(this,null,function*(){var t;const i=(t=this.parser.json.images)==null?void 0:t[o];if(i==null)return console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${o}] of glTF as a thumbnail but the image doesn't exist`),null;let s=i.uri;if(i.bufferView!=null){const r=yield this.parser.getDependency("bufferView",i.bufferView),a=new Blob([r],{type:i.mimeType});s=URL.createObjectURL(a)}return s==null?(console.warn(`VRMMetaLoaderPlugin: Attempt to use images[${o}] of glTF as a thumbnail but the image couldn't load properly`),null):yield new o0().loadAsync(V2(s,this.parser.options.path)).catch(r=>(console.error(r),console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image"),null))})}},W2=class{constructor(o){this.scene=o.scene,this.meta=o.meta,this.humanoid=o.humanoid,this.expressionManager=o.expressionManager,this.firstPerson=o.firstPerson,this.lookAt=o.lookAt}update(o){this.humanoid.update(),this.lookAt&&this.lookAt.update(o),this.expressionManager&&this.expressionManager.update()}},H2=class extends W2{constructor(o){super(o),this.materials=o.materials,this.springBoneManager=o.springBoneManager,this.nodeConstraintManager=o.nodeConstraintManager}update(o){super.update(o),this.nodeConstraintManager&&this.nodeConstraintManager.update(),this.springBoneManager&&this.springBoneManager.update(o),this.materials&&this.materials.forEach(t=>{t.update&&t.update(o)})}},$2=Object.defineProperty,Tx=Object.getOwnPropertySymbols,q2=Object.prototype.hasOwnProperty,j2=Object.prototype.propertyIsEnumerable,bx=(o,t,e)=>t in o?$2(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,Sx=(o,t)=>{for(var e in t||(t={}))q2.call(t,e)&&bx(o,e,t[e]);if(Tx)for(var e of Tx(t))j2.call(t,e)&&bx(o,e,t[e]);return o},gn=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),X2={"":3e3,srgb:3001};function Y2(o,t){parseInt(Ni,10)>=152?o.colorSpace=t:o.encoding=X2[t]}var Z2=class{get pending(){return Promise.all(this._pendings)}constructor(o,t){this._parser=o,this._materialParams=t,this._pendings=[]}assignPrimitive(o,t){t!=null&&(this._materialParams[o]=t)}assignColor(o,t,e){t!=null&&(this._materialParams[o]=new lt().fromArray(t),e&&this._materialParams[o].convertSRGBToLinear())}assignTexture(o,t,e){return gn(this,null,function*(){const i=gn(this,null,function*(){t!=null&&(yield this._parser.assignTexture(this._materialParams,o,t),e&&Y2(this._materialParams[o],"srgb"))});return this._pendings.push(i),i})}assignTextureByIndex(o,t,e){return gn(this,null,function*(){return this.assignTexture(o,t!=null?{index:t}:void 0,e)})}},Q2=`// #define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED
  varying vec3 vNormal;
#endif

#include <common>

// #include <uv_pars_vertex>
#ifdef MTOON_USE_UV
  varying vec2 vUv;

  // COMPAT: pre-r151 uses a common uvTransform
  #if THREE_VRM_THREE_REVISION < 151
    uniform mat3 uvTransform;
  #endif
#endif

// #include <uv2_pars_vertex>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    attribute vec2 uv2;
    varying vec2 vUv2;
    uniform mat3 uv2Transform;
  #endif
#endif

// #include <displacementmap_pars_vertex>
// #include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
  uniform sampler2D outlineWidthMultiplyTexture;
  uniform mat3 outlineWidthMultiplyTextureUvTransform;
#endif

uniform float outlineWidthFactor;

void main() {

  // #include <uv_vertex>
  #ifdef MTOON_USE_UV
    // COMPAT: pre-r151 uses a common uvTransform
    #if THREE_VRM_THREE_REVISION >= 151
      vUv = uv;
    #else
      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    #endif
  #endif

  // #include <uv2_vertex>
  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap
  #if THREE_VRM_THREE_REVISION < 151
    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
    #endif
  #endif

  #include <color_vertex>

  #include <beginnormal_vertex>
  #include <morphnormal_vertex>
  #include <skinbase_vertex>
  #include <skinnormal_vertex>

  // we need this to compute the outline properly
  objectNormal = normalize( objectNormal );

  #include <defaultnormal_vertex>

  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED
    vNormal = normalize( transformedNormal );
  #endif

  #include <begin_vertex>

  #include <morphtarget_vertex>
  #include <skinning_vertex>
  // #include <displacementmap_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>

  vViewPosition = - mvPosition.xyz;

  #ifdef OUTLINE
    float worldNormalLength = length( transformedNormal );
    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;

    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE
      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;
      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;
      outlineOffset *= outlineTex;
    #endif

    #ifdef OUTLINE_WIDTH_SCREEN
      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );

    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic
  #endif

  #include <worldpos_vertex>
  // #include <envmap_vertex>
  #include <shadowmap_vertex>
  #include <fog_vertex>

}`,J2=`// #define PHONG

uniform vec3 litFactor;

uniform float opacity;

uniform vec3 shadeColorFactor;
#ifdef USE_SHADEMULTIPLYTEXTURE
  uniform sampler2D shadeMultiplyTexture;
  uniform mat3 shadeMultiplyTextureUvTransform;
#endif

uniform float shadingShiftFactor;
uniform float shadingToonyFactor;

#ifdef USE_SHADINGSHIFTTEXTURE
  uniform sampler2D shadingShiftTexture;
  uniform mat3 shadingShiftTextureUvTransform;
  uniform float shadingShiftTextureScale;
#endif

uniform float giEqualizationFactor;

uniform vec3 parametricRimColorFactor;
#ifdef USE_RIMMULTIPLYTEXTURE
  uniform sampler2D rimMultiplyTexture;
  uniform mat3 rimMultiplyTextureUvTransform;
#endif
uniform float rimLightingMixFactor;
uniform float parametricRimFresnelPowerFactor;
uniform float parametricRimLiftFactor;

#ifdef USE_MATCAPTEXTURE
  uniform vec3 matcapFactor;
  uniform sampler2D matcapTexture;
  uniform mat3 matcapTextureUvTransform;
#endif

uniform vec3 emissive;
uniform float emissiveIntensity;

uniform vec3 outlineColorFactor;
uniform float outlineLightingMixFactor;

#ifdef USE_UVANIMATIONMASKTEXTURE
  uniform sampler2D uvAnimationMaskTexture;
  uniform mat3 uvAnimationMaskTextureUvTransform;
#endif

uniform float uvAnimationScrollXOffset;
uniform float uvAnimationScrollYOffset;
uniform float uvAnimationRotationPhase;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>

// #include <uv_pars_fragment>
#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
  varying vec2 vUv;
#endif

// #include <uv2_pars_fragment>
// COMAPT: pre-r151 uses uv2 for lightMap and aoMap
#if THREE_VRM_THREE_REVISION < 151
  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
    varying vec2 vUv2;
  #endif
#endif

#include <map_pars_fragment>

#ifdef USE_MAP
  uniform mat3 mapUvTransform;
#endif

// #include <alphamap_pars_fragment>

#include <alphatest_pars_fragment>

#include <aomap_pars_fragment>
// #include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>

#ifdef USE_EMISSIVEMAP
  uniform mat3 emissiveMapUvTransform;
#endif

// #include <envmap_common_pars_fragment>
// #include <envmap_pars_fragment>
// #include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>

// #include <bsdfs>
// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>
#if THREE_VRM_THREE_REVISION < 151
  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
    return RECIPROCAL_PI * diffuseColor;
  }
#endif

#include <lights_pars_begin>

#include <normal_pars_fragment>

// #include <lights_phong_pars_fragment>
varying vec3 vViewPosition;

struct MToonMaterial {
  vec3 diffuseColor;
  vec3 shadeColor;
  float shadingShift;
};

float linearstep( float a, float b, float t ) {
  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );
}

/**
 * Convert NdotL into toon shading factor using shadingShift and shadingToony
 */
float getShading(
  const in float dotNL,
  const in float shadow,
  const in float shadingShift
) {
  float shading = dotNL;
  shading = shading + shadingShift;
  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );
  shading *= shadow;
  return shading;
}

/**
 * Mix diffuseColor and shadeColor using shading factor and light color
 */
vec3 getDiffuse(
  const in MToonMaterial material,
  const in float shading,
  in vec3 lightColor
) {
  #ifdef DEBUG_LITSHADERATE
    return vec3( BRDF_Lambert( shading * lightColor ) );
  #endif

  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );

  // The "comment out if you want to PBR absolutely" line
  #ifdef V0_COMPAT_SHADE
    col = min( col, material.diffuseColor );
  #endif

  return col;
}

// COMPAT: pre-r156 uses a struct GeometricContext
#if THREE_VRM_THREE_REVISION >= 157
  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#else
  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {
    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );
    vec3 irradiance = directLight.color;

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;

    irradiance *= dotNL;

    float shading = getShading( dotNL, shadow, material.shadingShift );

    // toon shaded diffuse
    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );
  }

  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {
    // indirect diffuse will use diffuseColor, no shadeColor involved
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

    // directSpecular will be used for rim lighting, not an actual specular
    reflectedLight.directSpecular += irradiance;
  }
#endif

#define RE_Direct RE_Direct_MToon
#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon
#define Material_LightProbeLOD( material ) (0)

#include <shadowmap_pars_fragment>
// #include <bumpmap_pars_fragment>

// #include <normalmap_pars_fragment>
#ifdef USE_NORMALMAP

  uniform sampler2D normalMap;
  uniform mat3 normalMapUvTransform;
  uniform vec2 normalScale;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

  uniform mat3 normalMatrix;

#endif

// COMPAT: pre-r151
// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )

  // Per-Pixel Tangent Space Normal Mapping
  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

  // three-vrm specific change: it requires \`uv\` as an input in order to support uv scrolls

  // Temporary compat against shader change @ Three.js r126, r151
  #if THREE_VRM_THREE_REVISION >= 151

    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

      vec3 q0 = dFdx( eye_pos.xyz );
      vec3 q1 = dFdy( eye_pos.xyz );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = surf_norm;

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

      return mat3( T * scale, B * scale, N );

    }

  #else

    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
      vec2 st0 = dFdx( uv.st );
      vec2 st1 = dFdy( uv.st );

      vec3 N = normalize( surf_norm );

      vec3 q1perp = cross( q1, N );
      vec3 q0perp = cross( N, q0 );

      vec3 T = q1perp * st0.x + q0perp * st1.x;
      vec3 B = q1perp * st0.y + q0perp * st1.y;

      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0
      // TODO: Is this still required? Or shall I make a PR about it?
      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {
        return surf_norm;
      }

      float det = max( dot( T, T ), dot( B, B ) );
      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

    }

  #endif

#endif

// #include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// == post correction ==========================================================
void postCorrection() {
  #include <tonemapping_fragment>
  #include <colorspace_fragment>
  #include <fog_fragment>
  #include <premultiplied_alpha_fragment>
  #include <dithering_fragment>
}

// == main procedure ===========================================================
void main() {
  #include <clipping_planes_fragment>

  vec2 uv = vec2(0.5, 0.5);

  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
    uv = vUv;

    float uvAnimMask = 1.0;
    #ifdef USE_UVANIMATIONMASKTEXTURE
      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;
      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;
    #endif

    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );
    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );
    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;
    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;
  #endif

  #ifdef DEBUG_UV
    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )
      gl_FragColor = vec4( uv, 0.0, 1.0 );
    #endif
    return;
  #endif

  vec4 diffuseColor = vec4( litFactor, opacity );
  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;

  #include <logdepthbuf_fragment>

  // #include <map_fragment>
  #ifdef USE_MAP
    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;
    vec4 sampledDiffuseColor = texture2D( map, mapUv );
    #ifdef DECODE_VIDEO_TEXTURE
      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
    #endif
    diffuseColor *= sampledDiffuseColor;
  #endif

  // #include <color_fragment>
  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    diffuseColor.rgb *= vColor;
  #endif

  // #include <alphamap_fragment>

  #include <alphatest_fragment>

  // #include <specularmap_fragment>

  // #include <normal_fragment_begin>
  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;

  #ifdef FLAT_SHADED

    vec3 fdx = dFdx( vViewPosition );
    vec3 fdy = dFdy( vViewPosition );
    vec3 normal = normalize( cross( fdx, fdy ) );

  #else

    vec3 normal = normalize( vNormal );

    #ifdef DOUBLE_SIDED

      normal *= faceDirection;

    #endif

  #endif

  #ifdef USE_NORMALMAP

    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;

  #endif

  #ifdef USE_NORMALMAP_TANGENTSPACE

    #ifdef USE_TANGENT

      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn[0] *= faceDirection;
      tbn[1] *= faceDirection;

    #endif

  #endif

  #ifdef USE_CLEARCOAT_NORMALMAP

    #ifdef USE_TANGENT

      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

    #else

      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

    #endif

    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

      tbn2[0] *= faceDirection;
      tbn2[1] *= faceDirection;

    #endif

  #endif

  // non perturbed normal for clearcoat among others

  vec3 nonPerturbedNormal = normal;

  #ifdef OUTLINE
    normal *= -1.0;
  #endif

  // #include <normal_fragment_maps>

  // COMPAT: pre-r151
  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151
  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )

    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

    #ifdef FLIP_SIDED

      normal = - normal;

    #endif

    #ifdef DOUBLE_SIDED

      normal = normal * faceDirection;

    #endif

    normal = normalize( normalMatrix * normal );

  // COMPAT: pre-r151
  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151
  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )

    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;
    mapN.xy *= normalScale;

    // COMPAT: pre-r151
    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )

      normal = normalize( tbn * mapN );

    #else

      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );

    #endif

  #endif

  // #include <emissivemap_fragment>
  #ifdef USE_EMISSIVEMAP
    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;
    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;
  #endif

  #ifdef DEBUG_NORMAL
    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );
    return;
  #endif

  // -- MToon: lighting --------------------------------------------------------
  // accumulation
  // #include <lights_phong_fragment>
  MToonMaterial material;

  material.diffuseColor = diffuseColor.rgb;

  material.shadeColor = shadeColorFactor;
  #ifdef USE_SHADEMULTIPLYTEXTURE
    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;
  #endif

  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )
    material.shadeColor.rgb *= vColor;
  #endif

  material.shadingShift = shadingShiftFactor;
  #ifdef USE_SHADINGSHIFTTEXTURE
    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;
    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;
  #endif

  // #include <lights_fragment_begin>

  // MToon Specific changes:
  // Since we want to take shadows into account of shading instead of irradiance,
  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.

  // COMPAT: pre-r156 uses a struct GeometricContext
  #if THREE_VRM_THREE_REVISION >= 157
    vec3 geometryPosition = - vViewPosition;
    vec3 geometryNormal = normal;
    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    vec3 geometryClearcoatNormal;

    #ifdef USE_CLEARCOAT

      geometryClearcoatNormal = clearcoatNormal;

    #endif
  #else
    GeometricContext geometry;

    geometry.position = - vViewPosition;
    geometry.normal = normal;
    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

    #ifdef USE_CLEARCOAT

      geometry.clearcoatNormal = clearcoatNormal;

    #endif
  #endif

  IncidentLight directLight;

  // since these variables will be used in unrolled loop, we have to define in prior
  float shadow;

  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

    PointLight pointLight;
    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
    PointLightShadow pointLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

      pointLight = pointLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getPointLightInfo( pointLight, geometryPosition, directLight );
      #else
        getPointLightInfo( pointLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
      pointLightShadow = pointLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

    SpotLight spotLight;
    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
    SpotLightShadow spotLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

      spotLight = spotLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getSpotLightInfo( spotLight, geometryPosition, directLight );
      #else
        getSpotLightInfo( spotLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
      spotLightShadow = spotLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

    DirectionalLight directionalLight;
    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
    DirectionalLightShadow directionalLightShadow;
    #endif

    #pragma unroll_loop_start
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

      directionalLight = directionalLights[ i ];

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        getDirectionalLightInfo( directionalLight, directLight );
      #else
        getDirectionalLightInfo( directionalLight, geometry, directLight );
      #endif

      shadow = 1.0;
      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
      directionalLightShadow = directionalLightShadows[ i ];
      // COMPAT: pre-r166
      // r166 introduced shadowIntensity
      #if THREE_VRM_THREE_REVISION >= 166
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #else
        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
      #endif
      #endif

      // COMPAT: pre-r156 uses a struct GeometricContext
      #if THREE_VRM_THREE_REVISION >= 157
        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );
      #else
        RE_Direct( directLight, geometry, material, shadow, reflectedLight );
      #endif

    }
    #pragma unroll_loop_end

  #endif

  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

  //   RectAreaLight rectAreaLight;

  //   #pragma unroll_loop_start
  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

  //     rectAreaLight = rectAreaLights[ i ];
  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

  //   }
  //   #pragma unroll_loop_end

  // #endif

  #if defined( RE_IndirectDiffuse )

    vec3 iblIrradiance = vec3( 0.0 );

    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

    // COMPAT: pre-r156 uses a struct GeometricContext
    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES
    #if THREE_VRM_THREE_REVISION >= 157
      #if defined( USE_LIGHT_PROBES )
        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
      #endif
    #else
      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
    #endif

    #if ( NUM_HEMI_LIGHTS > 0 )

      #pragma unroll_loop_start
      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

        // COMPAT: pre-r156 uses a struct GeometricContext
        #if THREE_VRM_THREE_REVISION >= 157
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
        #else
          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
        #endif

      }
      #pragma unroll_loop_end

    #endif

  #endif

  // #if defined( RE_IndirectSpecular )

  //   vec3 radiance = vec3( 0.0 );
  //   vec3 clearcoatRadiance = vec3( 0.0 );

  // #endif

  #include <lights_fragment_maps>
  #include <lights_fragment_end>

  // modulation
  #include <aomap_fragment>

  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;

  #ifdef DEBUG_LITSHADERATE
    gl_FragColor = vec4( col, diffuseColor.a );
    postCorrection();
    return;
  #endif

  // -- MToon: rim lighting -----------------------------------------
  vec3 viewDir = normalize( vViewPosition );

  #ifndef PHYSICALLY_CORRECT_LIGHTS
    reflectedLight.directSpecular /= PI;
  #endif
  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );

  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );

  #ifdef USE_MATCAPTEXTURE
    {
      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );
      vec3 y = cross( viewDir, x ); // guaranteed to be normalized
      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );
      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;
      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;
      rim += matcapFactor * matcap;
    }
  #endif

  #ifdef USE_RIMMULTIPLYTEXTURE
    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;
    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;
  #endif

  col += rimMix * rim;

  // -- MToon: Emission --------------------------------------------------------
  col += totalEmissiveRadiance;

  // #include <envmap_fragment>

  // -- Almost done! -----------------------------------------------------------
  #if defined( OUTLINE )
    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );
  #endif

  #ifdef OPAQUE
    diffuseColor.a = 1.0;
  #endif

  gl_FragColor = vec4( col, diffuseColor.a );
  postCorrection();
}
`,K2={None:"none"},wx={None:"none",ScreenCoordinates:"screenCoordinates"},tL={3e3:"",3001:"srgb"};function Xc(o){return parseInt(Ni,10)>=152?o.colorSpace:tL[o.encoding]}var eL=class extends Yx{constructor(o={}){var t;super({vertexShader:Q2,fragmentShader:J2}),this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.fog=!0,this.normalMapType=ca,this._ignoreVertexColor=!0,this._v0CompatShade=!1,this._debugMode=K2.None,this._outlineWidthMode=wx.None,this._isOutline=!1,o.transparentWithZWrite&&(o.depthWrite=!0),delete o.transparentWithZWrite,o.fog=!0,o.lights=!0,o.clipping=!0,this.uniforms=Xx.merge([Bi.common,Bi.normalmap,Bi.emissivemap,Bi.fog,Bi.lights,{litFactor:{value:new lt(1,1,1)},mapUvTransform:{value:new yt},colorAlpha:{value:1},normalMapUvTransform:{value:new yt},shadeColorFactor:{value:new lt(0,0,0)},shadeMultiplyTexture:{value:null},shadeMultiplyTextureUvTransform:{value:new yt},shadingShiftFactor:{value:0},shadingShiftTexture:{value:null},shadingShiftTextureUvTransform:{value:new yt},shadingShiftTextureScale:{value:1},shadingToonyFactor:{value:.9},giEqualizationFactor:{value:.9},matcapFactor:{value:new lt(1,1,1)},matcapTexture:{value:null},matcapTextureUvTransform:{value:new yt},parametricRimColorFactor:{value:new lt(0,0,0)},rimMultiplyTexture:{value:null},rimMultiplyTextureUvTransform:{value:new yt},rimLightingMixFactor:{value:1},parametricRimFresnelPowerFactor:{value:5},parametricRimLiftFactor:{value:0},emissive:{value:new lt(0,0,0)},emissiveIntensity:{value:1},emissiveMapUvTransform:{value:new yt},outlineWidthMultiplyTexture:{value:null},outlineWidthMultiplyTextureUvTransform:{value:new yt},outlineWidthFactor:{value:0},outlineColorFactor:{value:new lt(0,0,0)},outlineLightingMixFactor:{value:1},uvAnimationMaskTexture:{value:null},uvAnimationMaskTextureUvTransform:{value:new yt},uvAnimationScrollXOffset:{value:0},uvAnimationScrollYOffset:{value:0},uvAnimationRotationPhase:{value:0}},(t=o.uniforms)!=null?t:{}]),this.setValues(o),this._uploadUniformsWorkaround(),this.customProgramCacheKey=()=>[...Object.entries(this._generateDefines()).map(([e,i])=>`${e}:${i}`),this.matcapTexture?`matcapTextureColorSpace:${Xc(this.matcapTexture)}`:"",this.shadeMultiplyTexture?`shadeMultiplyTextureColorSpace:${Xc(this.shadeMultiplyTexture)}`:"",this.rimMultiplyTexture?`rimMultiplyTextureColorSpace:${Xc(this.rimMultiplyTexture)}`:""].join(","),this.onBeforeCompile=e=>{const i=parseInt(Ni,10),s=Object.entries(Sx(Sx({},this._generateDefines()),this.defines)).filter(([n,r])=>!!r).map(([n,r])=>`#define ${n} ${r}`).join(`
`)+`
`;e.vertexShader=s+e.vertexShader,e.fragmentShader=s+e.fragmentShader,i<154&&(e.fragmentShader=e.fragmentShader.replace("#include <colorspace_fragment>","#include <encodings_fragment>"))}}get color(){return this.uniforms.litFactor.value}set color(o){this.uniforms.litFactor.value=o}get map(){return this.uniforms.map.value}set map(o){this.uniforms.map.value=o}get normalMap(){return this.uniforms.normalMap.value}set normalMap(o){this.uniforms.normalMap.value=o}get normalScale(){return this.uniforms.normalScale.value}set normalScale(o){this.uniforms.normalScale.value=o}get emissive(){return this.uniforms.emissive.value}set emissive(o){this.uniforms.emissive.value=o}get emissiveIntensity(){return this.uniforms.emissiveIntensity.value}set emissiveIntensity(o){this.uniforms.emissiveIntensity.value=o}get emissiveMap(){return this.uniforms.emissiveMap.value}set emissiveMap(o){this.uniforms.emissiveMap.value=o}get shadeColorFactor(){return this.uniforms.shadeColorFactor.value}set shadeColorFactor(o){this.uniforms.shadeColorFactor.value=o}get shadeMultiplyTexture(){return this.uniforms.shadeMultiplyTexture.value}set shadeMultiplyTexture(o){this.uniforms.shadeMultiplyTexture.value=o}get shadingShiftFactor(){return this.uniforms.shadingShiftFactor.value}set shadingShiftFactor(o){this.uniforms.shadingShiftFactor.value=o}get shadingShiftTexture(){return this.uniforms.shadingShiftTexture.value}set shadingShiftTexture(o){this.uniforms.shadingShiftTexture.value=o}get shadingShiftTextureScale(){return this.uniforms.shadingShiftTextureScale.value}set shadingShiftTextureScale(o){this.uniforms.shadingShiftTextureScale.value=o}get shadingToonyFactor(){return this.uniforms.shadingToonyFactor.value}set shadingToonyFactor(o){this.uniforms.shadingToonyFactor.value=o}get giEqualizationFactor(){return this.uniforms.giEqualizationFactor.value}set giEqualizationFactor(o){this.uniforms.giEqualizationFactor.value=o}get matcapFactor(){return this.uniforms.matcapFactor.value}set matcapFactor(o){this.uniforms.matcapFactor.value=o}get matcapTexture(){return this.uniforms.matcapTexture.value}set matcapTexture(o){this.uniforms.matcapTexture.value=o}get parametricRimColorFactor(){return this.uniforms.parametricRimColorFactor.value}set parametricRimColorFactor(o){this.uniforms.parametricRimColorFactor.value=o}get rimMultiplyTexture(){return this.uniforms.rimMultiplyTexture.value}set rimMultiplyTexture(o){this.uniforms.rimMultiplyTexture.value=o}get rimLightingMixFactor(){return this.uniforms.rimLightingMixFactor.value}set rimLightingMixFactor(o){this.uniforms.rimLightingMixFactor.value=o}get parametricRimFresnelPowerFactor(){return this.uniforms.parametricRimFresnelPowerFactor.value}set parametricRimFresnelPowerFactor(o){this.uniforms.parametricRimFresnelPowerFactor.value=o}get parametricRimLiftFactor(){return this.uniforms.parametricRimLiftFactor.value}set parametricRimLiftFactor(o){this.uniforms.parametricRimLiftFactor.value=o}get outlineWidthMultiplyTexture(){return this.uniforms.outlineWidthMultiplyTexture.value}set outlineWidthMultiplyTexture(o){this.uniforms.outlineWidthMultiplyTexture.value=o}get outlineWidthFactor(){return this.uniforms.outlineWidthFactor.value}set outlineWidthFactor(o){this.uniforms.outlineWidthFactor.value=o}get outlineColorFactor(){return this.uniforms.outlineColorFactor.value}set outlineColorFactor(o){this.uniforms.outlineColorFactor.value=o}get outlineLightingMixFactor(){return this.uniforms.outlineLightingMixFactor.value}set outlineLightingMixFactor(o){this.uniforms.outlineLightingMixFactor.value=o}get uvAnimationMaskTexture(){return this.uniforms.uvAnimationMaskTexture.value}set uvAnimationMaskTexture(o){this.uniforms.uvAnimationMaskTexture.value=o}get uvAnimationScrollXOffset(){return this.uniforms.uvAnimationScrollXOffset.value}set uvAnimationScrollXOffset(o){this.uniforms.uvAnimationScrollXOffset.value=o}get uvAnimationScrollYOffset(){return this.uniforms.uvAnimationScrollYOffset.value}set uvAnimationScrollYOffset(o){this.uniforms.uvAnimationScrollYOffset.value=o}get uvAnimationRotationPhase(){return this.uniforms.uvAnimationRotationPhase.value}set uvAnimationRotationPhase(o){this.uniforms.uvAnimationRotationPhase.value=o}get ignoreVertexColor(){return this._ignoreVertexColor}set ignoreVertexColor(o){this._ignoreVertexColor=o,this.needsUpdate=!0}get v0CompatShade(){return this._v0CompatShade}set v0CompatShade(o){this._v0CompatShade=o,this.needsUpdate=!0}get debugMode(){return this._debugMode}set debugMode(o){this._debugMode=o,this.needsUpdate=!0}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(o){this._outlineWidthMode=o,this.needsUpdate=!0}get isOutline(){return this._isOutline}set isOutline(o){this._isOutline=o,this.needsUpdate=!0}get isMToonMaterial(){return!0}update(o){this._uploadUniformsWorkaround(),this._updateUVAnimation(o)}copy(o){return super.copy(o),this.map=o.map,this.normalMap=o.normalMap,this.emissiveMap=o.emissiveMap,this.shadeMultiplyTexture=o.shadeMultiplyTexture,this.shadingShiftTexture=o.shadingShiftTexture,this.matcapTexture=o.matcapTexture,this.rimMultiplyTexture=o.rimMultiplyTexture,this.outlineWidthMultiplyTexture=o.outlineWidthMultiplyTexture,this.uvAnimationMaskTexture=o.uvAnimationMaskTexture,this.normalMapType=o.normalMapType,this.uvAnimationScrollXSpeedFactor=o.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=o.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=o.uvAnimationRotationSpeedFactor,this.ignoreVertexColor=o.ignoreVertexColor,this.v0CompatShade=o.v0CompatShade,this.debugMode=o.debugMode,this.outlineWidthMode=o.outlineWidthMode,this.isOutline=o.isOutline,this.needsUpdate=!0,this}_updateUVAnimation(o){this.uniforms.uvAnimationScrollXOffset.value+=o*this.uvAnimationScrollXSpeedFactor,this.uniforms.uvAnimationScrollYOffset.value+=o*this.uvAnimationScrollYSpeedFactor,this.uniforms.uvAnimationRotationPhase.value+=o*this.uvAnimationRotationSpeedFactor,this.uniforms.alphaTest.value=this.alphaTest,this.uniformsNeedUpdate=!0}_uploadUniformsWorkaround(){this.uniforms.opacity.value=this.opacity,this._updateTextureMatrix(this.uniforms.map,this.uniforms.mapUvTransform),this._updateTextureMatrix(this.uniforms.normalMap,this.uniforms.normalMapUvTransform),this._updateTextureMatrix(this.uniforms.emissiveMap,this.uniforms.emissiveMapUvTransform),this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture,this.uniforms.shadeMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.shadingShiftTexture,this.uniforms.shadingShiftTextureUvTransform),this._updateTextureMatrix(this.uniforms.matcapTexture,this.uniforms.matcapTextureUvTransform),this._updateTextureMatrix(this.uniforms.rimMultiplyTexture,this.uniforms.rimMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture,this.uniforms.outlineWidthMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture,this.uniforms.uvAnimationMaskTextureUvTransform),this.uniformsNeedUpdate=!0}_generateDefines(){const o=parseInt(Ni,10),t=this.outlineWidthMultiplyTexture!==null,e=this.map!==null||this.normalMap!==null||this.emissiveMap!==null||this.shadeMultiplyTexture!==null||this.shadingShiftTexture!==null||this.rimMultiplyTexture!==null||this.uvAnimationMaskTexture!==null;return{THREE_VRM_THREE_REVISION:o,OUTLINE:this._isOutline,MTOON_USE_UV:t||e,MTOON_UVS_VERTEX_ONLY:t&&!e,V0_COMPAT_SHADE:this._v0CompatShade,USE_SHADEMULTIPLYTEXTURE:this.shadeMultiplyTexture!==null,USE_SHADINGSHIFTTEXTURE:this.shadingShiftTexture!==null,USE_MATCAPTEXTURE:this.matcapTexture!==null,USE_RIMMULTIPLYTEXTURE:this.rimMultiplyTexture!==null,USE_OUTLINEWIDTHMULTIPLYTEXTURE:this._isOutline&&this.outlineWidthMultiplyTexture!==null,USE_UVANIMATIONMASKTEXTURE:this.uvAnimationMaskTexture!==null,IGNORE_VERTEX_COLOR:this._ignoreVertexColor===!0,DEBUG_NORMAL:this._debugMode==="normal",DEBUG_LITSHADERATE:this._debugMode==="litShadeRate",DEBUG_UV:this._debugMode==="uv",OUTLINE_WIDTH_SCREEN:this._isOutline&&this._outlineWidthMode===wx.ScreenCoordinates}}_updateTextureMatrix(o,t){o.value&&(o.value.matrixAutoUpdate&&o.value.updateMatrix(),t.value.copy(o.value.matrix))}},iL=new Set(["1.0","1.0-beta"]),gT=class ih{get name(){return ih.EXTENSION_NAME}constructor(t,e={}){var i,s,n,r;this.parser=t,this.materialType=(i=e.materialType)!=null?i:eL,this.renderOrderOffset=(s=e.renderOrderOffset)!=null?s:0,this.v0CompatShade=(n=e.v0CompatShade)!=null?n:!1,this.debugMode=(r=e.debugMode)!=null?r:"none",this._mToonMaterialSet=new Set}beforeRoot(){return gn(this,null,function*(){this._removeUnlitExtensionIfMToonExists()})}afterRoot(t){return gn(this,null,function*(){t.userData.vrmMToonMaterials=Array.from(this._mToonMaterialSet)})}getMaterialType(t){return this._getMToonExtension(t)?this.materialType:null}extendMaterialParams(t,e){const i=this._getMToonExtension(t);return i?this._extendMaterialParams(i,e):null}loadMesh(t){return gn(this,null,function*(){var e;const i=this.parser,n=(e=i.json.meshes)==null?void 0:e[t];if(n==null)throw new Error(`MToonMaterialLoaderPlugin: Attempt to use meshes[${t}] of glTF but the mesh doesn't exist`);const r=n.primitives,a=yield i.loadMesh(t);if(r.length===1){const l=a,h=r[0].material;h!=null&&this._setupPrimitive(l,h)}else{const l=a;for(let h=0;h<r.length;h++){const u=l.children[h],c=r[h].material;c!=null&&this._setupPrimitive(u,c)}}return a})}_removeUnlitExtensionIfMToonExists(){const i=this.parser.json.materials;i?.map((s,n)=>{var r;this._getMToonExtension(n)&&((r=s.extensions)!=null&&r.KHR_materials_unlit)&&delete s.extensions.KHR_materials_unlit})}_getMToonExtension(t){var e,i;const r=(e=this.parser.json.materials)==null?void 0:e[t];if(r==null){console.warn(`MToonMaterialLoaderPlugin: Attempt to use materials[${t}] of glTF but the material doesn't exist`);return}const a=(i=r.extensions)==null?void 0:i[ih.EXTENSION_NAME];if(a==null)return;const l=a.specVersion;if(!iL.has(l)){console.warn(`MToonMaterialLoaderPlugin: Unknown ${ih.EXTENSION_NAME} specVersion "${l}"`);return}return a}_extendMaterialParams(t,e){return gn(this,null,function*(){var i;delete e.metalness,delete e.roughness;const s=new Z2(this.parser,e);s.assignPrimitive("transparentWithZWrite",t.transparentWithZWrite),s.assignColor("shadeColorFactor",t.shadeColorFactor),s.assignTexture("shadeMultiplyTexture",t.shadeMultiplyTexture,!0),s.assignPrimitive("shadingShiftFactor",t.shadingShiftFactor),s.assignTexture("shadingShiftTexture",t.shadingShiftTexture,!0),s.assignPrimitive("shadingShiftTextureScale",(i=t.shadingShiftTexture)==null?void 0:i.scale),s.assignPrimitive("shadingToonyFactor",t.shadingToonyFactor),s.assignPrimitive("giEqualizationFactor",t.giEqualizationFactor),s.assignColor("matcapFactor",t.matcapFactor),s.assignTexture("matcapTexture",t.matcapTexture,!0),s.assignColor("parametricRimColorFactor",t.parametricRimColorFactor),s.assignTexture("rimMultiplyTexture",t.rimMultiplyTexture,!0),s.assignPrimitive("rimLightingMixFactor",t.rimLightingMixFactor),s.assignPrimitive("parametricRimFresnelPowerFactor",t.parametricRimFresnelPowerFactor),s.assignPrimitive("parametricRimLiftFactor",t.parametricRimLiftFactor),s.assignPrimitive("outlineWidthMode",t.outlineWidthMode),s.assignPrimitive("outlineWidthFactor",t.outlineWidthFactor),s.assignTexture("outlineWidthMultiplyTexture",t.outlineWidthMultiplyTexture,!1),s.assignColor("outlineColorFactor",t.outlineColorFactor),s.assignPrimitive("outlineLightingMixFactor",t.outlineLightingMixFactor),s.assignTexture("uvAnimationMaskTexture",t.uvAnimationMaskTexture,!1),s.assignPrimitive("uvAnimationScrollXSpeedFactor",t.uvAnimationScrollXSpeedFactor),s.assignPrimitive("uvAnimationScrollYSpeedFactor",t.uvAnimationScrollYSpeedFactor),s.assignPrimitive("uvAnimationRotationSpeedFactor",t.uvAnimationRotationSpeedFactor),s.assignPrimitive("v0CompatShade",this.v0CompatShade),s.assignPrimitive("debugMode",this.debugMode),yield s.pending})}_setupPrimitive(t,e){const i=this._getMToonExtension(e);if(i){const s=this._parseRenderOrder(i);t.renderOrder=s+this.renderOrderOffset,this._generateOutline(t),this._addToMaterialSet(t);return}}_shouldGenerateOutline(t){return typeof t.outlineWidthMode=="string"&&t.outlineWidthMode!=="none"&&typeof t.outlineWidthFactor=="number"&&t.outlineWidthFactor>0}_generateOutline(t){const e=t.material;if(!(e instanceof fs)||!this._shouldGenerateOutline(e))return;t.material=[e];const i=e.clone();i.name+=" (Outline)",i.isOutline=!0,i.side=yp,t.material.push(i);const s=t.geometry,n=s.index?s.index.count:s.attributes.position.count/3;s.addGroup(0,n,0),s.addGroup(0,n,1)}_addToMaterialSet(t){const e=t.material,i=new Set;Array.isArray(e)?e.forEach(s=>i.add(s)):i.add(e);for(const s of i)this._mToonMaterialSet.add(s)}_parseRenderOrder(t){var e;return(t.transparentWithZWrite?0:19)+((e=t.renderQueueOffsetNumber)!=null?e:0)}};gT.EXTENSION_NAME="VRMC_materials_mtoon";var sL=gT,nL=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),yT=class mp{get name(){return mp.EXTENSION_NAME}constructor(t){this.parser=t}extendMaterialParams(t,e){return nL(this,null,function*(){const i=this._getHDREmissiveMultiplierExtension(t);if(i==null)return;console.warn("VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead.");const s=i.emissiveMultiplier;e.emissiveIntensity=s})}_getHDREmissiveMultiplierExtension(t){var e,i;const r=(e=this.parser.json.materials)==null?void 0:e[t];if(r==null){console.warn(`VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${t}] of glTF but the material doesn't exist`);return}const a=(i=r.extensions)==null?void 0:i[mp.EXTENSION_NAME];if(a!=null)return a}};yT.EXTENSION_NAME="VRMC_materials_hdr_emissiveMultiplier";var rL=yT,oL=Object.defineProperty,aL=Object.defineProperties,lL=Object.getOwnPropertyDescriptors,Ax=Object.getOwnPropertySymbols,hL=Object.prototype.hasOwnProperty,uL=Object.prototype.propertyIsEnumerable,Nx=(o,t,e)=>t in o?oL(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,Ei=(o,t)=>{for(var e in t||(t={}))hL.call(t,e)&&Nx(o,e,t[e]);if(Ax)for(var e of Ax(t))uL.call(t,e)&&Nx(o,e,t[e]);return o},Rx=(o,t)=>aL(o,lL(t)),cL=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())});function gr(o){return Math.pow(o,2.2)}var dL=class{get name(){return"VRMMaterialsV0CompatPlugin"}constructor(o){var t;this.parser=o,this._renderQueueMapTransparent=new Map,this._renderQueueMapTransparentZWrite=new Map;const e=this.parser.json;e.extensionsUsed=(t=e.extensionsUsed)!=null?t:[],e.extensionsUsed.indexOf("KHR_texture_transform")===-1&&e.extensionsUsed.push("KHR_texture_transform")}beforeRoot(){return cL(this,null,function*(){var o;const t=this.parser.json,e=(o=t.extensions)==null?void 0:o.VRM,i=e?.materialProperties;i&&(this._populateRenderQueueMap(i),i.forEach((s,n)=>{var r,a;const l=(r=t.materials)==null?void 0:r[n];if(l==null){console.warn(`VRMMaterialsV0CompatPlugin: Attempt to use materials[${n}] of glTF but the material doesn't exist`);return}if(s.shader==="VRM/MToon"){const h=this._parseV0MToonProperties(s,l);t.materials[n]=h}else if((a=s.shader)!=null&&a.startsWith("VRM/Unlit")){const h=this._parseV0UnlitProperties(s,l);t.materials[n]=h}else s.shader==="VRM_USE_GLTFSHADER"||console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${s.shader}`)}))})}_parseV0MToonProperties(o,t){var e,i,s,n,r,a,l,h,u,c,d,p,f,m,g,y,x,M,_,v,A,T,w,U,D,V,W,$,at,J,At,St,Pt,dt,tt,Rt,qt,fe,ti,ie,ui,ci,uo,qs,ys,Sf,wf,Af,Nf,Rf,Ef,Cf,Pf,Ff,If;const Bf=(i=(e=o.keywordMap)==null?void 0:e._ALPHABLEND_ON)!=null?i:!1,wT=((s=o.floatProperties)==null?void 0:s._ZWrite)===1&&Bf,AT=this._v0ParseRenderQueue(o),Lf=(r=(n=o.keywordMap)==null?void 0:n._ALPHATEST_ON)!=null?r:!1,NT=Bf?"BLEND":Lf?"MASK":"OPAQUE",RT=Lf?(l=(a=o.floatProperties)==null?void 0:a._Cutoff)!=null?l:.5:void 0,ET=((u=(h=o.floatProperties)==null?void 0:h._CullMode)!=null?u:2)===0,js=this._portTextureTransform(o),CT=((d=(c=o.vectorProperties)==null?void 0:c._Color)!=null?d:[1,1,1,1]).map((Hf,tb)=>tb===3?Hf:gr(Hf)),Uf=(p=o.textureProperties)==null?void 0:p._MainTex,PT=Uf!=null?{index:Uf,extensions:Ei({},js)}:void 0,FT=(m=(f=o.floatProperties)==null?void 0:f._BumpScale)!=null?m:1,Df=(g=o.textureProperties)==null?void 0:g._BumpMap,IT=Df!=null?{index:Df,scale:FT,extensions:Ei({},js)}:void 0,BT=((x=(y=o.vectorProperties)==null?void 0:y._EmissionColor)!=null?x:[0,0,0,1]).map(gr),Of=(M=o.textureProperties)==null?void 0:M._EmissionMap,LT=Of!=null?{index:Of,extensions:Ei({},js)}:void 0,UT=((v=(_=o.vectorProperties)==null?void 0:_._ShadeColor)!=null?v:[.97,.81,.86,1]).map(gr),zf=(A=o.textureProperties)==null?void 0:A._ShadeTexture,DT=zf!=null?{index:zf,extensions:Ei({},js)}:void 0;let Aa=(w=(T=o.floatProperties)==null?void 0:T._ShadeShift)!=null?w:0,Na=(D=(U=o.floatProperties)==null?void 0:U._ShadeToony)!=null?D:.9;Na=zt.lerp(Na,1,.5+.5*Aa),Aa=-Aa-(1-Na);const Vf=(W=(V=o.floatProperties)==null?void 0:V._IndirectLightIntensity)!=null?W:.1,OT=Vf?1-Vf:void 0,uu=($=o.textureProperties)==null?void 0:$._SphereAdd,zT=uu!=null?[1,1,1]:void 0,VT=uu!=null?{index:uu}:void 0,kT=(J=(at=o.floatProperties)==null?void 0:at._RimLightingMix)!=null?J:0,kf=(At=o.textureProperties)==null?void 0:At._RimTexture,GT=kf!=null?{index:kf,extensions:Ei({},js)}:void 0,WT=((Pt=(St=o.vectorProperties)==null?void 0:St._RimColor)!=null?Pt:[0,0,0,1]).map(gr),HT=(tt=(dt=o.floatProperties)==null?void 0:dt._RimFresnelPower)!=null?tt:1,$T=(qt=(Rt=o.floatProperties)==null?void 0:Rt._RimLift)!=null?qt:0,qT=["none","worldCoordinates","screenCoordinates"][(ti=(fe=o.floatProperties)==null?void 0:fe._OutlineWidthMode)!=null?ti:0];let cu=(ui=(ie=o.floatProperties)==null?void 0:ie._OutlineWidth)!=null?ui:0;cu=.01*cu;const Gf=(ci=o.textureProperties)==null?void 0:ci._OutlineWidthTexture,jT=Gf!=null?{index:Gf,extensions:Ei({},js)}:void 0,XT=((qs=(uo=o.vectorProperties)==null?void 0:uo._OutlineColor)!=null?qs:[0,0,0]).map(gr),YT=((Sf=(ys=o.floatProperties)==null?void 0:ys._OutlineColorMode)!=null?Sf:0)===1?(Af=(wf=o.floatProperties)==null?void 0:wf._OutlineLightingMix)!=null?Af:1:0,Wf=(Nf=o.textureProperties)==null?void 0:Nf._UvAnimMaskTexture,ZT=Wf!=null?{index:Wf,extensions:Ei({},js)}:void 0,QT=(Ef=(Rf=o.floatProperties)==null?void 0:Rf._UvAnimScrollX)!=null?Ef:0;let Ra=(Pf=(Cf=o.floatProperties)==null?void 0:Cf._UvAnimScrollY)!=null?Pf:0;Ra!=null&&(Ra=-Ra);const JT=(If=(Ff=o.floatProperties)==null?void 0:Ff._UvAnimRotation)!=null?If:0,KT={specVersion:"1.0",transparentWithZWrite:wT,renderQueueOffsetNumber:AT,shadeColorFactor:UT,shadeMultiplyTexture:DT,shadingShiftFactor:Aa,shadingToonyFactor:Na,giEqualizationFactor:OT,matcapFactor:zT,matcapTexture:VT,rimLightingMixFactor:kT,rimMultiplyTexture:GT,parametricRimColorFactor:WT,parametricRimFresnelPowerFactor:HT,parametricRimLiftFactor:$T,outlineWidthMode:qT,outlineWidthFactor:cu,outlineWidthMultiplyTexture:jT,outlineColorFactor:XT,outlineLightingMixFactor:YT,uvAnimationMaskTexture:ZT,uvAnimationScrollXSpeedFactor:QT,uvAnimationScrollYSpeedFactor:Ra,uvAnimationRotationSpeedFactor:JT};return Rx(Ei({},t),{pbrMetallicRoughness:{baseColorFactor:CT,baseColorTexture:PT},normalTexture:IT,emissiveTexture:LT,emissiveFactor:BT,alphaMode:NT,alphaCutoff:RT,doubleSided:ET,extensions:{VRMC_materials_mtoon:KT}})}_parseV0UnlitProperties(o,t){var e,i,s,n,r;const a=o.shader==="VRM/UnlitTransparentZWrite",l=o.shader==="VRM/UnlitTransparent"||a,h=this._v0ParseRenderQueue(o),u=o.shader==="VRM/UnlitCutout",c=l?"BLEND":u?"MASK":"OPAQUE",d=u?(i=(e=o.floatProperties)==null?void 0:e._Cutoff)!=null?i:.5:void 0,p=this._portTextureTransform(o),f=((n=(s=o.vectorProperties)==null?void 0:s._Color)!=null?n:[1,1,1,1]).map(gr),m=(r=o.textureProperties)==null?void 0:r._MainTex,g=m!=null?{index:m,extensions:Ei({},p)}:void 0,y={specVersion:"1.0",transparentWithZWrite:a,renderQueueOffsetNumber:h,shadeColorFactor:f,shadeMultiplyTexture:g};return Rx(Ei({},t),{pbrMetallicRoughness:{baseColorFactor:f,baseColorTexture:g},alphaMode:c,alphaCutoff:d,extensions:{VRMC_materials_mtoon:y}})}_portTextureTransform(o){var t,e,i,s,n;const r=(t=o.vectorProperties)==null?void 0:t._MainTex;if(r==null)return{};const a=[(e=r?.[0])!=null?e:0,(i=r?.[1])!=null?i:0],l=[(s=r?.[2])!=null?s:1,(n=r?.[3])!=null?n:1];return a[1]=1-l[1]-a[1],{KHR_texture_transform:{offset:a,scale:l}}}_v0ParseRenderQueue(o){var t,e;const i=o.shader==="VRM/UnlitTransparentZWrite",s=((t=o.keywordMap)==null?void 0:t._ALPHABLEND_ON)!=null||o.shader==="VRM/UnlitTransparent"||i,n=((e=o.floatProperties)==null?void 0:e._ZWrite)===1||i;let r=0;if(s){const a=o.renderQueue;a!=null&&(n?r=this._renderQueueMapTransparentZWrite.get(a):r=this._renderQueueMapTransparent.get(a))}return r}_populateRenderQueueMap(o){const t=new Set,e=new Set;o.forEach(i=>{var s,n;const r=i.shader==="VRM/UnlitTransparentZWrite",a=((s=i.keywordMap)==null?void 0:s._ALPHABLEND_ON)!=null||i.shader==="VRM/UnlitTransparent"||r,l=((n=i.floatProperties)==null?void 0:n._ZWrite)===1||r;if(a){const h=i.renderQueue;h!=null&&(l?e.add(h):t.add(h))}}),t.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${t.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),e.size>10&&console.warn(`VRMMaterialsV0CompatPlugin: This VRM uses ${e.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`),Array.from(t).sort().forEach((i,s)=>{const n=Math.min(Math.max(s-t.size+1,-9),0);this._renderQueueMapTransparent.set(i,n)}),Array.from(e).sort().forEach((i,s)=>{const n=Math.min(Math.max(s,0),9);this._renderQueueMapTransparentZWrite.set(i,n)})}},Ex=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),Ps=new S,Yc=class extends Jr{constructor(o){super(),this._attrPosition=new It(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(lb);const t=new Ke;t.setAttribute("position",this._attrPosition);const e=new Kr({color:16711935,depthTest:!1,depthWrite:!1});this._line=new bp(t,e),this.add(this._line),this.constraint=o}updateMatrixWorld(o){Ps.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,Ps.x,Ps.y,Ps.z),this.constraint.source&&Ps.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,Ps.x,Ps.y,Ps.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(o)}};function Cx(o,t){return t.set(o.elements[12],o.elements[13],o.elements[14])}var pL=new S,fL=new S;function mL(o,t){return o.decompose(pL,t,fL),t}function Lh(o){return o.invert?o.invert():o.inverse(),o}var Tf=class{constructor(o,t){this.destination=o,this.source=t,this.weight=1}},gL=new S,yL=new S,xL=new S,_L=new rt,ML=new rt,vL=new rt,TL=class extends Tf{get aimAxis(){return this._aimAxis}set aimAxis(o){this._aimAxis=o,this._v3AimAxis.set(o==="PositiveX"?1:o==="NegativeX"?-1:0,o==="PositiveY"?1:o==="NegativeY"?-1:0,o==="PositiveZ"?1:o==="NegativeZ"?-1:0)}get dependencies(){const o=new Set([this.source]);return this.destination.parent&&o.add(this.destination.parent),o}constructor(o,t){super(o,t),this._aimAxis="PositiveX",this._v3AimAxis=new S(1,0,0),this._dstRestQuat=new rt}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);const o=_L.identity(),t=ML.identity();this.destination.parent&&(mL(this.destination.parent.matrixWorld,o),Lh(t.copy(o)));const e=gL.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(o),i=Cx(this.source.matrixWorld,yL).sub(Cx(this.destination.matrixWorld,xL)).normalize(),s=vL.setFromUnitVectors(e,i).premultiply(t).multiply(o).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(s,this.weight)}};function bL(o,t){const e=[o];let i=o.parent;for(;i!==null;)e.unshift(i),i=i.parent;e.forEach(s=>{t(s)})}var SL=class{constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}get constraints(){return this._constraints}addConstraint(o){this._constraints.add(o);let t=this._objectConstraintsMap.get(o.destination);t==null&&(t=new Set,this._objectConstraintsMap.set(o.destination,t)),t.add(o)}deleteConstraint(o){this._constraints.delete(o),this._objectConstraintsMap.get(o.destination).delete(o)}setInitState(){const o=new Set,t=new Set;for(const e of this._constraints)this._processConstraint(e,o,t,i=>i.setInitState())}update(){const o=new Set,t=new Set;for(const e of this._constraints)this._processConstraint(e,o,t,i=>i.update())}_processConstraint(o,t,e,i){if(e.has(o))return;if(t.has(o))throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");t.add(o);const s=o.dependencies;for(const n of s)bL(n,r=>{const a=this._objectConstraintsMap.get(r);if(a)for(const l of a)this._processConstraint(l,t,e,i)});i(o),e.add(o)}},wL=new rt,AL=new rt,NL=class extends Tf{get dependencies(){return new Set([this.source])}constructor(o,t){super(o,t),this._dstRestQuat=new rt,this._invSrcRestQuat=new rt}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),Lh(this._invSrcRestQuat.copy(this.source.quaternion))}update(){const o=wL.copy(this._invSrcRestQuat).multiply(this.source.quaternion),t=AL.copy(this._dstRestQuat).multiply(o);this.destination.quaternion.copy(this._dstRestQuat).slerp(t,this.weight)}},RL=new S,EL=new rt,CL=new rt,PL=class extends Tf{get rollAxis(){return this._rollAxis}set rollAxis(o){this._rollAxis=o,this._v3RollAxis.set(o==="X"?1:0,o==="Y"?1:0,o==="Z"?1:0)}get dependencies(){return new Set([this.source])}constructor(o,t){super(o,t),this._rollAxis="X",this._v3RollAxis=new S(1,0,0),this._dstRestQuat=new rt,this._invDstRestQuat=new rt,this._invSrcRestQuatMulDstRestQuat=new rt}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),Lh(this._invDstRestQuat.copy(this._dstRestQuat)),Lh(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){const o=EL.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),t=RL.copy(this._v3RollAxis).applyQuaternion(o),i=CL.setFromUnitVectors(t,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(o);this.destination.quaternion.copy(this._dstRestQuat).slerp(i,this.weight)}},FL=new Set(["1.0","1.0-beta"]),xT=class Go{get name(){return Go.EXTENSION_NAME}constructor(t,e){this.parser=t,this.helperRoot=e?.helperRoot}afterRoot(t){return Ex(this,null,function*(){t.userData.vrmNodeConstraintManager=yield this._import(t)})}_import(t){return Ex(this,null,function*(){var e;const i=this.parser.json;if(!(((e=i.extensionsUsed)==null?void 0:e.indexOf(Go.EXTENSION_NAME))!==-1))return null;const n=new SL,r=yield this.parser.getDependencies("node");return r.forEach((a,l)=>{var h;const u=i.nodes[l],c=(h=u?.extensions)==null?void 0:h[Go.EXTENSION_NAME];if(c==null)return;const d=c.specVersion;if(!FL.has(d)){console.warn(`VRMNodeConstraintLoaderPlugin: Unknown ${Go.EXTENSION_NAME} specVersion "${d}"`);return}const p=c.constraint;if(p.roll!=null){const f=this._importRollConstraint(a,r,p.roll);n.addConstraint(f)}else if(p.aim!=null){const f=this._importAimConstraint(a,r,p.aim);n.addConstraint(f)}else if(p.rotation!=null){const f=this._importRotationConstraint(a,r,p.rotation);n.addConstraint(f)}}),t.scene.updateMatrixWorld(),n.setInitState(),n})}_importRollConstraint(t,e,i){const{source:s,rollAxis:n,weight:r}=i,a=e[s],l=new PL(t,a);if(n!=null&&(l.rollAxis=n),r!=null&&(l.weight=r),this.helperRoot){const h=new Yc(l);this.helperRoot.add(h)}return l}_importAimConstraint(t,e,i){const{source:s,aimAxis:n,weight:r}=i,a=e[s],l=new TL(t,a);if(n!=null&&(l.aimAxis=n),r!=null&&(l.weight=r),this.helperRoot){const h=new Yc(l);this.helperRoot.add(h)}return l}_importRotationConstraint(t,e,i){const{source:s,weight:n}=i,r=e[s],a=new NL(t,r);if(n!=null&&(a.weight=n),this.helperRoot){const l=new Yc(a);this.helperRoot.add(l)}return a}};xT.EXTENSION_NAME="VRMC_node_constraint";var IL=xT,kl=(o,t,e)=>new Promise((i,s)=>{var n=l=>{try{a(e.next(l))}catch(h){s(h)}},r=l=>{try{a(e.throw(l))}catch(h){s(h)}},a=l=>l.done?i(l.value):Promise.resolve(l.value).then(n,r);a((e=e.apply(o,t)).next())}),bf=class{},Zc=new S,hn=new S,_T=class extends bf{get type(){return"capsule"}constructor(o){var t,e,i,s;super(),this.offset=(t=o?.offset)!=null?t:new S(0,0,0),this.tail=(e=o?.tail)!=null?e:new S(0,0,0),this.radius=(i=o?.radius)!=null?i:0,this.inside=(s=o?.inside)!=null?s:!1}calculateCollision(o,t,e,i){Zc.setFromMatrixPosition(o),hn.subVectors(this.tail,this.offset).applyMatrix4(o),hn.sub(Zc);const s=hn.lengthSq();i.copy(t).sub(Zc);const n=hn.dot(i);n<=0||(s<=n||hn.multiplyScalar(n/s),i.sub(hn));const r=i.length(),a=this.inside?this.radius-e-r:r-e-this.radius;return a<0&&(i.multiplyScalar(1/r),this.inside&&i.negate()),a}},Qc=new S,Px=new yt,MT=class extends bf{get type(){return"plane"}constructor(o){var t,e;super(),this.offset=(t=o?.offset)!=null?t:new S(0,0,0),this.normal=(e=o?.normal)!=null?e:new S(0,0,1)}calculateCollision(o,t,e,i){i.setFromMatrixPosition(o),i.negate().add(t),Px.getNormalMatrix(o),Qc.copy(this.normal).applyNormalMatrix(Px).normalize();const s=i.dot(Qc)-e;return i.copy(Qc),s}},BL=new S,vT=class extends bf{get type(){return"sphere"}constructor(o){var t,e,i;super(),this.offset=(t=o?.offset)!=null?t:new S(0,0,0),this.radius=(e=o?.radius)!=null?e:0,this.inside=(i=o?.inside)!=null?i:!1}calculateCollision(o,t,e,i){i.subVectors(t,BL.setFromMatrixPosition(o));const s=i.length(),n=this.inside?this.radius-e-s:s-e-this.radius;return n<0&&(i.multiplyScalar(1/s),this.inside&&i.negate()),n}},Ci=new S,LL=class extends Ke{constructor(o){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new S,this._currentTail=new S,this._shape=o,this._attrPos=new It(new Float32Array(396),3),this.setAttribute("position",this._attrPos),this._attrIndex=new It(new Uint16Array(264),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let o=!1;const t=this._shape.radius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,o=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),o=!0);const e=Ci.copy(this._shape.tail).divideScalar(this.worldScale);this._currentTail.distanceToSquared(e)>1e-10&&(this._currentTail.copy(e),o=!0),o&&this._buildPosition()}_buildPosition(){Ci.copy(this._currentTail).sub(this._currentOffset);const o=Ci.length()/this._currentRadius;for(let i=0;i<=16;i++){const s=i/16*Math.PI;this._attrPos.setXYZ(i,-Math.sin(s),-Math.cos(s),0),this._attrPos.setXYZ(17+i,o+Math.sin(s),Math.cos(s),0),this._attrPos.setXYZ(34+i,-Math.sin(s),0,-Math.cos(s)),this._attrPos.setXYZ(51+i,o+Math.sin(s),0,Math.cos(s))}for(let i=0;i<32;i++){const s=i/16*Math.PI;this._attrPos.setXYZ(68+i,0,Math.sin(s),Math.cos(s)),this._attrPos.setXYZ(100+i,o,Math.sin(s),Math.cos(s))}const t=Math.atan2(Ci.y,Math.sqrt(Ci.x*Ci.x+Ci.z*Ci.z)),e=-Math.atan2(Ci.z,Ci.x);this.rotateZ(t),this.rotateY(e),this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let o=0;o<34;o++){const t=(o+1)%34;this._attrIndex.setXY(o*2,o,t),this._attrIndex.setXY(68+o*2,34+o,34+t)}for(let o=0;o<32;o++){const t=(o+1)%32;this._attrIndex.setXY(136+o*2,68+o,68+t),this._attrIndex.setXY(200+o*2,100+o,100+t)}this._attrIndex.needsUpdate=!0}},UL=class extends Ke{constructor(o){super(),this.worldScale=1,this._currentOffset=new S,this._currentNormal=new S,this._shape=o,this._attrPos=new It(new Float32Array(6*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new It(new Uint16Array(10),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let o=!1;this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),o=!0),this._currentNormal.equals(this._shape.normal)||(this._currentNormal.copy(this._shape.normal),o=!0),o&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,-.5,-.5,0),this._attrPos.setXYZ(1,.5,-.5,0),this._attrPos.setXYZ(2,.5,.5,0),this._attrPos.setXYZ(3,-.5,.5,0),this._attrPos.setXYZ(4,0,0,0),this._attrPos.setXYZ(5,0,0,.25),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this.lookAt(this._currentNormal),this._attrPos.needsUpdate=!0}_buildIndex(){this._attrIndex.setXY(0,0,1),this._attrIndex.setXY(2,1,2),this._attrIndex.setXY(4,2,3),this._attrIndex.setXY(6,3,0),this._attrIndex.setXY(8,4,5),this._attrIndex.needsUpdate=!0}},DL=class extends Ke{constructor(o){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new S,this._shape=o,this._attrPos=new It(new Float32Array(32*3*3),3),this.setAttribute("position",this._attrPos),this._attrIndex=new It(new Uint16Array(64*3),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let o=!1;const t=this._shape.radius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,o=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),o=!0),o&&this._buildPosition()}_buildPosition(){for(let o=0;o<32;o++){const t=o/16*Math.PI;this._attrPos.setXYZ(o,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+o,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+o,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let o=0;o<32;o++){const t=(o+1)%32;this._attrIndex.setXY(o*2,o,t),this._attrIndex.setXY(64+o*2,32+o,32+t),this._attrIndex.setXY(128+o*2,64+o,64+t)}this._attrIndex.needsUpdate=!0}},OL=new S,Jc=class extends Jr{constructor(o){if(super(),this.matrixAutoUpdate=!1,this.collider=o,this.collider.shape instanceof vT)this._geometry=new DL(this.collider.shape);else if(this.collider.shape instanceof _T)this._geometry=new LL(this.collider.shape);else if(this.collider.shape instanceof MT)this._geometry=new UL(this.collider.shape);else throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");const t=new Kr({color:16711935,depthTest:!1,depthWrite:!1});this._line=new zh(this._geometry,t),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(o){this.collider.updateWorldMatrix(!0,!1),this.matrix.copy(this.collider.matrixWorld);const t=this.matrix.elements;this._geometry.worldScale=OL.set(t[0],t[1],t[2]).length(),this._geometry.update(),super.updateMatrixWorld(o)}},zL=class extends Ke{constructor(o){super(),this.worldScale=1,this._currentRadius=0,this._currentTail=new S,this._springBone=o,this._attrPos=new It(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new It(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}update(){let o=!1;const t=this._springBone.settings.hitRadius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,o=!0),this._currentTail.equals(this._springBone.initialLocalChildPosition)||(this._currentTail.copy(this._springBone.initialLocalChildPosition),o=!0),o&&this._buildPosition()}_buildPosition(){for(let o=0;o<32;o++){const t=o/16*Math.PI;this._attrPos.setXYZ(o,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+o,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+o,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let o=0;o<32;o++){const t=(o+1)%32;this._attrIndex.setXY(o*2,o,t),this._attrIndex.setXY(64+o*2,32+o,32+t),this._attrIndex.setXY(128+o*2,64+o,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}},VL=new S,kL=class extends Jr{constructor(o){super(),this.matrixAutoUpdate=!1,this.springBone=o,this._geometry=new zL(this.springBone);const t=new Kr({color:16776960,depthTest:!1,depthWrite:!1});this._line=new zh(this._geometry,t),this.add(this._line)}dispose(){this._geometry.dispose()}updateMatrixWorld(o){this.springBone.bone.updateWorldMatrix(!0,!1),this.matrix.copy(this.springBone.bone.matrixWorld);const t=this.matrix.elements;this._geometry.worldScale=VL.set(t[0],t[1],t[2]).length(),this._geometry.update(),super.updateMatrixWorld(o)}},Kc=class extends Xt{constructor(o){super(),this.colliderMatrix=new ht,this.shape=o}updateWorldMatrix(o,t){super.updateWorldMatrix(o,t),GL(this.colliderMatrix,this.matrixWorld,this.shape.offset)}};function GL(o,t,e){const i=t.elements;o.copy(t),e&&(o.elements[12]=i[0]*e.x+i[4]*e.y+i[8]*e.z+i[12],o.elements[13]=i[1]*e.x+i[5]*e.y+i[9]*e.z+i[13],o.elements[14]=i[2]*e.x+i[6]*e.y+i[10]*e.z+i[14])}var WL=new ht;function HL(o){return o.invert?o.invert():o.getInverse(WL.copy(o)),o}var $L=class{constructor(o){this._inverseCache=new ht,this._shouldUpdateInverse=!0,this.matrix=o;const t={set:(e,i,s)=>(this._shouldUpdateInverse=!0,e[i]=s,!0)};this._originalElements=o.elements,o.elements=new Proxy(o.elements,t)}get inverse(){return this._shouldUpdateInverse&&(HL(this._inverseCache.copy(this.matrix)),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}},td=new ht,yr=new S,Oo=new S,zo=new S,Vo=new S,qL=new ht,jL=class{constructor(o,t,e={},i=[]){this._currentTail=new S,this._prevTail=new S,this._boneAxis=new S,this._worldSpaceBoneLength=0,this._center=null,this._initialLocalMatrix=new ht,this._initialLocalRotation=new rt,this._initialLocalChildPosition=new S;var s,n,r,a,l,h;this.bone=o,this.bone.matrixAutoUpdate=!1,this.child=t,this.settings={hitRadius:(s=e.hitRadius)!=null?s:0,stiffness:(n=e.stiffness)!=null?n:1,gravityPower:(r=e.gravityPower)!=null?r:0,gravityDir:(l=(a=e.gravityDir)==null?void 0:a.clone())!=null?l:new S(0,-1,0),dragForce:(h=e.dragForce)!=null?h:.4},this.colliderGroups=i}get dependencies(){const o=new Set,t=this.bone.parent;t&&o.add(t);for(let e=0;e<this.colliderGroups.length;e++)for(let i=0;i<this.colliderGroups[e].colliders.length;i++)o.add(this.colliderGroups[e].colliders[i]);return o}get center(){return this._center}set center(o){var t;(t=this._center)!=null&&t.userData.inverseCacheProxy&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=o,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new $L(this._center.matrixWorld)))}get initialLocalChildPosition(){return this._initialLocalChildPosition}get _parentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:td}setInitState(){this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),this.child?this._initialLocalChildPosition.copy(this.child.position):this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);const o=this._getMatrixWorldToCenter();this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(o),this._prevTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix);const o=this._getMatrixWorldToCenter();this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(o),this._prevTail.copy(this._currentTail)}update(o){if(o<=0)return;this._calcWorldSpaceBoneLength();const t=Oo.copy(this._boneAxis).transformDirection(this._initialLocalMatrix).transformDirection(this._parentMatrixWorld);Vo.copy(this._currentTail).add(yr.subVectors(this._currentTail,this._prevTail).multiplyScalar(1-this.settings.dragForce)).applyMatrix4(this._getMatrixCenterToWorld()).addScaledVector(t,this.settings.stiffness*o).addScaledVector(this.settings.gravityDir,this.settings.gravityPower*o),zo.setFromMatrixPosition(this.bone.matrixWorld),Vo.sub(zo).normalize().multiplyScalar(this._worldSpaceBoneLength).add(zo),this._collision(Vo),this._prevTail.copy(this._currentTail),this._currentTail.copy(Vo).applyMatrix4(this._getMatrixWorldToCenter());const e=qL.multiplyMatrices(this._parentMatrixWorld,this._initialLocalMatrix).invert();this.bone.quaternion.setFromUnitVectors(this._boneAxis,yr.copy(Vo).applyMatrix4(e).normalize()).premultiply(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix)}_collision(o){for(let t=0;t<this.colliderGroups.length;t++)for(let e=0;e<this.colliderGroups[t].colliders.length;e++){const i=this.colliderGroups[t].colliders[e],s=i.shape.calculateCollision(i.colliderMatrix,o,this.settings.hitRadius,yr);if(s<0){o.addScaledVector(yr,-s),o.sub(zo);const n=o.length();o.multiplyScalar(this._worldSpaceBoneLength/n).add(zo)}}}_calcWorldSpaceBoneLength(){yr.setFromMatrixPosition(this.bone.matrixWorld),this.child?Oo.setFromMatrixPosition(this.child.matrixWorld):(Oo.copy(this._initialLocalChildPosition),Oo.applyMatrix4(this.bone.matrixWorld)),this._worldSpaceBoneLength=yr.sub(Oo).length()}_getMatrixCenterToWorld(){return this._center?this._center.matrixWorld:td}_getMatrixWorldToCenter(){return this._center?this._center.userData.inverseCacheProxy.inverse:td}};function XL(o,t){const e=[];let i=o;for(;i!==null;)e.unshift(i),i=i.parent;e.forEach(s=>{t(s)})}function gp(o,t){o.children.forEach(e=>{t(e)||gp(e,t)})}function YL(o){var t;const e=new Map;for(const i of o){let s=i;do{const n=((t=e.get(s))!=null?t:0)+1;if(n===o.size)return s;e.set(s,n),s=s.parent}while(s!==null)}return null}var Fx=class{constructor(){this._joints=new Set,this._sortedJoints=[],this._hasWarnedCircularDependency=!1,this._ancestors=[],this._objectSpringBonesMap=new Map,this._isSortedJointsDirty=!1,this._relevantChildrenUpdated=this._relevantChildrenUpdated.bind(this)}get joints(){return this._joints}get springBones(){return console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead."),this._joints}get colliderGroups(){const o=new Set;return this._joints.forEach(t=>{t.colliderGroups.forEach(e=>{o.add(e)})}),Array.from(o)}get colliders(){const o=new Set;return this.colliderGroups.forEach(t=>{t.colliders.forEach(e=>{o.add(e)})}),Array.from(o)}addJoint(o){this._joints.add(o);let t=this._objectSpringBonesMap.get(o.bone);t==null&&(t=new Set,this._objectSpringBonesMap.set(o.bone,t)),t.add(o),this._isSortedJointsDirty=!0}addSpringBone(o){console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead."),this.addJoint(o)}deleteJoint(o){this._joints.delete(o),this._objectSpringBonesMap.get(o.bone).delete(o),this._isSortedJointsDirty=!0}deleteSpringBone(o){console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead."),this.deleteJoint(o)}setInitState(){this._sortJoints();for(let o=0;o<this._sortedJoints.length;o++){const t=this._sortedJoints[o];t.bone.updateMatrix(),t.bone.updateWorldMatrix(!1,!1),t.setInitState()}}reset(){this._sortJoints();for(let o=0;o<this._sortedJoints.length;o++){const t=this._sortedJoints[o];t.bone.updateMatrix(),t.bone.updateWorldMatrix(!1,!1),t.reset()}}update(o){this._sortJoints();for(let t=0;t<this._ancestors.length;t++)this._ancestors[t].updateWorldMatrix(t===0,!1);for(let t=0;t<this._sortedJoints.length;t++){const e=this._sortedJoints[t];e.bone.updateMatrix(),e.bone.updateWorldMatrix(!1,!1),e.update(o),gp(e.bone,this._relevantChildrenUpdated)}}_sortJoints(){if(!this._isSortedJointsDirty)return;const o=[],t=new Set,e=new Set,i=new Set;for(const n of this._joints)this._insertJointSort(n,t,e,o,i);this._sortedJoints=o;const s=YL(i);this._ancestors=[],s&&(this._ancestors.push(s),gp(s,n=>{var r,a;return((a=(r=this._objectSpringBonesMap.get(n))==null?void 0:r.size)!=null?a:0)>0?!0:(this._ancestors.push(n),!1)})),this._isSortedJointsDirty=!1}_insertJointSort(o,t,e,i,s){if(e.has(o))return;if(t.has(o)){this._hasWarnedCircularDependency||(console.warn("VRMSpringBoneManager: Circular dependency detected"),this._hasWarnedCircularDependency=!0);return}t.add(o);const n=o.dependencies;for(const r of n){let a=!1,l=null;XL(r,h=>{const u=this._objectSpringBonesMap.get(h);if(u)for(const c of u)a=!0,this._insertJointSort(c,t,e,i,s);else a||(l=h)}),l&&s.add(l)}i.push(o),e.add(o)}_relevantChildrenUpdated(o){var t,e;return((e=(t=this._objectSpringBonesMap.get(o))==null?void 0:t.size)!=null?e:0)>0?!0:(o.updateWorldMatrix(!1,!1),!1)}},Ix="VRMC_springBone_extended_collider",ZL=new Set(["1.0","1.0-beta"]),QL=new Set(["1.0"]),TT=class vr{get name(){return vr.EXTENSION_NAME}constructor(t,e){var i;this.parser=t,this.jointHelperRoot=e?.jointHelperRoot,this.colliderHelperRoot=e?.colliderHelperRoot,this.useExtendedColliders=(i=e?.useExtendedColliders)!=null?i:!0}afterRoot(t){return kl(this,null,function*(){t.userData.vrmSpringBoneManager=yield this._import(t)})}_import(t){return kl(this,null,function*(){const e=yield this._v1Import(t);if(e!=null)return e;const i=yield this._v0Import(t);return i??null})}_v1Import(t){return kl(this,null,function*(){var e,i,s,n,r;const a=t.parser.json;if(!(((e=a.extensionsUsed)==null?void 0:e.indexOf(vr.EXTENSION_NAME))!==-1))return null;const h=new Fx,u=yield t.parser.getDependencies("node"),c=(i=a.extensions)==null?void 0:i[vr.EXTENSION_NAME];if(!c)return null;const d=c.specVersion;if(!ZL.has(d))return console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${vr.EXTENSION_NAME} specVersion "${d}"`),null;const p=(s=c.colliders)==null?void 0:s.map((m,g)=>{var y,x,M,_,v,A,T,w,U,D,V,W,$,at,J;const At=u[m.node];if(At==null)return console.warn(`VRMSpringBoneLoaderPlugin: The collider #${g} attempted to use the node #${m.node} but not found`),null;const St=m.shape,Pt=(y=m.extensions)==null?void 0:y[Ix];if(this.useExtendedColliders&&Pt!=null){const dt=Pt.specVersion;if(!QL.has(dt))console.warn(`VRMSpringBoneLoaderPlugin: Unknown ${Ix} specVersion "${dt}". Fallbacking to the ${vr.EXTENSION_NAME} definition`);else{const tt=Pt.shape;if(tt.sphere)return this._importSphereCollider(At,{offset:new S().fromArray((x=tt.sphere.offset)!=null?x:[0,0,0]),radius:(M=tt.sphere.radius)!=null?M:0,inside:(_=tt.sphere.inside)!=null?_:!1});if(tt.capsule)return this._importCapsuleCollider(At,{offset:new S().fromArray((v=tt.capsule.offset)!=null?v:[0,0,0]),radius:(A=tt.capsule.radius)!=null?A:0,tail:new S().fromArray((T=tt.capsule.tail)!=null?T:[0,0,0]),inside:(w=tt.capsule.inside)!=null?w:!1});if(tt.plane)return this._importPlaneCollider(At,{offset:new S().fromArray((U=tt.plane.offset)!=null?U:[0,0,0]),normal:new S().fromArray((D=tt.plane.normal)!=null?D:[0,0,1])})}}if(St.sphere)return this._importSphereCollider(At,{offset:new S().fromArray((V=St.sphere.offset)!=null?V:[0,0,0]),radius:(W=St.sphere.radius)!=null?W:0,inside:!1});if(St.capsule)return this._importCapsuleCollider(At,{offset:new S().fromArray(($=St.capsule.offset)!=null?$:[0,0,0]),radius:(at=St.capsule.radius)!=null?at:0,tail:new S().fromArray((J=St.capsule.tail)!=null?J:[0,0,0]),inside:!1});throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${g} has no valid shape`)}),f=(n=c.colliderGroups)==null?void 0:n.map((m,g)=>{var y;return{colliders:((y=m.colliders)!=null?y:[]).flatMap(M=>{const _=p?.[M];return _??(console.warn(`VRMSpringBoneLoaderPlugin: The colliderGroup #${g} attempted to use a collider #${M} but not found`),[])}),name:m.name}});return(r=c.springs)==null||r.forEach((m,g)=>{var y;const x=m.joints,M=(y=m.colliderGroups)==null?void 0:y.map(A=>{const T=f?.[A];if(T==null)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${g} attempted to use a colliderGroup ${A} but not found`);return T}),_=m.center!=null?u[m.center]:void 0;let v;x.forEach(A=>{if(v){const T=v.node,w=u[T],U=A.node,D=u[U],V={hitRadius:v.hitRadius,dragForce:v.dragForce,gravityPower:v.gravityPower,stiffness:v.stiffness,gravityDir:v.gravityDir!=null?new S().fromArray(v.gravityDir):void 0},W=this._importJoint(w,D,V,M);_&&(W.center=_),h.addJoint(W)}v=A})}),h.setInitState(),h})}_v0Import(t){return kl(this,null,function*(){var e,i,s;const n=t.parser.json;if(!(((e=n.extensionsUsed)==null?void 0:e.indexOf("VRM"))!==-1))return null;const a=(i=n.extensions)==null?void 0:i.VRM,l=a?.secondaryAnimation;if(!l)return null;const h=l?.boneGroups;if(!h)return null;const u=new Fx,c=yield t.parser.getDependencies("node"),d=(s=l.colliderGroups)==null?void 0:s.map(p=>{var f;const m=c[p.node];return{colliders:((f=p.colliders)!=null?f:[]).map((y,x)=>{var M,_,v;const A=new S(0,0,0);return y.offset&&A.set((M=y.offset.x)!=null?M:0,(_=y.offset.y)!=null?_:0,y.offset.z?-y.offset.z:0),this._importSphereCollider(m,{offset:A,radius:(v=y.radius)!=null?v:0,inside:!1})})}});return h?.forEach((p,f)=>{const m=p.bones;m&&m.forEach(g=>{var y,x,M,_;const v=c[g],A=new S;p.gravityDir?A.set((y=p.gravityDir.x)!=null?y:0,(x=p.gravityDir.y)!=null?x:0,(M=p.gravityDir.z)!=null?M:0):A.set(0,-1,0);const T=p.center!=null?c[p.center]:void 0,w={hitRadius:p.hitRadius,dragForce:p.dragForce,gravityPower:p.gravityPower,stiffness:p.stiffiness,gravityDir:A},U=(_=p.colliderGroups)==null?void 0:_.map(D=>{const V=d?.[D];if(V==null)throw new Error(`VRMSpringBoneLoaderPlugin: The spring #${f} attempted to use a colliderGroup ${D} but not found`);return V});v.traverse(D=>{var V;const W=(V=D.children[0])!=null?V:null,$=this._importJoint(D,W,w,U);T&&($.center=T),u.addJoint($)})})}),t.scene.updateMatrixWorld(),u.setInitState(),u})}_importJoint(t,e,i,s){const n=new jL(t,e,i,s);if(this.jointHelperRoot){const r=new kL(n);this.jointHelperRoot.add(r),r.renderOrder=this.jointHelperRoot.renderOrder}return n}_importSphereCollider(t,e){const i=new vT(e),s=new Kc(i);if(t.add(s),this.colliderHelperRoot){const n=new Jc(s);this.colliderHelperRoot.add(n),n.renderOrder=this.colliderHelperRoot.renderOrder}return s}_importCapsuleCollider(t,e){const i=new _T(e),s=new Kc(i);if(t.add(s),this.colliderHelperRoot){const n=new Jc(s);this.colliderHelperRoot.add(n),n.renderOrder=this.colliderHelperRoot.renderOrder}return s}_importPlaneCollider(t,e){const i=new MT(e),s=new Kc(i);if(t.add(s),this.colliderHelperRoot){const n=new Jc(s);this.colliderHelperRoot.add(n),n.renderOrder=this.colliderHelperRoot.renderOrder}return s}};TT.EXTENSION_NAME="VRMC_springBone";var JL=TT,iO=class{get name(){return"VRMLoaderPlugin"}constructor(o,t){var e,i,s,n,r,a,l,h,u,c;this.parser=o;const d=t?.helperRoot,p=t?.autoUpdateHumanBones;this.expressionPlugin=(e=t?.expressionPlugin)!=null?e:new m2(o),this.firstPersonPlugin=(i=t?.firstPersonPlugin)!=null?i:new y2(o),this.humanoidPlugin=(s=t?.humanoidPlugin)!=null?s:new S2(o,{helperRoot:d,autoUpdateHumanBones:p}),this.lookAtPlugin=(n=t?.lookAtPlugin)!=null?n:new z2(o,{helperRoot:d}),this.metaPlugin=(r=t?.metaPlugin)!=null?r:new G2(o),this.mtoonMaterialPlugin=(a=t?.mtoonMaterialPlugin)!=null?a:new sL(o),this.materialsHDREmissiveMultiplierPlugin=(l=t?.materialsHDREmissiveMultiplierPlugin)!=null?l:new rL(o),this.materialsV0CompatPlugin=(h=t?.materialsV0CompatPlugin)!=null?h:new dL(o),this.springBonePlugin=(u=t?.springBonePlugin)!=null?u:new JL(o,{colliderHelperRoot:d,jointHelperRoot:d}),this.nodeConstraintPlugin=(c=t?.nodeConstraintPlugin)!=null?c:new IL(o,{helperRoot:d})}beforeRoot(){return Ol(this,null,function*(){yield this.materialsV0CompatPlugin.beforeRoot(),yield this.mtoonMaterialPlugin.beforeRoot()})}loadMesh(o){return Ol(this,null,function*(){return yield this.mtoonMaterialPlugin.loadMesh(o)})}getMaterialType(o){const t=this.mtoonMaterialPlugin.getMaterialType(o);return t??null}extendMaterialParams(o,t){return Ol(this,null,function*(){yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(o,t),yield this.mtoonMaterialPlugin.extendMaterialParams(o,t)})}afterRoot(o){return Ol(this,null,function*(){yield this.metaPlugin.afterRoot(o),yield this.humanoidPlugin.afterRoot(o),yield this.expressionPlugin.afterRoot(o),yield this.lookAtPlugin.afterRoot(o),yield this.firstPersonPlugin.afterRoot(o),yield this.springBonePlugin.afterRoot(o),yield this.nodeConstraintPlugin.afterRoot(o),yield this.mtoonMaterialPlugin.afterRoot(o);const t=o.userData.vrmMeta,e=o.userData.vrmHumanoid;if(t&&e){const i=new H2({scene:o.scene,expressionManager:o.userData.vrmExpressionManager,firstPerson:o.userData.vrmFirstPerson,humanoid:e,lookAt:o.userData.vrmLookAt,meta:t,materials:o.userData.vrmMToonMaterials,springBoneManager:o.userData.vrmSpringBoneManager,nodeConstraintManager:o.userData.vrmNodeConstraintManager});o.userData.vrm=i}})}};function KL(o){const t=new Set;return o.traverse(e=>{if(!e.isMesh)return;const i=e;t.add(i)}),t}function Bx(o,t,e){if(t.size===1){const r=t.values().next().value;if(r.weight===1)return o[r.index]}const i=new Float32Array(o[0].count*3);let s=0;if(e)s=1;else for(const r of t)s+=r.weight;for(const r of t){const a=o[r.index],l=r.weight/s;for(let h=0;h<a.count;h++)i[h*3+0]+=a.getX(h)*l,i[h*3+1]+=a.getY(h)*l,i[h*3+2]+=a.getZ(h)*l}return new It(i,3)}function tU(o){var t;const e=KL(o.scene),i=new Map,s=(t=o.expressionManager)==null?void 0:t.expressionMap;if(s!=null)for(const[n,r]of Object.entries(s)){const a=new Set;for(const l of r.binds)if(l instanceof Bh){if(l.weight!==0)for(const h of l.primitives){let u=i.get(h);u==null&&(u=new Map,i.set(h,u));let c=u.get(n);c==null&&(c=new Set,u.set(n,c)),c.add(l)}a.add(l)}for(const l of a)r.deleteBind(l)}for(const n of e){const r=i.get(n);if(r==null)continue;const a=n.geometry.morphAttributes;n.geometry.morphAttributes={};const l=n.geometry.clone();n.geometry=l;const h=l.morphTargetsRelative,u=a.position!=null,c=a.normal!=null,d={},p={},f=[];if(u||c){u&&(d.position=[]),c&&(d.normal=[]);let m=0;for(const[g,y]of r)u&&(d.position[m]=Bx(a.position,y,h)),c&&(d.normal[m]=Bx(a.normal,y,h)),s?.[g].addBind(new Bh({index:m,weight:1,primitives:[n]})),p[g]=m,f.push(0),m++}l.morphAttributes=d,n.morphTargetDictionary=p,n.morphTargetInfluences=f}}function Uh(o,t,e){if(o.getComponent)return o.getComponent(t,e);{let i=o.array[t*o.itemSize+e];return o.normalized&&(i=zt.denormalize(i,o.array)),i}}function bT(o,t,e,i){o.setComponent?o.setComponent(t,e,i):(o.normalized&&(i=zt.normalize(i,o.array)),o.array[t*o.itemSize+e]=i)}function eU(o){var t;const e=iU(o),i=new Set;for(const c of e)i.has(c.geometry)&&(c.geometry=lU(c.geometry)),i.add(c.geometry);const s=new Map;for(const c of i){const d=c.getAttribute("skinIndex"),p=(t=s.get(d))!=null?t:new Map;s.set(d,p);const f=c.getAttribute("skinWeight"),m=sU(d,f);p.set(f,m)}const n=new Map;for(const c of e){const d=nU(c,s);n.set(c,d)}const r=[];for(const[c,d]of n){let p=!1;for(const f of r)if(rU(d,f.boneInverseMap)){p=!0,f.meshes.add(c);for(const[g,y]of d)f.boneInverseMap.set(g,y);break}p||r.push({boneInverseMap:d,meshes:new Set([c])})}const a=new Map,l=new ed,h=new ed,u=new ed;for(const c of r){const{boneInverseMap:d,meshes:p}=c,f=Array.from(d.keys()),m=Array.from(d.values()),g=new pa(f,m),y=h.getOrCreate(g);for(const x of p){const M=x.geometry.getAttribute("skinIndex"),_=l.getOrCreate(M),v=x.skeleton.bones,A=v.map(U=>u.getOrCreate(U)).join(","),T=`${_};${y};${A}`;let w=a.get(T);w==null&&(w=M.clone(),oU(w,v,f),a.set(T,w)),x.geometry.setAttribute("skinIndex",w)}for(const x of p)x.bind(g,new ht)}}function iU(o){const t=new Set;return o.traverse(e=>{if(!e.isSkinnedMesh)return;const i=e;t.add(i)}),t}function sU(o,t){const e=new Set;for(let i=0;i<o.count;i++)for(let s=0;s<o.itemSize;s++){const n=Uh(o,i,s);Uh(t,i,s)!==0&&e.add(n)}return e}function nU(o,t){const e=new Map,i=o.skeleton,s=o.geometry,n=s.getAttribute("skinIndex"),r=s.getAttribute("skinWeight"),a=t.get(n),l=a?.get(r);if(!l)throw new Error("Unreachable. attributeUsedIndexSetMap does not know the skin index attribute or the skin weight attribute.");for(const h of l)e.set(i.bones[h],i.boneInverses[h]);return e}function rU(o,t){for(const[e,i]of o.entries()){const s=t.get(e);if(s!=null&&!aU(i,s))return!1}return!0}function oU(o,t,e){const i=new Map;for(const n of t)i.set(n,i.size);const s=new Map;for(const[n,r]of e.entries()){const a=i.get(r);s.set(a,n)}for(let n=0;n<o.count;n++)for(let r=0;r<o.itemSize;r++){const a=Uh(o,n,r),l=s.get(a);bT(o,n,r,l)}o.needsUpdate=!0}function aU(o,t,e){if(e=e||1e-4,o.elements.length!=t.elements.length)return!1;for(let i=0,s=o.elements.length;i<s;i++)if(Math.abs(o.elements[i]-t.elements[i])>e)return!1;return!0}var ed=class{constructor(){this._objectIndexMap=new Map,this._index=0}get(o){return this._objectIndexMap.get(o)}getOrCreate(o){let t=this._objectIndexMap.get(o);return t==null&&(t=this._index,this._objectIndexMap.set(o,t),this._index++),t}};function lU(o){var t,e,i,s;const n=new Ke;n.name=o.name,n.setIndex(o.index);for(const[r,a]of Object.entries(o.attributes))n.setAttribute(r,a);for(const[r,a]of Object.entries(o.morphAttributes)){const l=r;n.morphAttributes[l]=a.concat()}n.morphTargetsRelative=o.morphTargetsRelative,n.groups=[];for(const r of o.groups)n.addGroup(r.start,r.count,r.materialIndex);return n.boundingSphere=(e=(t=o.boundingSphere)==null?void 0:t.clone())!=null?e:null,n.boundingBox=(s=(i=o.boundingBox)==null?void 0:i.clone())!=null?s:null,n.drawRange.start=o.drawRange.start,n.drawRange.count=o.drawRange.count,n.userData=o.userData,n}function Lx(o){if(Object.values(o).forEach(t=>{t?.isTexture&&t.dispose()}),o.isShaderMaterial){const t=o.uniforms;t&&Object.values(t).forEach(e=>{const i=e.value;i?.isTexture&&i.dispose()})}o.dispose()}function hU(o){const t=o.geometry;t&&t.dispose();const e=o.skeleton;e&&e.dispose();const i=o.material;i&&(Array.isArray(i)?i.forEach(s=>Lx(s)):i&&Lx(i))}function uU(o){o.traverse(hU)}function cU(o,t){var e,i;console.warn("VRMUtils.removeUnnecessaryJoints: removeUnnecessaryJoints is deprecated. Use combineSkeletons instead. combineSkeletons contributes more to the performance improvement. This function will be removed in the next major version.");const s=(e=t?.experimentalSameBoneCounts)!=null?e:!1,n=[];o.traverse(l=>{l.type==="SkinnedMesh"&&n.push(l)});const r=new Map;let a=0;for(const l of n){const u=l.geometry.getAttribute("skinIndex");if(r.has(u))continue;const c=new Map,d=new Map;for(let p=0;p<u.count;p++)for(let f=0;f<u.itemSize;f++){const m=Uh(u,p,f);let g=c.get(m);g==null&&(g=c.size,c.set(m,g),d.set(g,m)),bT(u,p,f,g)}u.needsUpdate=!0,r.set(u,d),a=Math.max(a,c.size)}for(const l of n){const u=l.geometry.getAttribute("skinIndex"),c=r.get(u),d=[],p=[],f=s?a:c.size;for(let g=0;g<f;g++){const y=(i=c.get(g))!=null?i:0;d.push(l.skeleton.bones[y]),p.push(l.skeleton.boneInverses[y])}const m=new pa(d,p);l.bind(m,new ht)}}function dU(o){const t=new Map;o.traverse(e=>{var i,s,n,r;if(!e.isMesh)return;const a=e,l=a.geometry,h=l.index;if(h==null)return;const u=t.get(l);if(u!=null){a.geometry=u;return}const c=Object.values(l.attributes)[0].count,d=new Array(c);let p=0;const f=h.array;for(let _=0;_<f.length;_++){const v=f[_];d[v]||(d[v]=!0,p++)}if(p===c)return;const m=[],g=[];let y=0;for(let _=0;_<d.length;_++)if(d[_]){const v=y++;m[_]=v,g[v]=_}const x=new Ke;x.name=l.name,x.morphTargetsRelative=l.morphTargetsRelative,l.groups.forEach(_=>{x.addGroup(_.start,_.count,_.materialIndex)}),x.boundingBox=(s=(i=l.boundingBox)==null?void 0:i.clone())!=null?s:null,x.boundingSphere=(r=(n=l.boundingSphere)==null?void 0:n.clone())!=null?r:null,x.setDrawRange(l.drawRange.start,l.drawRange.count),x.userData=l.userData,t.set(l,x);{const _=h.array,v=new _.constructor(_.length);for(let A=0;A<_.length;A++){const T=_[A],w=m[T];v[A]=w}x.setIndex(new It(v,1,!1))}Object.keys(l.attributes).forEach(_=>{const v=l.attributes[_];if(v.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const A=v.array,{itemSize:T,normalized:w}=v,U=new A.constructor(g.length*T);g.forEach((D,V)=>{for(let W=0;W<T;W++)U[V*T+W]=A[D*T+W]}),x.setAttribute(_,new It(U,T,w))});let M=!0;for(const[_,v]of Object.entries(l.morphAttributes)){const A=_;x.morphAttributes[A]=[];for(let T=0;T<v.length;T++){const w=v[T];if(w.isInterleavedBufferAttribute)throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");const U=w.array,{itemSize:D,normalized:V}=w,W=new U.constructor(g.length*D);g.forEach(($,at)=>{for(let J=0;J<D;J++)W[at*D+J]=U[$*D+J]}),M=M&&W.every($=>$===0),x.morphAttributes[A][T]=new It(W,D,V)}}M&&(x.morphAttributes={}),a.geometry=x}),Array.from(t.keys()).forEach(e=>{e.dispose()})}function pU(o){var t;((t=o.meta)==null?void 0:t.metaVersion)==="0"&&(o.scene.rotation.y=Math.PI)}var ho=class{constructor(){}};ho.combineMorphs=tU;ho.combineSkeletons=eU;ho.deepDispose=uU;ho.removeUnnecessaryJoints=cU;ho.removeUnnecessaryVertices=dU;ho.rotateVRM0=pU;/*!
 * @pixiv/three-vrm-core v3.4.1
 * The implementation of core features of VRM, for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-core is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-mtoon v3.4.1
 * MToon (toon material) module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier v3.4.1
 * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-materials-v0compat v3.4.1
 * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-node-constraint v3.4.1
 * Node constraint module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-node-constraint is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 *//*!
 * @pixiv/three-vrm-springbone v3.4.1
 * Spring bone module for @pixiv/three-vrm
 *
 * Copyright (c) 2019-2025 pixiv Inc.
 * @pixiv/three-vrm-springbone is distributed under MIT License
 * https://github.com/pixiv/three-vrm/blob/release/LICENSE
 */const ST={idle_pool:{animations:[{clipName:"Idle_nomal.fbx",weight:60},{clipName:"Looking Around.fbx",weight:5},{clipName:"Hands on waist.fbx",weight:5},{clipName:"Arms crossed.fbx",weight:5},{clipName:"Neck Stretching.fbx",weight:2,cooldown:30},{clipName:"Arm Stretching.fbx",weight:2,cooldown:30},{clipName:"Yawning.fbx",weight:1,cooldown:45,duration:5}],transitionTime:1.5,minPlayTime:3,maxPlayTime:30},thinking_pool:{animations:[{clipName:"Thinking.fbx",weight:35},{clipName:"Hand To Chin.fbx",weight:25},{clipName:"Looking Up Thinking.fbx",weight:20},{clipName:"Head Scratch.fbx",weight:15,cooldown:20},{clipName:"Deep Thought.fbx",weight:5}],transitionTime:1.5,minPlayTime:2,maxPlayTime:8},speaking_pool:{animations:[{clipName:"talk1.fbx",weight:35},{clipName:"talk2.fbx",weight:25},{clipName:"talk3.fbx",weight:25}],transitionTime:1.5,minPlayTime:2,maxPlayTime:8},listening_pool:{animations:[{clipName:"Listening.fbx",weight:50}],transitionTime:1.5,minPlayTime:3,maxPlayTime:10}};class fU{model;currentPoolName="";currentClipName="";clipTimer=0;nextChangeTime=0;isBlending=!1;blendTimer=0;currentTransitionTime=0;gestureMixer;constructor(t){this.model=t,this.gestureMixer=new pA(t.vrm?.scene)}setPool(t){this.currentPoolName!==t&&(console.log(`[AnimPool] Switching to pool: ${t}`),this.currentPoolName=t,this.clipTimer=0,this.selectAndPlayNextClip(!0))}triggerGesture(t,e=.3){const i=this.model.actions[t];i&&i.reset().setLoop(E0,1).fadeIn(e).play()}update(t){this.gestureMixer.update(t),this.currentPoolName&&(this.clipTimer+=t,this.isBlending&&(this.blendTimer+=t,this.blendTimer>=this.currentTransitionTime&&(this.isBlending=!1,this.blendTimer=0)),this.clipTimer>=this.nextChangeTime&&!this.isBlending&&this.selectAndPlayNextClip())}selectAndPlayNextClip(t=!1){const e=ST[this.currentPoolName];if(!e)return;const i=this.weightedRandomSelect(e.animations);if(i){if(!t&&i.clipName===this.currentClipName)for(let s=0;s<3;s++){const n=this.weightedRandomSelect(e.animations);if(n&&n.clipName!==this.currentClipName){this.playClip(n,e);return}}this.playClip(i,e)}}weightedRandomSelect(t){const e=Date.now()/1e3,i=t.filter(r=>r.cooldown&&r.lastPlayedTime?e-r.lastPlayedTime>=r.cooldown:!0);if(i.length===0)return null;const s=i.reduce((r,a)=>r+a.weight,0);if(s===0)return null;let n=Math.random()*s;for(const r of i)if(n-=r.weight,n<=0)return r.lastPlayedTime=e,r;return i[0]}playClip(t,e){if(!this.model.actions[t.clipName]){console.warn(`[AnimPool] Animation not found: ${t.clipName}`);return}if(this.currentClipName!==t.clipName){console.log(`[AnimPool] Playing: ${t.clipName} (weight: ${t.weight})`),this.currentClipName&&this.model.actions[this.currentClipName]&&this.model.actions[this.currentClipName].fadeOut(e.transitionTime);const s=this.model.actions[t.clipName];s.reset(),s.setLoop(C0,1/0),s.fadeIn(e.transitionTime),s.play(),this.currentClipName=t.clipName,this.clipTimer=0,this.isBlending=!0,this.blendTimer=0,this.currentTransitionTime=e.transitionTime}const i=t.duration||this.getRandomPlayTime(e);this.nextChangeTime=Math.max(i,e.minPlayTime)}getRandomPlayTime(t){return t.minPlayTime+Math.random()*(t.maxPlayTime-t.minPlayTime)}getCurrentClip(){return this.currentClipName}isPlaying(){return!!this.currentClipName&&!this.isBlending}}const id={idle:{headTilt:new E(0,0,0),neckTilt:new E(0,0,0),spineRotation:new E(0,0,0),expressions:{neutral:1},gazePattern:"random",gazeIntensity:.6,animationPool:"idle_pool",blendInTime:.8,blendOutTime:.5},thinking:{headTilt:new E(.1,-.1,.05),neckTilt:new E(.05,-.08,0),spineRotation:new E(-.02,0,0),expressions:{neutral:.2,fun:.3,surprised:.1},gazePattern:"upward",gazeIntensity:.7,animationPool:"thinking_pool",blendInTime:.6,blendOutTime:.4},listening:{headTilt:new E(-.15,.05,0),neckTilt:new E(-.08,0,0),spineRotation:new E(.05,0,0),expressions:{neutral:.3,relaxed:.7},gazePattern:"mouse_follow",gazeIntensity:.9,animationPool:"listening_pool",blendInTime:.4,blendOutTime:.3},speaking:{headTilt:new E(0,0,0),neckTilt:new E(0,0,0),spineRotation:new E(0,0,0),expressions:{happy:.4,neutral:.6},gazePattern:"forward",gazeIntensity:.8,animationPool:"speaking_pool",blendInTime:.3,blendOutTime:.2}};class sO{model;vrm;animationPoolManager;currentState="idle";stateTimer=0;transitionTimer=0;isTransitioning=!1;headBone;neckBone;spineBone;leftHandBone;rightHandBone;targetPoses=new Map;originalPoses=new Map;isListening=!1;isSpeaking=!1;lastUserInput=0;gestureQueue=[];constructor(t,e){this.model=t,this.vrm=e,this.animationPoolManager=new fU(t),this.initializeBoneReferences(),this.cacheOriginalPoses(),this.setState("idle",!0)}initializeBoneReferences(){this.headBone=this.vrm.humanoid.getRawBoneNode("head"),this.neckBone=this.vrm.humanoid.getRawBoneNode("neck"),this.spineBone=this.vrm.humanoid.getRawBoneNode("spine"),this.leftHandBone=this.vrm.humanoid.getRawBoneNode("leftHand"),this.rightHandBone=this.vrm.humanoid.getRawBoneNode("rightHand")}cacheOriginalPoses(){const t=[this.headBone,this.neckBone,this.spineBone,this.leftHandBone,this.rightHandBone].filter(Boolean);for(const e of t)this.originalPoses.set(e,e.quaternion.clone())}setState(t,e=!1){!e&&this.currentState===t||(this.currentState=t,this.stateTimer=0,this.transitionTimer=0,this.isTransitioning=!0,this.applyStateConfiguration(t))}setListening(t){this.isListening=t,t&&(this.lastUserInput=Date.now())}setSpeaking(t){this.isSpeaking=t}triggerGesture(t){this.gestureQueue.push(t)}getCurrentState(){return this.currentState}evaluateTransitions(){const e=[{from:"idle",to:"speaking",condition:()=>this.isSpeaking,priority:100},{from:"listening",to:"speaking",condition:()=>this.isSpeaking,priority:100},{from:"thinking",to:"speaking",condition:()=>this.isSpeaking,priority:100},{from:"idle",to:"listening",condition:()=>this.isListening,priority:80},{from:"thinking",to:"listening",condition:()=>this.isListening,priority:80},{from:"speaking",to:"idle",condition:()=>!this.isSpeaking,priority:40},{from:"thinking",to:"idle",condition:()=>this.stateTimer>2&&!this.isSpeaking,priority:40},{from:"listening",to:"idle",condition:()=>!this.isListening&&Date.now()-this.lastUserInput>5e3,priority:40}].filter(i=>i.from===this.currentState&&i.condition()).sort((i,s)=>s.priority-i.priority)[0];e&&this.setState(e.to)}applyStateConfiguration(t){const e=id[t];this.applyExpressions(e.expressions),this.configureGaze(e),e.animationPool?this.animationPoolManager.setPool(e.animationPool):e.baseAnimation&&this.handleAnimationChange(e)}setupPoseTargets(t){if(this.headBone){const e=new je().setFromEuler(new Ye(t.headTilt.x,t.headTilt.y,t.headTilt.z)),i=this.originalPoses.get(this.headBone);this.targetPoses.set(this.headBone,i.clone().multiply(e))}if(this.neckBone){const e=new je().setFromEuler(new Ye(t.neckTilt.x,t.neckTilt.y,t.neckTilt.z)),i=this.originalPoses.get(this.neckBone);this.targetPoses.set(this.neckBone,i.clone().multiply(e))}if(this.spineBone){const e=new je().setFromEuler(new Ye(t.spineRotation.x,t.spineRotation.y,t.spineRotation.z)),i=this.originalPoses.get(this.spineBone);this.targetPoses.set(this.spineBone,i.clone().multiply(e))}}applyExpressions(t){}configureGaze(t){switch(t.gazePattern){case"mouse_follow":this.model.startMouseFollowing();break;case"random":this.model.stopMouseFollowing(),this.model.changeGaze();break;case"upward":this.model.stopMouseFollowing(),this.model.changeGaze({x:.5,y:1.5,z:.8});break;case"forward":this.model.stopMouseFollowing(),this.model.changeGaze({x:.2,y:.2,z:1});break}}handleAnimationChange(t){if(t.baseAnimation&&this.model.actions[t.baseAnimation]){for(const i of Object.values(this.model.actions))i.fadeOut(t.blendOutTime);this.model.actions[t.baseAnimation].reset().fadeIn(t.blendInTime).play()}}update(t){if(this.stateTimer+=t,this.handleGestures(),this.animationPoolManager.update(t),this.evaluateTransitions(),this.isTransitioning){this.transitionTimer+=t,this.updatePoseBlending(t);const e=id[this.currentState];this.transitionTimer>=e.blendInTime&&(this.isTransitioning=!1)}this.updateStateSpecificBehavior(t)}handleGestures(){if(this.gestureQueue.length>0){const t=this.gestureQueue.shift();t&&this.animationPoolManager.triggerGesture(t)}}updatePoseBlending(t){const e=id[this.currentState],i=Math.min(this.transitionTimer/e.blendInTime,1),s=this.smoothStep(i);for(const[n,r]of this.targetPoses){const a=this.originalPoses.get(n);n.quaternion.slerpQuaternions(a,r,s),n.updateMatrixWorld(!0)}}updateStateSpecificBehavior(t){switch(this.currentState){case"thinking":if(this.headBone&&Math.random()<.02){const e=new je().setFromAxisAngle(new E(0,1,0),(Math.random()-.5)*.1);this.headBone.quaternion.multiply(e)}break}}adjustAnimationWeight(t,e,i){const s=ST[t];if(!s)return;const n=s.animations.find(r=>r.clipName===e);n&&(n.weight=i,console.log(`[AnimPool] Updated ${e} weight to ${i}`))}smoothStep(t){return t*t*(3-2*t)}getDebugInfo(){return{currentState:this.currentState,stateTimer:this.stateTimer.toFixed(2),isTransitioning:this.isTransitioning,transitionTimer:this.transitionTimer.toFixed(2),currentClip:this.animationPoolManager.getCurrentClip(),gestureQueueLength:this.gestureQueue.length,isListening:this.isListening,isSpeaking:this.isSpeaking}}}export{pa as $,Ot as A,ya as B,lt as C,VD as D,Ke as E,ED as F,Kb as G,ta as H,iD as I,zh as J,bp as K,fa as L,hD as M,SU as N,Xt as O,DD as P,rt as Q,Jf as R,Fs as S,AU as T,nD as U,E as V,oD as W,Jr as X,Qx as Y,zt as Z,Qb as _,RU as a,ND as a0,tS as a1,sh as a2,nd as a3,KU as a4,da as a5,ah as a6,oh as a7,Gh as a8,di as a9,ho as aA,ZD as aB,KD as aC,j as aD,Q0 as aE,is as aF,oo as aG,J1 as aH,JD as aI,sF as aJ,tO as aK,sd as aa,kh as ab,Ws as ac,ds as ad,YD as ae,eO as af,iO as ag,Fi as ah,aD as ai,cD as aj,pD as ak,TU as al,GD as am,Ko as an,Vb as ao,yt as ap,s0 as aq,ps as ar,tx as as,je as at,z0 as au,te as av,QD as aw,sO as ax,pA as ay,Ye as az,NU as b,HD as c,wt as d,Mp as e,BD as f,S as g,ht as h,Bm as i,CD as j,$D as k,It as l,QU as m,sb as n,wU as o,bU as p,ib as q,tm as r,Kf as s,Ea as t,sS as u,fs as v,Kr as w,vS as x,$f as y,ud as z};
